[
    "age_sliced, extent, path, outline_curves)\n        return image_sample\n\n    def regular_polygon_ring_arc(image, dpu=1000.0, sides_per_segment=1, inner_radius=0.5, outer_radius=0.8, sample",
    "ser.parse(code)\n    assignments = []\n    for node in tree.body:\n        if isinstance(node, ast.Assign):\n            assignments.append(node.value)\n    return assignments\n\ndef find_assignments_from_file(filename):\n    assignments = []\n    with open(filename) as f",
    "rouge_score(generated, expected)\n        return scores['rouge-l']['r']\n",
    ".shape[0]\n        width = image.shape[1]\n        image_ar = width / height\n        x1 = np.min(curve[:, 0])\n        x2 = np.max(curve[:, 0])\n        y1 = np.min(curve[:, 1])\n        y2 =",
    "rent2[:, 0], curve2[:, 1])).T\n            curve2 = CurveTransforms.tight_map_cartesian_to_polar(curve2, (radius2 - width2, radius2), (theta1, theta1 + (theta2-theta1)/periods2))\n        curve2 =",
    " y1, y2)\n        image = cv2.resize(image, extent, interpolation=cv2.INTER_AREA)\n        image = image.astype(np.float32)\n        image = image.reshape(1, 3, height, width)\n        image = image.transpose((2,",
    "rser[:, 0])\n        y1 = np.min(curve[:, 1])\n        y2 = np.max(curve[:, 1])\n        extent = (x1, x2, y1, y2)\n        x_abs = x2 - x1\n        y_abs = y2",
    "transform_curve(curve)\n        return x_bounds, y_bounds, rho, theta",
    " x + y * y)\n        theta = np.arctan2(y, x)\n        return np.vstack((rho, theta))\n\n    def polar_to_cartesian(x, y):\n        rho = np.sqrt(x * x + y * y)\n        theta = np.ar",
    "ample(image, extent, path)\n        outline_curves = [curve]\n        outline_curves = [curve]\n        outline_curves = [curve]\n        outline_curves = [curve]\n        outline_curves = [curve]\n        outline_curves = [curve]\n        outline_",
    "tring(start_pos, end_pos)\n            if result:\n                examples.append(result)\n        if examples:\n            return examples\n        return []\n\n    def extract_code_sections(block: str, max_characters: int = 100, min_context_lines: int = 1,",
    "rint(np.ceil(np.log2(repetitions))))\n        elif delta_angle is None:\n            repetitions = np.maximum(1, repetitions)\n            angle = None\n        elif delta_angle is None:\n            repetitions = np.maximum(1, repetitions)\n            angle = delta",
    ", sample_rotation, global_rotation)\n        image_sample = ImageSample(image_sliced, extent, path, outline_curves)\n        ImageSampleTransformer.mirror_persistent(image_sample, np.pi/2)\n        ImageSampleTransformer.circular_placement_additive(image_sample,",
    "_line][start_idx]\n            if char == '(':\n                parentheses_balance -= 1\n            elif char == ')':\n                parentheses_balance -= 1\n            elif char == '[':\n                parentheses_balance -= 1\n            elif char == ']':\n                parentheses_balance -= 1\n            elif char == '{':",
    "olumn_conditions(block, max_characters, min_context_lines, max_context_lines)\n        return [\n            (start_pos, end_pos, condition)\n            for start_pos, end_pos, condition in conditions\n        ]\n\n    def extract_section(block: str, start_",
    "curve2, curve1))]\n        elif left_side:\n            outline_curves = [np.vstack((curve1, curve2))]\n        else:\n            outline_curves = [curve2, curve1]\n        curve = np.vstack((curve1, curve2))\n        (image, extent",
    "_list\n\n    @staticmethod\n    def custom_ring_arc(image, dpu, inner_curve, outer_curve, theta1, theta2, left_side, right_side):\n        # Create a random curve\n        curve = CurveGenerator.random_edge(dpu, theta1, theta2,",
    "ape[1]\n        image_ar = width / height\n        x1 = np.min(curve[:, 0])\n        x2 = np.max(curve[:, 0])\n        y1 = np.min(curve[:, 1])\n        y2 = np.max(curve[:, 1])\n       ",
    " 1] + [prefix])\n            middle = '\\n'.join(lines[start: end] + [middle])\n            suffix = '\\n'.join([suffix] + lines[call['end_line']:end])\n            examples.append((prefix, middle, suffix))\n        return examples\n\n    def extract_function",
    "lular(theta, rho)\n        curve = curve.transform(offset)",
    "rator.edge_type1(half=half), 1, outer_radius, edge_width, \"cartesian\")\n        image_sliced = image.crop(inner_curve)\n        image_sliced = image_sliced.crop(outer_curve)\n        image_sliced = image_sliced.crop",
    ".translate(old_x_bounds[0], -old_y_bounds[0])\n        transform = transform.scale((new_x_bounds[1]-new_x_bounds[0])/(old_x_bounds[1]-old_x_bounds[0]),\n                                    (new_y",
    "deepcopy(base_curves)\n            curves.extend(new_curves)\n        return curves\n\n    def translate_curves(curves: \"list\", step: \"list\", scale: \"float\"):\n        for curve in curves:\n            curve.translate(step, scale)\n\n    def translate_curves_",
    "(np.linspace(0, 1, 1000))\n            curve2 = np.array(np.linspace(0, 1, 1000))\n        else:\n            curve1 = inner_curve\n            curve2 = outer_curve\n        (curve1, periods1, radius",
    "curve2]\n        outline_curves = [outline_curves[0], outline_curves[1]]\n        outline_curves = [outline_curves[0], outline_curves[2]]\n        outline_curves = [outline_curves[1], outline_curves[2",
    "ray(scale, 0, 2*np.pi)\n        curves = []\n        for i in range(repetitions):\n            curves.append(curves[i].rotate(angle))",
    "er, global_rotation_offset, use_flip, flip_angle, reverse_rotation, calculate_overlap)\n        image_sample.AdditiveTransforms = additive_transforms\n        if calculate_overlap:\n            (new_persistent_paths, new_persistent_transforms, outline_curves) = paths_",
    "lor\n        else:\n            outline_color = [0.0, 0.0, 0.0]\n        for i in range(len(self.PersistentClipPaths)):\n            im = ax.imshow(self.Image, extent=self.Extent, origin=\"upper\", cmap=\"gray\", clip_",
    "curve1[:, 0], curve1[:, 1])).T\n                curve1 = CurveTransforms.tight_map_cartesian_to_polar(curve1, (radius1 - width1, radius1), (theta1, theta1 + (theta2-theta1)/periods1))\n            curve1 =",
    "_list\n\n    def sample_from_curve(self, image: np.ndarray, curve: np.ndarray, dpu: float) -> (np.ndarray, (float, float, float, float), Path, List[np.ndarray]):\n        (image, extent, path) = self.sample_",
    ")\n        indentation = line[:indentation_length]\n        return indentation, line[indentation_length:]\n\n    def split_code_text(line: str) -> Tuple[str, str]:\n        \"\"\"Separate code text from the rest of the line.\"\"\"\n        code_text = line[1:]\n        return code_",
    "for i in range(segments + 1)])\n        outer_rho = np.array([outer_radius - ((i + aligned) % 2) * teeth_width for i in range(segments + 1)])\n        curve1 = np.vstack((inner_rho, theta)).T\n        curve",
    "ne(np.array([[-1, 0], [-1, 1], [0, 2]]))\n        elif leaf_type == \"cartesian\":\n            leaf = CurveGenerator.bezier(np.array([[-1, 0], [-1, 1], [0, 2]]))",
    " flip_angle).translate(radius, 0).rotate(i * angle + global_rotation_offset)\n            transforms.append(trans_data)\n        return transforms\n\n    def rotate_transforms(self, transforms: List[Affine2D]):\n        transforms = [t.rotate(t.translate(t.",
    "ame(image, curve, dpu, width, height)",
    "l(curve)\n        return curve",
    "nted)\n        length = len(expected)\n        if length!= len(generated):\n            return None\n        total = defaultdict(float)\n        counts = defaultdict(int)\n        for gen, exp in zip(generated, expected):\n            for key, value in self.evaluate(gen, exp, check_syntax).",
    "source_segment(code, node.value)\n            start_line = node.value.test.lineno\n            start_col = node.value.test.col_offset\n            end_line = node.value.test.end_lineno\n            end_col = node.value.test.end_col_",
    "nts.shape[1], 3), dtype=np.uint8)\n    for i in range(num_segments):\n        color_image[segments == i] = colors[i]\n    return color_image",
    "nge(min_left, min_right)\n                if split_idx == min_left:\n                    break\n                if split_idx == min_right:\n                    break\n                if suffix[split_idx - 1:split_idx + 1]!= r'\\n':\n                    break\n            prefix += middle[:",
    "gion2_id]\n    region1_info['neighbors'] = set()\n    region2_info['neighbors'] = set()\n    for neighbour in region1_info['neighbors']:\n        if neighbour < region1_id:\n            region1_info['neighbors'].add(neighbour)\n        else:\n           ",
    "te(radius, 0).rotate(i * angle + global_rotation_offset).translate(radius, 0).rotate(i * angle + global_rotation_offset)\n            else:\n                trans_data = Affine2D().rotate(local_rotation_offset).scale(1, -1",
    "ds[1] - (y_bounds[0]))\n        if x_bounds[0] == x_bounds[1]:\n            theta = np.ones(curve_cartesian[:, 0].shape) * theta_bounds[0]\n        else:\n            theta = (curve_cartesian[:, 0",
    "heta1)/n_periods\n        curve = CurveTransforms.polar_to_cartesian(np.vstack((radius, theta)).T)\n        CurveTransforms.translate_single(curve, offset[0], offset[1], inplace=True)\n        return curve\n\n    def sine_wave_circular_",
    "rator.random_edge(grid_size, step_size, interpolation)\n        inner_curve = (curve1, 1, inner_radius, width, \"cartesian\")\n        outer_curve = (curve2, 1, outer_radius, width, \"cartesian\")\n        (image,",
    "arse_source(code)\n        self.code = self.code.replace(\n            \"def\", \"def \" + self.code.split(\"def \")[-1]\n        )\n        self.code = self.code.replace(\n            \"def\", \"def \" + self.code.split(\"def",
    "curve)\n        outer_curve = (curve2, 1, outer_radius, width, \"cartesian\")\n        (image, extent, path, outline_curves) = ImageSlicer.custom_ring_arc(image, dpu, inner_curve, outer_curve, theta1, theta",
    "er()\n    visitor.visit(tree)\n    return visitor.function_calls\n",
    "onamond]\n        for i in range(subdivisions[0]):\n            for j in range(subdivisions[1]):\n                diamonds.append(base_diamond.interpolate(i, j))\n        if fill:\n            for curve in diamonds:\n                figure.add_curve(curve",
    "te_additive(image_sample)\n            image_sample.set_custom_outline_curves(outline_curves)"
]