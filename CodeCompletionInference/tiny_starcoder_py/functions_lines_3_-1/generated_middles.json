[
    "return np.random.uniform(low=0, high=1, size=grid_size) * grid_step + grid_size * grid_step * np.random.uniform(low=0, high=1, size=grid_size) * np.random.uniform(low=0, high=1, size=grid_size) * np.random.uniform(low=0, high=1, size=grid_size) * np.random.uniform(low=0, high=1, size=grid_size) * np.random.uniform(low=0, high=1, size=grid_size) * np.random.uniform(low=0, high=1, size=grid_size) * np.random.uniform(low=0, high=1, size=",
    "_list\n\n    def sample_from_curve(self, image, curve, dpu=1000.0):\n        \"\"\"\n        Sample a curve from a given image.\n\n        Parameters\n        ----------\n        image : numpy.ndarray\n            The image to sample from.\n        curve : numpy.ndarray\n            The curve to sample from.\n        dpu : float\n            The dpu to use for sampling.\n\n        Returns\n        -------\n        image : numpy.ndarray\n            The image sampled from the curve.\n        extent : numpy.ndarray\n            The extent of the image.\n        path : numpy.ndarray\n            The path of the image.\n        outline_curves_list : list\n            The outline curves.\n        \"\"\"\n        image = np.array(image)\n        image = image.astype(np.float32)\n        image = image.reshape((image.shape[0],",
    "_to_node(assignment_info, node)\n\n    def get_assignment_info(self, node):\n        if isinstance(node, ast.Assign):\n            return self.assignments[node.targets[0]]\n        elif isinstance(node, ast.AugAssign):\n            return self.assignments[node.target]\n        elif isinstance(node, ast.AnnAssign):\n            return self.assignments[node.value]\n        else:\n            return None\n\n    def get_assignment_info_for_node(self, node):\n        if isinstance(node, ast.Assign):\n            return self.get_assignment_info(node.targets[0])\n        elif isinstance(node, ast.AugAssign):\n            return self.get_assignment_info(node.target)\n        elif isinstance(node, ast.AnnAssign):\n            return self.get",
    "results['meteor'] = self.meteor_score(generated, expected)\n        results['bert'] = self.bert_score(generated, expected)\n        if check_syntax:\n            results['syntax_valid'] = self.syntax_validity(generated)\n        return results\n\n    def exact_match(self, generated, expected):\n        return len(generated) == len(expected) and self.exact_match_syntax(generated, expected)\n\n    def exact_match_syntax(self, generated, expected):\n        return len(generated) == len(expected) and self.exact_match_syntax_syntax(generated, expected)\n\n    def meteor_score(self, generated, expected):\n        return len(generated) == len(expected) and self.meteor_score_syntax(generated, expected)\n\n    def meteor_score_",
    "for line in lines:\n            if len(line) > max_characters:\n                continue\n            if len(line) < min_context_lines:\n                continue\n            if len(line) > max_context_lines:\n                continue\n            if len(line) == 0:\n                continue\n            if len(line) == 1:\n                continue\n            if len(line) == 2:\n                result = (line[0], line[1], line[2])\n                if result not in assignments:\n                    assignments.append(result)\n            else:\n                result = (line[0], line[1], line[2], line[3])\n                if result not in assignments:",
    "curve = np.array(curve)\n        x_fine = np.linspace(0, 1, samples)\n        y_fine = curve",
    "for i in range(len(self.Curves)):\n            if self.PlotType[i] == \"line\":\n                ax.plot(self.Curves[i][:, 0], self.Curves[i][:, 1], color=\"k\", zorder=self.z_order)\n            elif self.PlotType[i] == \"line_2\":\n                ax.plot(self.Curves[i][:, 0], self.Curves[i][:, 1], color=\"k\", zorder=self.z_order)\n            elif self.PlotType[i] == \"line_3\":\n                ax.plot(self.Curves[i][:, 0], self.Curves[i][:, 1], color=\"k\", zorder=self.z_order)\n           ",
    "image_sliced = image.slice(segments, inner_radius, outer_radius)\n        ImageSampleTransformer.ring_additive(image_sliced, 2 * segments, None,\n                                          rotation_offset=sample_rotation, use_flip=True,\n                                          flip_angle=(2 * sample_rotation + np.pi / segments) / 2)\n        return image_sliced\n\n    def test_ring_with_rotation(image, dpu=1000.0, segments=8, inner_radius=0.5, outer_radius=0.8, width=0.05, sample_rotation=0.0) -> ImageSample:\n        image_sliced = image.slice(segments, inner_radius, outer_radius)\n        ImageSampleTransformer.ring_additive(image_sliced, 2",
    "new_curves.append(x)\n            base_curves = new_curves\n        return curves\n\n    def translate_curves(curves: \"list\", step: \"list\", scale: \"float\"):\n        for curve in curves:\n            curve.translate(step[0], step[1], scale)\n\n    def translate_curves_with_scale(curves: \"list\", step: \"list\", scale: \"float\"):\n        for curve in curves:\n            curve.translate(step[0], step[1], scale)\n\n    def translate_curves_with_scale_and_scale(curves: \"list\", step: \"list\", scale: \"float\"):\n        for curve in curves:\n            curve.translate(step[0], step[1], scale)\n            curve.translate(step[0], step",
    "self.X_bounds = None\n        self.Y_bounds = None\n        self.Rho_bounds = None\n        self.Theta_bounds = None",
    "ax.fill(self.Curves[i][:, 0], self.Curves[i][:, 1], color=\"w\", zorder=self.z_order)\n                ax.plot(self.Curves[i][:, 0], self.Curves[i][:, 1], color=\"k\", solid_capstyle='round',",
    "func_name = node.func.id\n        if func_name:\n            self.function_calls.append({\n                \"function\": func_name,\n                \"arguments\": node.args,\n                \"start_line\": node.lineno,\n                \"end_line\": node.end_lineno,\n                \"col_offset\": node.col_offset,\n                \"end_col_offset\": node.end_col_offset\n            })\n        self.generic_visit(node)\n\n    def visit_Assign(self, node):\n        target = node.targets[0]\n        if isinstance(target, ast.Name):\n            target = target.id\n        if target:\n            self.function_calls.append({\n                \"function\": target,\n                \"arguments\": node.targets,\n                \"start_line\": node.lineno,\n                \"end_",
    "self.Extent = extent\n        self.MainClipPath = main_clip_path\n        self.LocalOutlineCurves = local_outline_curves",
    "scales = scale*np.ones(repetitions, 2)\n        else:\n            scales = scale*np.ones(repetitions, 2, 2)\n        return curves, scales\n\n    def scale_curves(curves: \"list\", scale: \"list\"):\n        if len(curves) == 0:\n            return\n        if len(curves) == 1:\n            curves.append(scale)\n        else:\n            for i in range(len(curves)):\n                curves[i] = np.array(curves[i]) * scale\n\n    def rotate_curves(curves: \"list\", angle: \"float\"):\n        if len(curves) == 0:\n            return\n        if len(curves) == 1:\n            curves.append(angle)\n        else",
    "current_line,\n            function_call['start_line'],\n            function_call['end_line']\n        )\n        prefix = lines[current_line][start_idx]\n        arguments = ', '.join(function_call['arguments'])\n        suffix = lines[function_call['end_line'] - 1][end_idx:]\n        return prefix, arguments, suffix\n\n    def extract_function_call_details_with_parens(lines: List[str], function_call: dict) -> Tuple[str, str, str]:\n        \"\"\"Extract the components of a function call: prefix, arguments, and suffix.\"\"\"\n        current_line, start_idx, end_idx = (\n            current_line,\n            function_call['start_line'],\n            function_call['end_line']\n        )\n        parentheses_balance = ",
    "x_clip = np.clip(x_abs, 0, width)\n        y_clip = np.clip(y_abs, 0, height)\n        clip_ar = np.clip(y_clip - y1, 0, height)\n        if clip_ar < 0:\n            clip_ar = 0\n        if clip_ar > width:\n            clip_ar = width\n        if clip_ar < 0:\n            clip_ar = 0\n        if clip_ar > height:\n            clip_ar = height\n        if clip_ar < 0:\n            clip_ar = 0\n        if clip_ar > 0:\n            clip_ar = 0\n        if clip_ar < 0:\n            clip_ar = 0\n        if clip_ar > 0:\n            clip_",
    "rho = np.ones(curve_cartesian[:, 0].shape) * rho_bounds[1]\n        if x_bounds[0] == x_bounds[1]:\n            theta = np.ones(curve_cartesian[:, 1].shape) * theta_bounds[0]\n        else:",
    "function_call['start_line'] - 1,\n            function_call['end_line'] - 1\n        )\n        prefix = lines[current_line][start_idx]\n        arguments = ', '.join(function_call['arguments'])\n        suffix = lines[current_line][end_idx:]\n        return prefix, arguments, suffix\n\n    def extract_function_call_details_with_parens(lines: List[str], function_call: dict) -> Tuple[str, str, str]:\n        \"\"\"Extract the components of a function call: prefix, arguments, and suffix.\"\"\"\n        current_line, start_idx, end_idx = (\n            function_call['end_line'] - 1,\n            function_call['start_line'] - 1,\n            function_call['end_line'] - ",
    "results = {}\n        results['bleu'] = self.bleu_score(generated, expected)\n        results['rouge'] = self.rouge_score(generated, expected)\n        results['meteor'] = self.meteor_score(generated, expected)\n        results['bert'] = self.bert_score(generated, expected)\n        if check_syntax:\n            results['syntax_valid'] = self.syntax_validity(generated)\n        return results\n\n    def bleu_score(self, generated, expected):\n        return self.score(generated, expected, 'bleu')\n\n    def rouge_score(self, generated, expected):\n        return self.score(generated, expected, 'rouge')\n\n    def meteor_score(self, generated, expected):\n        return self.score(generated, expected,'meteor')\n\n    def b",
    "curve1 = np.vstack((-curve1[:, 0], curve1[:, 1])).T\n                curve1 = CurveTransforms.polar_to_cartesian(curve1)\n            else:\n                curve1 = np.vstack((-curve1[:, 0], curve1[:, 1])).T\n                curve1 = CurveTransforms.polar_to_cartesian(curve1)\n        (curve2, periods2, radius2, width2, coordinate_type2) = outer_curve\n        if coordinate_type2 == \"polar\":\n            curve2 = CurveTransforms.tight_remap_polar_to_polar(curve2, (radius2 - width2, radius2), (theta1, theta1 + (theta2-theta1)/periods2))\n            curve2 = CurveTransforms.polar_to_cartesian(curve2",
    "clip_ar = clip_ar * dpu\n        clip_ar = clip_ar / clip_ar\n        clip_ar = clip_ar * 255\n        clip_ar = np.clip(clip_ar, 0, 255)\n        clip_ar = np.uint8(clip_ar)\n        image_ar = cv2.resize(image_ar, (new_width, new_height))\n        image_ar = cv2.cvtColor(image_ar, cv2.COLOR_BGR2RGB)\n        image_ar = np.expand_dims(image_ar, axis=0)\n        image_ar = np.expand_dims(image_ar, axis=0)\n        image_ar = np.expand_dims(image_ar, axis=0)\n        image",
    "for dataset_name, examples in extract_method(code_blocks, max_value, max_context):",
    "  global_rotation, half, left_edge, right_edge)\n        image_sample = ImageSample(image_sliced, extent, path, outline_curves)\n        return image_sample\n\n    def pit_ring_with_offset(image, dpu=1000.0, segments=8, pits_per_segment=1, inner_radius=0.5, outer_radius=0.8, width=0.8, depth=0.4, gap=0.2, sample_rotation=0.0,\n                               global_rotation=0.0, half=False, left_edge=False, right_edge=False) -> ImageSample:\n        outer_curve = (CurveGenerator.pit(100, width, gap, pits_per_segment), 1,",
    "num_lines_to_extract = min(num_lines, max_characters)\n        if num_lines_to_extract == 0:\n            return None, None, None\n        start_line = start_pos\n        end_line = end_pos\n        if start_line == end_line:\n            return None, None, None\n        if start_line < 0:\n            start_line = 0\n        if end_line < 0:\n            end_line = num_lines\n        if start_line >= num_lines:\n            return None, None, None\n        if end_line >= num_lines:\n            return None, None, None\n        if start_line == end_line:\n            return None, None, None\n        if start_line < 0:\n            start_line = 0\n        if end_line",
    "self.MainClipPath = main_clip_path\n        self.LocalOutlineCurves = local_outline_curves",
    "'area': image[region_mask].sum(),\n            'centroid': image[region_mask].mean(),\n            'centroid_x': image[region_mask].min(),\n            'centroid_y': image[region_mask].max()",
    "y2 = np.max(curve[:, 1])\n        x_abs = x2 - x1\n        y_abs = y2 - y1\n        clip_ar = x_abs / y_abs\n        if clip_ar < image_ar:\n            new_height = np.minimum(int(np.minimum(height, y_abs*dpu)), height-1)\n            new_width = int(new_height * clip_ar)\n        else:\n            new_width = np.minimum(int(np.minimum(width, x_abs*dpu)), width-1)\n            new_height = int(new_width / clip_ar)\n        origin = (np.random.randint(0, width - new_width), np.random.randint(0, height - new_height))\n       ",
    "self.X_bounds = bounds[0]\n            self.Y_bounds = bounds[1]\n            self.Rho_bounds = bounds[2]\n            self.Theta_bounds = bounds[3]\n        else:\n            self.X_bounds = (np.minimum(self.X_bounds[0], bounds[0][0]),\n                             np.maximum(self.X_bounds[1], bounds[0][1]))\n            self.Y_bounds = (np.minimum(self.Y_bounds[0], bounds[1][0]),\n                             np.maximum(self.Y_bounds[1], bounds[1][1]))\n            self.Rho_bounds = (np.minimum(self.Rho_bounds[0], bounds[2][0]),\n                               np.maximum(self.Rho_bounds",
    "'neighbors': set(),\n        'color_histogram': np.zeros(regions[region1_id]['size'] + regions[region2_id]['size']),\n        'color_histogram_min': np.zeros(regions[region1_id]['size'] + regions[region2_id]['size']),\n        'color_histogram_max': np.zeros(regions[region1_id]['size'] + regions[region2_id]['size']),\n        'color_histogram_mean': np.zeros(regions[region1_id]['size'] + regions[region2_id]['size']),\n        'color_histogram_std': np.zeros(regions[region1_id]['size'] + regions[region2_id]['size']),\n        'color_histogram_sum': np.zeros(regions[region1_id",
    "number_of_segments = 1",
    "    if reverse_rotation:\n                angle = -angle\n            transforms = []\n            for i in range(repetitions):\n                if i % 2 == 0 or not use_flip:\n                    trans_data = Affine2D().rotate(i * angle + rotation_offset)\n                else:\n                    trans_data = Affine2D().rotate(-flip_angle).scale(1, -1).rotate(i * angle + flip_angle + rotation_offset)\n                transforms.append(trans_data)\n        else:\n            repetitions = int(np.trunc(2 * np.pi / delta_angle))\n            angle = None\n            if reverse_rotation:\n                angle = -angle\n            transforms = []\n            for i in range(repetitions):\n                if i % 2 == 0 or not use_flip:",
    "conditions.append(((node.test.lineno, node.test.col_offset), (node.test.end_lineno, node.test.col_offset)))\n        elif isinstance(node, ast.For):\n            for child in node.body:\n                conditions.append(((child.lineno, child.col_offset), (child.end_lineno, child.col_offset)))\n        elif isinstance(node, ast.While):\n            for child in node.body:\n                conditions.append(((child.lineno, child.col_offset), (child.end_lineno, child.col_offset)))\n        elif isinstance(node, ast.Assign):\n            target = node.targets[0]\n            if isinstance(target, ast.Name):\n                target = ast.Name(target.id)\n            if isinstance(target, ast.Attribute",
    "for random_split_name, examples_split in examples:\n                        random_split_name = random_split_name.replace(' ', '_')\n                        random_split_name = random_split_name.replace('(', '_')\n                        random_split_name = random_split_name.replace(')', '_')",
    "scales = np.linspace(scale[0], scale[1], repetitions)\n        else:\n            scales = np.linspace(scale[0], scale[1], repetitions)\n        curves = []\n        for i in range(repetitions):\n            curves.append(Transformer.rotate_curves(curves[-1], i*angle))\n        return curves\n\n    def scale_curves(curves: \"list\", scale: \"list\"):\n        for curve in curves:\n            curve.scale(scale[i])\n\n    def rotate_curves(curves: \"list\", angle: \"float\"):\n        for curve in curves:\n            curve.rotate(angle)\n\n    def scale_curves_with_rotation(curves: \"list\", scale: \"list\", rotation: \"float\"):\n        for curve in curves:\n            curve",
    "    dataset_type: str,\n        max_values: List[int],\n        max_context_lines: List[List[str]],",
    "    else:\n            rho = np.ones(curve_cartesian[:, 0].shape) * rho_bounds[1]\n        if x_bounds[0] == x_bounds[1]:\n            theta = np.ones(curve_cartesian[:, 1].shape) * theta_bounds[0]\n        else:\n            theta = (curve_cartesian[:, 1] - x_bounds[0]) / (x_bounds[1] - (x_bounds[0])) * (theta_bounds[1] - theta_bounds[0]) + theta_bounds[0]\n        return np.vstack((rho, theta)).T\n\n    def square_map_polar_to_cartesian(curve_polar, x_bounds, y_bounds, rho_bounds, theta_bounds):\n        if y_bounds",
    "code_blocks=code_blocks,\n            max_characters=max_characters,\n            max_context_lines=max_context_lines,",
    "    scales = scales*np.ones(repetitions)\n        else:\n            scales = np.ones(repetitions)\n        base_curves = copy.deepcopy(curves)\n        Transformer.scale_curves(curves, scales[0])\n        for i in range(1, repetitions):\n            new_curves = copy.deepcopy(base_curves)\n            Transformer.rotate_curves(new_curves, i*angle)\n            Transformer.scale_curves(new_curves, scales[i])\n            curves.extend(new_curves)\n        return curves\n\n    def rotate_curves(curves: \"list\", angle: float):\n        if angle < 0:\n            angle += 2*np.pi\n        for i in range(len(curves)):\n            curves[",
    "curve1 = CurveTransforms.cartesian_to_polar(curve1)\n        curve1 = np.flip(np.vstack([CurveTransforms.rotate_single(curve1, i*(theta2-theta1)/periods1, inplace=False) for i in range(0, periods1)]), 0)\n        if left_side and right_side:\n            outline_curves = [np.vstack((curve1, curve2, np.array([[curve1[0, 0], curve1[0, 1]]])))]\n        elif right_side:\n            outline_curves = [np.vstack((curve1, curve2))]\n        elif left_side:\n            outline_curves = [np.vstack((curve2, curve1))]\n        else:\n            outline_curves = [curve",
    "self.PersistentClipPaths.extend(local_outline_curves)\n        self.PersistentClipPaths.sort()\n        self.PersistentClipPaths.reverse()\n        self.PersistentClipPaths.append(main_clip_path)\n        self.PersistentClipPaths.append(local_outline_curves[0])\n        self.PersistentClipPaths.append(local_outline_curves[1])\n        self.PersistentClipPaths.append(local_outline_curves[2])\n        self.PersistentClipPaths.append(local_outline_curves[3])\n        self.PersistentClipPaths.append(local_outline_curves[4])\n        self.PersistentClipPaths.append(local_outline_curves[5])\n        self.PersistentClipPaths.append(local_outline_curves[6])\n        self",
    "if self.PlotType[i] == \"line\":\n                ax.plot(self.Curves[i][:, 0], self.Curves[i][:, 1], color=\"k\", solid_capstyle='round',\n                         linewidth=self.PlotType[i], zorder=self.z_order)\n            elif self.PlotType[i] == \"scatter\":\n                ax.plot(self.Curves[i][:, 0], self.Curves[i][:, 1], color=\"k\", solid_capstyle='round',\n                         linewidth=self.PlotType[i], zorder=self.z_order)\n            elif self.PlotType[i] == \"bar\":\n                ax.plot(self.Curves[i][:, 0], self.Curves[i][:,",
    "curve2 = CurveTransforms.polar_to_cartesian(curve2)\n        curve2 = np.flip(np.vstack([CurveTransforms.rotate_single(curve2, i*(theta2-theta1)/periods2, inplace=False) for i in range(0, periods2)]), 0)\n        curve2 = CurveTransforms.polar_to_cartesian(curve2)\n        curve2 = np.flip(np.vstack([CurveTransforms.rotate_single(curve2, i*(theta2-theta1)/periods2, inplace=False) for i in range(0, periods2)]), 0)\n        curve2 = CurveTransforms.polar_to_cartesian(curve2)\n        curve2 = np.flip(np.vstack([CurveTransforms.rotate_single(curve2, i",
    "    curve1 = CurveTransforms.cartesian_to_polar(curve1)\n            curve1 = np.flip(np.vstack([CurveTransforms.rotate_single(curve1, i * (theta2-theta1)/periods1, inplace=False) for i in range(0, periods1)]), 0)\n            curve1 = CurveTransforms.cartesian_to_polar(curve1)\n            curve1 = np.flip(np.vstack([CurveTransforms.rotate_single(curve1, i * (theta2-theta1)/periods1, inplace=False) for i in range(0, periods1)]), 0)\n            curve1 = CurveTransforms.cartesian_to_polar(curve1)\n            curve1 = np.flip(np.vstack([CurveTransforms.rotate_single(curve",
    "for block in code_blocks:\n            yield (\n                block,\n                CodeSegmentExtractor.extract_condition_sections(block, max_characters=max_characters, max_context_lines=max_context_lines),\n            )\n\n\nclass CodeSegmentExtractor:\n    def __init__(self, code_blocks: List[str], max_characters: List[int], max_context_lines: List[int]):\n        self.code_blocks = code_blocks\n        self.max_characters = max_characters\n        self.max_context_lines = max_context_lines\n\n    def extract_condition_sections(self, block: str, max_characters: List[int], max_context_lines: List[int]) -> List[Tuple[str, List[Tuple[str, str, str]]]]:\n        return CodeSegment",
    "rotation_offset = 0.0\n            angle = None\n        else:\n            rotation_offset = np.radians(rotation_offset)\n            angle = np.radians(angle)\n        transforms = []\n        for i in range(repetitions):\n            if i % 2 == 0 or not use_flip:\n                trans_data = Affine2D().rotate(i * angle + rotation_offset)\n            else:\n                trans_data = Affine2D().rotate(-flip_angle).scale(1, -1).rotate(i * angle + flip_angle + rotation_offset)\n            transforms.append(trans_data)\n        return transforms\n\n    def rotate(self, transforms: List[Affine2D], use_flip=True, flip_angle=0.0, reverse_rotation=False):\n        if use_",
    "diamonds = []\n        for i in range(subdivisions[0]):\n            for j in range(subdivisions[1]):\n                diamond = Diamond(x_bounds[0] + i * x_delta, y_bounds[0] + j * y_delta, fill=fill)\n                diamonds.append(diamond)\n        return diamonds\n\n    def diamond_figure_curves(x_bounds=(0.0, 1.0), y_bounds=(0.0, 1.0), subdivisions=(3, 3), line_width=1.0, fill=False):\n        x_delta = np.abs(x_bounds[0] - x_bounds[1]) / subdivisions[0]\n        y_delta = np.abs(",
    "number_of_segments = 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "\"\"\"\n        Pit ring.\n\n        :param image: Image to be pited.\n        :param dpu: DPU of the pits.\n        :param segments: Number of pits per segment.\n        :param pits_per_segment: Number of pits per segment.\n        :param inner_radius: Inner radius of the pits.\n        :param outer_radius: Outer radius of the pits.\n        :param width: Width of the pits.\n        :param depth: Depth of the pits.\n        :param gap: Gap of the pits.\n        :param sample_rotation: Rotation of the pits.\n        :param global_rotation: Rotation of the pits.\n        :param half: Half the pits.\n        :param left_edge: Left edge of the pits.\n        :param",
    "    regions = {}\n        for id in image.id:",
    "\"\"\"\n        2D Sine Wave Ring\n        2D Sine Wave Ring with a 2D Sine Wave Ring\n        2D Sine Wave Ring with a 2D Sine Wave Ring with a 2D Sine Wave Ring\n        2D Sine Wave Ring with a 2D Sine Wave Ring with a 2D Sine Wave Ring\n        2D Sine Wave Ring with a 2D Sine Wave Ring with a 2D Sine Wave Ring\n        2D Sine Wave Ring with a 2D Sine Wave Ring with a 2D Sine Wave Ring\n        2D Sine Wave Ring with a 2D Sine Wave Ring with a 2D Sine Wave Ring\n        2D Sine Wave Ring with a 2D Sine Wave Ring with a 2D Sine Wave Ring\n        2"
]