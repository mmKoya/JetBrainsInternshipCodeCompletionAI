[
    "ast.Assign):\n            return\n        elif isinstance(node, ast.AnnAssign",
    "d, region2_id)\n    region1_info = regions[region1_id]\n    region2_info = regions[region2_id]\n    for neighbour in region1_info['neighbors']:\n        if neighbour < region1_id:\n            del similarities[(neighbour, region",
    " curve2))]\n        elif right_side:\n            outline_curves = [np.vstack((curve2, curve1))]\n        elif left_side:\n            outline_curves = [np.vstack((curve1, curve2))]\n        else:\n            outline_curves = [curve",
    "Curves)):\n            if self.PlotType[i] == \"clear\":\n                ax.fill(self.Curves[i][:, 0], self.Curves[i][:, 1], color=\"w\", zorder=self.z_order)\n            elif self.PlotType",
    "Theta_bounds[0], bounds[3][0",
    " curve2, (radius2, radius2+width2), (theta1, theta1 + (theta2-theta1)/periods2))\n            curve2 = CurveTransforms.polar_to_cartesian(curve2)\n        else:\n            curve2 = np.vstack((-curve2[:,",
    "))\n        y_bounds = (np.min(curve[:, 2]), np.max(curve[:, 2]))\n        return CurveTransforms.remap_c2c(curve, x_bounds, y_bounds, extent[0:2], extent[2:4])\n\n    def fit_",
    "ransform.T)))\n        CurveTransforms.translate_single(curve, offset[0], offset[1], inplace=True)\n        return curve\n\n    def regular_polygon_2d(n, radius=1.0, offset=(0.0, 0.0)):\n        theta = np",
    "d, path, outline_curves)\n        return image_sample\n\n    def ring_type2(image, dpu=1000.0, segments=8, inner_radius=0.5, outer_radius=0.8, edge_width=0.05,",
    "ze, interpolation)\n        curve2 = CurveGenerator.random_edge(grid_size, step_size, interpolation)\n        inner_curve = (curve1, 1, inner_radius, width, \"cartesian\")\n        outer_curve = (curve2, 1, outer_radius",
    "], -old_y_bounds[0])\n        transform = transform.scale((new_x_bounds[1]-new_x_bounds[0])/(old_x_bounds[1]-old_x_bounds[0]),\n                                    (new_y_bounds[1]-new_",
    "urves)):\n                transformed_curves.append(affine.transform(curves[i]))\n            return transformed_curves\n\n    def apply_affine_single(curves: List[np.ndarray], affine: Affine2D, inplace=True) -> List[np.ndarray]:\n       ",
    " rotation_offset)\n            transforms.append(trans_data)\n        return transforms\n\n    def rotate_image(self, image: np.ndarray, transforms: List[Affine2D]):\n        transforms = self.rotate_transforms(transforms)\n        return self.apply_transforms(image, transforms)\n\n   ",
    "ts, min_context_lines, max_context_lines)\n            if result:\n                examples.append(result)\n        return examples\n\n    def extract_code_segments(block: str, max_characters: int = 100, min_context_lines: int = 1,",
    "))\n        rho = rho*np.cos(theta)\n        rho = rho*np.sin(theta)\n        return rho\n\n    def sine_wave_circular_arc_2d(n=100, radius=0.5, theta1=0.0, theta2=",
    "o),\n        'color_histogram': merge_histograms(region1_info['color_histogram'],\n                                            region1_info['size'],\n                                            region2_info['color_histogram'],\n                                            region2_info['size']),\n       'size': region1_info['size'] + region2",
    "rations2)",
    "gap1, gap2))\n        gap1 = np.vstack((gap1, np.zeros(10))).T\n        gap2 = np.vstack((gap2, np.zeros(10))).T\n        arc = CurveGenerator.circular_arc(n, width/2,",
    "_text, suffix))\n        return examples\n\n\nclass TextUtils:\n    \"\"\"Utility class to generate examples from text.\"\"\"\n\n    @staticmethod\n    def split_indentation(text: str) -> List[str]:\n        \"\"\"Split text into individual lines and return them as a list of strings.\"\"\"\n        lines = text",
    " 0, 0), radius, height, sample_rotation, left_edge, right_edge, leaf_type)\n        image_sample = ImageSample(image_sliced, extent, path, outline_curves)\n        ImageSampleTransformer.rotational_repeat_additive(image_",
    "curves)\n            Transformer.rotate_curves(new_curves, i*angle)\n            Transformer.scale_curves(new_curves, scales[i])\n            curves.extend(new_curves)\n        return curves\n\n    def rotate_curves(self, curves: \"",
    "elf.get_source_segment(code, node.test)), (end_line, end_col)))\n        elif isinstance(node, ast.Assign):\n            target = ast.get_source_segment(code, node.target)\n            value = ast.get_source_segment(code",
    "radius, repetitions, leaf_width, leaf_height, leaf_rotation)\n        (image_sliced, extent, path, outline_curves) = ImageSlicer.leaf(image, dpu, leaf_width, leaf_height, False)\n        image_sample = ImageSample(",
    "rves)):\n            curves[i][0, :] = curves[i][0, :] + curves[i][1, :]\n            curves[i][1, :] = curves[i][1, :] - curves[i][0, :]\n\n    def flip_horizontal(curves):",
    "0], pivot[1])\n        curve = curve.rotate(angle).translate(pivot[0], pivot[1])\n        return CurveTransforms.apply_affine_single(curve, transform, inplace)\n\n    def rotate_multiple(curve: np.ndarray, angle=0.0, pivot=(",
    "size[1]",
    "s)\n        bezier_curve = Curve(nodes.T, degree=nodes.shape[0] - 1)\n        return bezier_curve.evaluate_multi(values).T\n\n\nclass CurveTransforms:\n    def __init__(self, degree=1):\n        self.degree =",
    "sertion.Constant):\n            targets = [node.value]\n            value = node.value\n        else:\n            return\n        start_line = node.lineno\n        end_line = node.end_lineno\n        end_col = node.end_col_offset\n        start_col = value.col",
    "_nodes, width, height))))\n        return curve\n\n    def fit_c2c(curve, x_values, y_values):\n        curve = np.array(curve)\n        curve = curve.reshape(curve.shape[0], curve.shape[1], 2)\n        curve =",
    "es)\n        curves = []\n        for i in range(repetitions):\n            curves.append(curves[i] + np.random.normal(scale[i], scale[i+1]))\n        return curves\n\n    def scale_curves(curves: \"list\", scale:",
    "tesian[:, 0]), np.max(curve_cartesian[:, 0]))\n        y_bounds = (np.min(curve_cartesian[:, 1]), np.max(curve_cartesian[:, 1]))\n        return CurveTransforms.square_map_cartesian_to_",
    "mon_paths",
    "olors)",
    "_c2c(curve, width/2, height/2, half=True))))\n        return curve\n\n    def curve_to_curve_transform(self, curve):\n        curve = np.array(curve)\n        curve = np.flip(curve)\n        curve = np.array([curve",
    " outline_curves, path, leaf_rotation, leaf_width, leaf_height, leaf_rotation, repetitions, radius, leaf_width, leaf_height, leaf_rotation, repetitions, radius, leaf_width, leaf_height, leaf_rotation, repetitions, radius,",
    " theta2, n_periods)\n        curve = CurveTransforms.polar_to_cartesian(np.vstack((radius, theta)).T)\n        CurveTransforms.translate_single(curve, offset[0], offset[1], inplace=True)\n        return curve\n\n    def sine_wave",
    "tesian[:, 1]))\n        rho_bounds = (np.min(curve_cartesian[:, 2]), np.max(curve_cartesian[:, 2]))\n        theta_bounds = (np.min(curve_cartesian[:, 3]), np.max(curve_cartesian",
    "PersistentTransforms)):\n            im = ax.imshow(self.PersistentTransforms[i], extent=self.Extent, origin=\"upper\", cmap=\"gray\", clip_on=True, interpolation=\"bicubic\",\n                           zorder=z_order, transform=self.PersistentTransforms[i] + transform +",
    ")):\n            new_persistent_transforms.append(image_sample.PersistentTransforms[i] + transform)\n            new_persistent_paths.append(image_sample.PersistentClipPaths[i])\n        image_sample.PersistentClipPaths.extend(new_persistent_paths)\n        image_sample",
    " generated, expected)\n        results['bleu'] = self.bleu_score(generated, expected)\n        results['rouge'] = self.rouge_score(generated, expected)\n        results['meteor'] = self.meteor_score(generated, expected)\n        results['bert'] = self.",
    "cartesian[:, 1]), np.max(curve_cartesian[:, 1]))\n        return CurveTransforms.square_map_cartesian_to_polar(curve_cartesian, x_bounds, y_bounds, rho_bounds, theta_bounds)\n\n    def tight_map_polar",
    "angle).scale(1, 1)\n        image_sample.PersistentClipPaths.extend(transform.apply(image_sample.PersistentClipPaths))\n        image_sample.PersistentTransforms.extend(transform.apply(image_sample.PersistentTransforms))\n        image_sample.PersistentClipPaths.",
    " ",
    "_code)\n    visitor = FunctionCallVisitor(tree)\n    visitor.visit(tree)\n    return visitor.function_calls\n\n\ndef find_function_calls_with_kwargs(source_code):\n    tree = ast.parse(source_code)\n    visitor = FunctionCallVisitor(tree",
    "missions1)])\n        (curve2, periods2, radius2, width2, coordinate_type2) = outer_curve\n        if coordinate_type2 == \"polar\":\n            curve2 = CurveTransforms.tight_remap_polar_to_polar(curve2, (radius2 - width2",
    "nction, ast.Name):\n            func_name = node.func.id\n        elif isinstance(node.func, ast.Attribute):\n            parts = []\n            current = node.func\n            while isinstance(current, ast.Attribute):\n                parts.insert(0, current.attr)\n                current",
    "height, width, 100), half=half)\n        return CurveTransforms.merge_curves([triangle1, curve])\n\n    def edge_type2(width=1.0, height=0.2, flip=False, half=False):\n        if flip:\n            height =",
    "rotation).translate(radius, 0).rotate(i * angle + global_rotation_offset)\n            transforms.append(trans_data)\n        return transforms\n\n    def rotate_transforms(self, transforms: List[Affine2D]):\n        transforms = np.array(transforms)\n        transforms = transforms",
    " generated",
    "rves)):\n            curves[i][0, :] = curves[i][0, :] + curves[i][1, :]\n            curves[i][1, :] = curves[i][1, :] + curves[i][2, :]\n            curves[i][2, :] ="
]