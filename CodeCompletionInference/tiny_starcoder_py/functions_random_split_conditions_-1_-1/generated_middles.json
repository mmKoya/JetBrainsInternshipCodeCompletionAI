[
    "e'] > min_context_lines",
    " == y_bounds[0] and x_bounds[1] == x_bounds[0]:\n            rho = np.ones(curve_cartesian[:, 0].shape) * rho_bounds[0]\n        else:\n            rho = (curve_cartesian[:, ",
    " subdivisions[0] > 0:\n            for curve in diamonds:\n                figure.add_curve(curve, 0)\n        if fill",
    "lotType[i] == \"line\":\n                ax.plot(self.Curves[i][:, 0], self.Curves[i][:, 1], color=\"k\", solid_capstyle='round',\n                         linewidth=self.PlotType[i], z",
    "= 0:\n                local_rotation_offset = np.random.uniform(-np.pi, np.pi)\n                global_rotation_offset = np.random.uniform(-np.pi, np.pi)\n            else:\n                local_rotation_offset = np.",
    "tance(node.func, ast.Attribute)",
    "e_rotation:\n            angle = np.pi/repetitions\n        curves = copy.deepcopy(curves)\n        for i in range(repetitions):\n            new_curves = copy.deepcopy(curves)\n            Transformer.rotate_curves(new_cur",
    " ast.AnnAssign):\n            targets = [node.target]\n            value = node.value\n        else:\n            return\n        start_line = node.lineno\n        end_line = node.end_lineno\n        end_col = node.end_col_offset\n        start_col",
    "urrent, ast.Name)",
    "context']) > max_arguments:\n                continue\n            if len(call['arguments']) > max_arguments:\n                continue\n            if len(call['arguments']) == 0:\n                continue\n            if call['context'] == 'function':\n                examples.append((call['name'], call",
    "angle is None:\n            delta_angle = 2 * np.pi / repetitions\n        elif delta_angle is not None:\n            delta_angle = np.maximum(1, delta_angle)\n            angle = None\n        else:\n            delta_angle = np.maximum(",
    "balance == 0:\n                current_line += 1\n                start_idx = len(lines[current_line]) - 1\n        prefix = '\\n'.join(lines[function_call['start_line'] - 1:current_line] + [lines[",
    "de, ast.Name):\n            targets = [node.id]\n            value = node.id\n        elif isinstance(node, ast.Str):\n            targets = [node.s]\n            value = node.s\n        elif isinstance(node, ast.Num):\n            targets = [",
    "_angle is None:\n            delta_angle = 2 * np.pi / repetitions\n        elif delta_angle is not None:\n            delta_angle = np.maximum(1, delta_angle)\n            angle = None\n        else:\n            delta_angle = np.maximum",
    "_list\n\n    def sample_from_curve(self, image: np.ndarray, curve: np.ndarray, dpu: float) -> (np.ndarray, (float, float, float, float), Path, List[np.ndarray]):\n        image = np.flip",
    "everse_rotation:\n            rotation_offset = -rotation_offset\n        else:\n            rotation_offset = rotation_offset\n        transforms = []\n        for i in range(repetitions):\n            if i % 2 == 0 or not use_flip:\n                trans_data",
    "le, Figure):\n            self.append_figure(figure)\n        else:\n            raise TypeError(\"Operator += can only be used with instance of class Figure\")\n\n    def __isub__(self, figure: \"Figure\"):\n        if isinstance(figure, Figure):\n            self.remove_",
    "size == 1:\n            scales = scale\n        elif scale.size == 2:\n            scales = np.linspace(scale[0], scale[1], repetitions)\n        elif scale.size == repetitions:\n            scales = scale\n        else:\n            scales = np.ones",
    "is None:\n            angle = 2*np.pi/repetitions\n        if scale is None:\n            scale = np.array([1.0, 1.0])\n        elif scale.size == 1:\n            scale = np.linspace(scale[0],",
    "of_segments is None:\n            number_of_segments = np.trunc(2*np.pi/delta_angle)\n            delta_angle = None\n        elif delta_angle is None:\n            number_of_segments = np.maximum(1, number_of_",
    "l_balance > 0:\n            current_line += 1\n            start_idx = len(lines[current_line]) - 1\n            if start_idx < 0:\n                current_line -= 1\n                start_idx = len(lines[current_line",
    "ype == \"bezier\":\n            curve = control_nodes\n        elif interpolation_type == \"linear\":\n            curve = control_nodes\n        else:\n            curve = CurveTransforms.interpolate(control_nodes, 100, \"cubic\", False)\n        return curve\n\n    def random_",
    "< region2_id:\n            del similarities[(neighbour, region2_id)]\n        else:\n            del similarities[(region2_id, neighbour)]\n    new_mask = np.logical_or(region1_info['mask'], region2_info['mask",
    "ited[j] and swaps < cycle_length:\n            visited[j] = True\n            j = perm1_mapped[j]\n            cycle_length += 1\n        if visited[j]",
    "ppliedTransforms) > 0:\n            for transform in self.AdditiveTransforms:\n                self.plot_persistent(ax, transform, z_order, outline_thickness, debug_colors)\n                z_order += 0.001\n        if len(self.",
    "segments is None and delta_angle is not None:\n            repetitions = number_of_segments\n            angle = delta_angle\n        elif delta_angle is not None:\n            repetitions = np.maximum(1, number_of_segments)\n            angle = delta_angle\n       ",
    "s is None and delta_angle is not None:\n            repetitions = int(np.trunc(2 * np.pi / delta_angle))\n            angle = None\n        elif repetitions is not None and delta_angle is not None:\n            repetitions = int(np.",
    "olors:\n            ax.imshow(self.PersistentClipPaths, extent=self.Extent, origin=\"upper\", cmap=\"gray\", clip_on=True, interpolation=\"bicubic\",\n                       zorder=z_order, transform=transform + ax.transData)\n        else",
    "_side:\n            outline_curves = [np.vstack((curve2, curve1))]\n        elif left_side:\n            outline_curves = [np.vstack((curve1, curve2))]\n        else:\n            outline_curves = [curve2,",
    "type2 == \"polar\":\n            curve2 = CurveTransforms.tight_remap_polar_to_polar(curve2, (radius2, radius2+width2), (theta1, theta1 + (theta2-theta1)/periods2))\n            curve2 = Curve",
    "== x_bounds[1]",
    "ion == \"x_input\"",
    "e < new_id:\n            similarities[(neighbour, new_id)] = similarity\n        else:\n            similarities[(new_id, neighbour)] = similarity\n    del regions[region1_id]\n    del regions[region2_id]\n    regions[new_id",
    "_bounds is None",
    "e, ast.Assign):\n            targets = [node.target]\n            value = node.value\n        elif isinstance(node, ast.AnnAssign):\n            targets = [node.target]\n            value = node.value\n        else:\n            return\n        start_line = node.lineno",
    "ion == \"z_input\":\n            z_values = values\n            x_values = np.array([function(z) for z in z_values])\n            curve = np.vstack((x_values, y_values)).T\n        else:\n            print(\"Invalid input",
    "= \"sharp\":\n            leaf = CurveGenerator.bezier(np.array([[-1, 0], [-1, 1], [0, 1], [0, 2]]))\n        elif leaf_type ==\"cartesian\":\n            leaf = CurveGenerator.bezier(",
    "<= 0",
    "s_split:\n                        datasets.append((random_split_name, examples_split))\n                else",
    "ength > 0",
    "_rotation:\n            angle = -angle\n        transforms = []\n        for i in range(repetitions):\n            if i % 2 == 0 or not use_flip:\n                trans_data = Affine2D().rotate(local_rotation_offset).translate(radius",
    "_bounds:\n            self.update_curve_bounds(self.evaluate_curve_bounds(curve))\n\n    def update_curve_bounds(self, bounds):\n        for curve in self.Curves:\n            curve.update_bounds(bounds)\n\n    def evaluate_curve_",
    "ns is None and delta_angle is not None:\n            repetitions = 1\n            angle = delta_angle\n        elif repetitions is not None and delta_angle is not None:\n            repetitions = 1\n            angle = delta_angle\n        elif repetitions is not None and",
    "angle is None:\n            repetitions = np.trunc(2*np.pi/delta_angle)\n            angle = None\n        else:\n            repetitions = np.trunc(2*np.pi/delta_angle)\n            angle = delta_angle\n        if angle is None",
    "node.func, ast.Name):\n            func_name = node.func.id\n        elif isinstance(node.func, ast.Attribute):\n            parts = []\n            current = node.func\n            while isinstance(current, ast.Attribute):\n                parts.insert(0, current",
    "n(expected)",
    "ation_type == \"cubic\"",
    "pe[i] < 0:\n                ax.plot(self.Curves[i][:, 0], self.Curves[i][:, 1], color=\"w\", zorder=self.z_order)\n                ax.plot(self.Curves[",
    "put_curves is not None:\n            self.LocalOutlineCurves = local_output_curves\n        else",
    "1.0:\n            clip_ar = 1.0\n        if clip_ar > 1.0:\n            clip_ar = 1.0\n        if clip_ar < 0.0:\n            clip_ar = 0.0\n        if clip_ar"
]