[
    "return\n        if delta_angle is None:\n            repetitions = np.maximum(1, number_of_segments)\n            angle = None\n        else:\n            repetitions = np.maximum(1, number_of_segments)\n            angle = delta_angle\n        if angle is None:\n            angle = 2*np.pi/repetitions\n        if reverse_rotation:\n            angle = -angle\n        scale = np.array(scale)\n        if scale.size == 1:\n            scales = scale*np.ones(repetitions)\n        elif scale.size == 2:\n            scales = np.linspace(scale[0], scale[1], repetitions)\n        elif scale.size == repetitions:\n            scales = scale\n        else:\n            scales = np.ones(repetitions)\n        base_curves = copy.deepcopy(curves)\n        Transformer.scale_curves(curves, scales[0])",
    "curve = np.array(function(values))\n        elif input_coordinate == \"z_input\":\n            curve = np.array(function(values))\n        else:\n            print(\"Invalid input_coordinate, curve will default to 0,0\")\n            curve = np.array([[0.0, 0.0]])\n        if polar:\n            curve = CurveTransforms.polar_to_cartesian(curve)\n        return curve\n    @staticmethod\n    def linear_curve(n, width=0.1, height=0.2, half=False):\n        curve = CurveTransforms.linear_curve(n, width, height, half)\n        CurveTransforms.translate_single(curve, 0, 0, inplace=True)\n        return curve\n    @staticmethod\n    def cubic_curve(n, width=0.1, height=0.2, half=False):\n        curve = CurveTransforms.cubic_curve(n,",
    "return CurveTransforms.apply_affine_multi(curves, transform, inplace)\n    @staticmethod\n    def translate_single(curve: np.ndarray, x=0.0, y=0.0, inplace=True) -> np.ndarray:\n        transform = Affine2D().translate(x, y)\n        return CurveTransforms.apply_affine_single(curve, transform, inplace)\n    @staticmethod\n    def translate_multi(curves: List[np.ndarray], x=0.0, y=0.0, inplace=True) -> List[np.ndarray]:\n        transform = Affine2D().translate(x, y)\n        return CurveTransforms.apply_affine_multi(curves, transform, inplace)\n    @staticmethod\n    def scale_single(curve: np.ndarray, scale=(1.0, 1.0), pivot=(0.0, 0.0), inplace=True",
    "\"name\": func_name,\n                \"args\": args,\n                \"end_col_offset\": node.end_col_offset\n            })\n        self.generic_visit(node)\n    def visit_Name(self, node):\n        self.generic_visit(node)\n    def visit_Attribute(self, node):\n        self.generic_visit(node)\n    def visit_List(self, node):\n        self.generic_visit(node)\n    def visit_Tuple(self, node):\n        self.generic_visit(node)\n    def visit_Dict(self, node):\n        self.generic_visit(node)\n    def visit_Set(self, node):\n        self.generic_visit(node)\n    def visit_DictComp(self, node):\n        self.generic_visit(node)\n    def visit_GeneratorExp(self, node):\n        self.generic_visit(node)\n    def visit_",
    "_arc(image, dpu=10.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.",
    "curve = np.vstack((inner_curve, outer_curve)).T\n        outline_curves = [curve]\n        (image, extent, path) = ImageSlicer.sample_from_curve(image, curve, dpu)\n        return image, extent, path, outline_curves\n    @staticmethod\n    def sine_wave_circular_arc(image, dpu=1000.0, n_periods=2, period_offset=0.25, inner_radius=0.5, outer_radius=0.8,\n                               amplitude=0.1, theta1=0.0, theta2=np.pi/2):\n        inner_curve = CurveGenerator.sine_wave_circular_arc(100, inner_radius+amplitude, theta1, theta2, amplitude, n_periods, period_offset)\n        outer_curve = np.flip(CurveGenerator",
    "_arc(image, dpu=10.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.",
    "curve = CurveGenerator.bezier(curve_nodes, np.linspace(0, 1 - 0.5 * half, 100))\n        else:\n            curve = CurveGenerator.bezier(curve_nodes, np.linspace(0, 1 - 0.5 * half, 100))\n        if half:\n            curve = np.vstack((curve, np.flip(CurveTransforms.scale_single(curve, (-1, 1), inplace=False), 0)))\n        else:\n            curve = CurveTransforms.interpolate(curve_nodes, 100, \"cubic\", False)\n        return curve\n    @staticmethod\n    def edge_type2(width=1.0, height=0.2, flip=False, half=False):\n        if flip:\n            height = -height\n        triangle1 = np.array([[0, 0], [0.1*width, height],",
    "func_name = current.id\n            else:\n                func_name = current.id + '.' + node.func.attr.id\n        elif isinstance(node.func, ast.Attribute):\n            parts = []\n            current = node.func\n            while isinstance(current, ast.Attribute):\n                parts.insert(0, current.attr)\n                current = current.value\n            if isinstance(current, ast.Name):\n                func_name = current.id\n            else:\n                func_name = current.id + '.' + node.func.attr.id\n        elif isinstance(node.func, ast.Name):\n            func_name = node.func.id\n        else:\n            raise Exception(\"Unknown function type: \" + str(node.func))\n        self.function_calls.append({\n            \"name\": func_name,\n            \"args\": parts,\n            \"start_line\": node.lineno,\n            \"end_line\": node",
    "return CurveTransforms.merge_curves([nodes, values])\n    @staticmethod\n    def fit_c2c(curve, x_values, y_values):\n        result = curve.T\n        curve = CurveTransforms.interpolate(curve, 100, \"cubic\", False)\n        curve = CurveTransforms.merge_curves([curve, result])\n        curve = CurveTransforms.interpolate(curve, 100, \"cubic\", False)\n        curve = CurveTransforms.merge_curves([curve, curve])\n        curve = CurveTransforms.interpolate(curve, 100, \"cubic\", False)\n        curve = CurveTransforms.merge_curves([curve, curve])\n        curve = CurveTransforms.interpolate(curve, 100, \"cubic\", False)\n        curve = CurveTransforms.merge_curves([curve, curve])\n        curve = CurveTransforms.interpolate(curve, 100, \"cubic",
    "curve[i][0, :] = curve[i][0, :] + 1\n            curve[i][1, :] = curve[i][1, :] + 1\n    @staticmethod\n    def flip_vertical(curves):\n        for i in range(len(curves)):\n            curve[i][0, :] = curve[i][0, :] - 1\n            curve[i][1, :] = curve[i][1, :] - 1\n    @staticmethod\n    def flip_diagonal(curves):\n        for i in range(len(curves)):\n            curve[i][0, :] = curve[i][0, :] * 0\n            curve[i][1, :] = curve[i][1, :] * 0\n    @staticmethod\n    def flip_diagonal_figure(figure: \"Figure\", diagonal=True):\n        Transformer.flip_diagonal(figure.Curves)\n        figure.evaluate_bounds",
    "self.function_calls.append({\n                \"name\": func_name,\n                \"args\": args,\n                \"col_offset\": node.col_offset,\n                \"end_col_offset\": node.end_col_offset\n            })\n        self.generic_visit(node)\n    def visit_Attribute(self, node):\n        func_name = None\n        if isinstance(node.value, ast.Name):\n            func_name = node.value.id\n        elif isinstance(node.value, ast.Attribute):\n            parts = []\n            current = node.value\n            while isinstance(current, ast.Attribute):\n                parts.insert(0, current.attr)\n                current = current.value\n            if isinstance(current, ast.Name):\n                parts.insert(0, current.id)\n            func_name = \".\".join(parts)\n        args = [ast.get_source_segment(self.source_code,",
    "for dataset_name, examples in DatasetBuilder.extract_datasets_with_max_context(code_blocks, max_value, max_context):",
    "    self.z_order = 0\n    def __iadd__(self, figure: \"Figure\"):\n        if isinstance(figure, Figure):\n            self.append_figure(figure)\n        else:\n            raise TypeError(\"Operator += can only be used with instance of class Figure\")\n    def __add__(self, figure: \"Figure\"):\n        if isinstance(figure, Figure):\n            new_figure = Figure()\n            new_figure += self\n            new_figure += figure\n        else:\n            raise TypeError(\"Operator + can only be used with instance of class Figure\")\n        return new_figure\n    def plot(self, ax, image_outline_width=1.0):\n        for image in self.Images:\n            image.plot(ax, self.z_order, image_outline_width)\n            Figure.z_order += 1\n        for i in range(len(self.Curves)):\n            if self.PlotType[i]",
    "def fit_c2c_multi(curves, extent):\n        x_bounds = (np.min(curves[:, 0]), np.max(curves[:, 0]))\n        y_bounds = (np.min(curves[:, 1]), np.max(curves[:, 1]))\n        return CurveTransforms.remap_c2c(curves, x_bounds, y_bounds, extent[0:2], extent[2:4])\n    @staticmethod\n    def fit_c2c_multi_multi(curves, extent):\n        x_bounds = (np.min(curves[:, 0]), np.max(curves[:, 0]))\n        y_bounds = (np.min(curves[:, 1]), np.max(curves[:, 1]))\n        return CurveTransforms.remap_c2c(curves, x_bounds, y_bounds, extent[0",
    "if isinstance(figure, Figure):\n            self.add_figure(figure)\n        else:\n            raise TypeError(\"Operator += can only be used with instance of class Figure\")\n    def __sub__(self, figure: \"Figure\"):\n        if isinstance(figure, Figure):\n            self.append_figure(figure)\n        else:\n            raise TypeError(\"Operator -= can only be used with instance of class Figure\")\n    def __rsub__(self, figure: \"Figure\"):\n        if isinstance(figure, Figure):\n            self.sub_figure(figure)\n        else:\n            raise TypeError(\"Operator -= can only be used with instance of class Figure\")\n    def __mul__(self, figure: \"Figure\"):\n        if isinstance(figure, Figure):\n            self.append_figure(figure)\n        else:\n            raise TypeError(\"Operator *= can only be used with instance of class Figure\")\n    def __rmul__(self, figure: \"Figure\"):\n        if isinstance(",
    "     local_rotation_offset=0.0, global_rotation_offset=0.0, use_flip=False, flip_angle=0.0, reverse_rotation=False, calculate_overlap=False):\n        additive_transforms = TransformsGenerator.circular_placement(radius, repetitions, delta_angle, local_rotation_offset,\n                                                                     global_rotation_offset, use_flip, flip_angle, reverse_rotation)\n        image_sample.AdditiveTransforms = additive_transforms\n        if calculate_overlap:\n            (new_persistent_paths, new_persistent_transforms, outline_curves) = paths_self_overlap(image_sample.PersistentClipPaths, image_sample.PersistentTransforms,\n                                                                                                   additive_transforms[0], additive_transforms[1])\n            image_sample.PersistentTransforms = new_persistent_transforms\n            image_sample.PersistentClipPaths = new_",
    "transform = Affine2D().translate(x, y)\n        return CurveTransforms.apply_affine_multi(curves, transform, inplace)\n    @staticmethod\n    def translate_multi(curves: List[np.ndarray], x=0.0, y=0.0, inplace=True) -> List[np.ndarray]:\n        transform = Affine2D().translate(x, y)\n        return CurveTransforms.apply_affine_multi(curves, transform, inplace)\n    @staticmethod\n    def scale_single(curve: np.ndarray, scale=(1.0, 1.0), pivot=(0.0, 0.0), inplace=True) -> np.ndarray:\n        transform = Affine2D().scale(scale[0], scale[1]).translate(pivot[0], pivot[1])\n        return CurveTransforms.apply_affine_single(curve, transform, inplace)\n    @",
    "@staticmethod\n    def translate_multi(curves: List[np.ndarray], x=0.0, y=0.0, inplace=True) -> List[np.ndarray]:\n        transform = Affine2D().translate(x, y)\n        return CurveTransforms.apply_affine_multi(curves, transform, inplace)\n    @staticmethod\n    def scale_single(curve: np.ndarray, scale=(1.0, 1.0), pivot=(0.0, 0.0), inplace=True) -> np.ndarray:\n        transform = Affine2D().translate(-pivot[0], -pivot[1]).scale(scale[0], scale[1]).translate(pivot[0], pivot[1])\n        return CurveTransforms.apply_affine_single(curve, transform, inplace)\n    @staticmethod\n    def scale_multi(curves: List[np.ndarray], scale=(1.0",
    "if inplace:\n            curve[:] = curve.copy()\n            return curve\n        else:\n            return CurveTransforms.fit_c2c(curve, samples)\n    @staticmethod\n    def interpolate_multi(curves: List[np.ndarray]):\n        interpolated_curves = []\n        for i in range(len(curves)):\n            interpolated_curves.append(CurveTransforms.interpolate(curves[i], samples=100, kind=kind))\n        return interpolated_curves\n    @staticmethod\n    def interpolate_single(curve: np.ndarray, samples=100, kind=\"cubic\", inplace=True) -> np.ndarray:\n        if inplace:\n            curve[:] = curve.copy()\n            return curve\n        else:\n            return CurveTransforms.fit_c2c(curve, samples)\n    @staticmethod\n    def interpolate_multi_single(curves: List[np.ndarray]):\n        interpolated_curves = []\n       ",
    "def sine_wave_circular_arc(image, dpu=1000.0, n_periods=2, period_offset=0.25, inner_radius=0.5, outer_radius=0.8, amplitude=0.1, theta1=0.0, theta2=np.pi/6,\n                            left_side=False, right_side=False) -> (np.ndarray, (float, float, float, float), Path, List[np.ndarray]):\n        curve = np.array((np.linspace(0, 1, n_periods+1), np.zeros(n_periods+1))).T\n        inner_curve = (curve, 1, inner_radius, 0, \"cartesian\")\n        outer_curve = (curve, 1, outer_radius, 0, \"cartesian\")\n        (image, extent, path, outline",
    "curve2 = np.vstack((outer_rho, theta)).T\n        outline_curves = [curve1, curve2]\n        curve = np.vstack((inner_curve, outer_curve)).T\n        (image, extent, path) = ImageSlicer.sample_from_curve(image, curve, dpu)\n        return image, extent, path, outline_curves\n    @staticmethod\n    def serrated_sine_wave_arc(image, dpu=1000.0, n_periods=2, period_offset=0.25, inner_radius=0.5, outer_radius=0.8,\n                           amplitude=0.1, theta1=0.0, theta2=np.pi/2):\n        inner_curve = CurveGenerator.sine_wave_circular_arc(100, inner_radius+amplitude, theta1, theta2",
    "image_sample = ImageSample(image_sliced, extent, path, outline_curves)\n        ImageSampleTransformer.rotational_repeat_additive(image_sample, 2 * segments, None,\n                                                          rotation_offset=-sample_rotation+global_rotation, use_flip=True,\n                                                          flip_angle=(2 * sample_rotation + np.pi / segments) / 2)\n        return image_sample\n    @staticmethod\n    def leaf_circle_type1(image, dpu=1000.0, repetitions=50, radius=0.7, leaf_width=0.1, leaf_height=0.2, leaf_rotation=np.pi/6):\n        circle = CurveGenerator.regular_polygon(1000, radius)\n        (image_sliced, extent, path, outline_curves) = ImageSlicer.leaf(image, dpu, leaf_",
    "ax.plot(self.Curves[i][:, 0], self.Curves[i][:, 1], color=\"k\", solid_capstyle='round',\n                         linewidth=self.PlotType[i], zorder=self.z_order)\n        Figure.z_order += 1\n        for i in range(len(self.Images)):\n            ax.plot(self.Images[i], self.Images[i], color=\"k\", solid_capstyle='round', linewidth=self.PlotType[i], zorder=self.z_order)\n        Figure.z_order += 1\n        for i in range(len(self.Curves)):\n            ax.plot(self.Curves[i][:, 0], self.Curves[i][:, 1], color=\"k\", solid_capstyle='round', linewidth=self.PlotType[i], zorder=self.",
    "def translate_single(curve: np.ndarray, x: float, y: float, inplace=True) -> np.ndarray:\n        transform = Affine2D().translate(x, y)\n        return CurveTransforms.apply_affine_single(curve, transform, inplace)\n    @staticmethod\n    def translate_multi(curves: List[np.ndarray], x: float, y: float, inplace=True) -> List[np.ndarray]:\n        transform = Affine2D().translate(x, y)\n        return CurveTransforms.apply_affine_multi(curves, transform, inplace)\n    @staticmethod\n    def scale_single(curve: np.ndarray, scale=(1.0, 1.0), pivot=(0.0, 0.0), inplace=True) -> np.ndarray:\n        transform = Affine2D().translate(x, y)\n        return CurveTransforms.apply_affine_",
    "   np.maximum(self.X_bounds[1], bounds[1][0]))\n            self.Rho_bounds = (np.minimum(self.Rho_bounds[0], bounds[2][0]),\n                                 np.maximum(self.Rho_bounds[1], bounds[2][1]))\n            self.Theta_bounds = (np.minimum(self.Theta_bounds[0], bounds[3][0]),\n                                 np.maximum(self.Theta_bounds[1], bounds[3][1]))\n    def update_curve_bounds(self, bounds):\n        if self.X_bounds is None:\n            self.X_bounds = bounds[0]\n            self.Y_bounds = bounds[1]\n            self.Rho_bounds = bounds[2]\n            self.Theta_bounds = bounds[3]\n        else:\n            self.X_bounds = (np.minimum(self.X",
    "image_ar = image.shape[0]\n        x1 = int(np.random.randint(0, image_ar - dpu))\n        y1 = int(np.random.randint(0, image_ar - dpu))\n        x2 = int(np.random.randint(0, image_ar - dpu))\n        y2 = int(np.random.randint(0, image_ar - dpu))\n        image_ar = image.shape[0]\n        x1 = int(np.random.randint(0, image_ar - dpu))\n        y1 = int(np.random.randint(0, image_ar - dpu))\n        x2 = int(np.random.randint(0, image_ar - dpu))\n        y2 = int(np.random.randint(0, image_ar - dpu))\n        image_ar = image.shape",
    "self.classes = []\n        self.generic_visit = self.visit\n\n    def visit_FunctionDef(self, node):\n        function_source = ast.get_source_segment(self.code, node)\n        self.functions.append(function_source)\n        self.generic_visit(node)\n    def extract_from_code(self, code):\n        self.code = code\n        tree = ast.parse(self.code)\n        self.visit(tree)\n    def visit_FunctionDef(self, node):\n        function_source = ast.get_source_segment(self.code, node)\n        self.functions.append(function_source)\n        self.generic_visit(node)\n    def extract_from_code(self, code):\n        self.code = code\n        tree = ast.parse(self.code)\n        self.visit(tree)\n    def visit_ClassDef(self, node",
    "if reverse_rotation:\n            angle = -angle\n        for i in range(len(curves)):\n            curves[i] = curves[i].transpose()\n            curves[i] = curves[i].reshape(1, -1)\n    @staticmethod\n    def rotate_figure_with_rotation(figure: \"Figure\", angle=0):\n        Transformer.rotate_curves(figure.Curves, angle)\n        figure.evaluate_bounds()\n        return figure\n    @staticmethod\n    def rotate_figure_with_scale(figure: \"Figure\", scale=1.0):\n        Transformer.scale_curves(figure.Curves, scale)\n        figure.evaluate_bounds()\n    @staticmethod\n    def rotate_figure_with_rotation_with_scale(figure: \"Figure\", angle=0):\n        Transformer.rotate_curves(figure.Curves, angle)\n        figure.evaluate_bounds()\n        return figure\n    @staticmethod",
    "for i in range(len(curves)):\n            curves[i] = np.concatenate((curves[i], curves[i+1]))\n    @staticmethod\n    def merge_figure(figure: \"Figure\"):\n        for i in range(len(figure.Curves)):\n            figure.Curves[i] = np.concatenate((figure.Curves[i], figure.Curves[i+1]))\n    @staticmethod\n    def merge_curves_with_figure(curves: \"list\", figure: \"Figure\"):\n        for i in range(len(curves)):\n            curves[i] = np.concatenate((curves[i], curves[i+1]))\n    @staticmethod\n    def merge_figure_with_curves(curves: \"list\", figure: \"Figure\"):\n        for i in range(len(figure.Curves)):\n            figure.Curves[i] = np.concatenate((figure.",
    "image_sample.PersistentTransforms = new_persistent_transforms\n        image_sample.set_custom_outline_curves(outline_curves)\n    @staticmethod\n    def mirror_persistent_with_offset(image_sample: ImageSample, mirror_angle=0.0):\n        transform = Affine2D().rotate(-mirror_angle).scale(1, -1).rotate(mirror_angle)\n        new_persistent_transforms = []\n        new_persistent_paths = []\n        for i in range(len(image_sample.PersistentTransforms)):\n            new_persistent_transforms.append(image_sample.PersistentTransforms[i] + transform)\n            new_persistent_paths.append(image_sample.PersistentClipPaths[i])\n        image_sample.PersistentClipPaths.extend(new_persistent_paths)\n        image_sample.PersistentTransforms = new_persistent_transforms\n        image_sample.set_custom_outline",
    "curve2 = CurveGenerator.circular_arc(100, outer_radius, theta1, theta2)\n        curve = np.vstack((curve1, curve2))\n        (image, extent, path) = ImageSlicer.sample_from_curve(image, curve, dpu)\n        return image, extent, path, outline_curves\n    @staticmethod\n    def circular_arc(x1, x2, theta1, theta2, amplitude, n_periods, period_offset):\n        x_abs = x2 - x1\n        y_abs = amplitude * np.sin(theta1) * np.cos(theta2)\n        x_rel = x_abs / y_abs\n        y_rel = y_abs / x_abs\n        x_rel = x_rel * period_offset\n        y_rel = y_rel * period_offset\n        x_rel = x_rel + x",
    "def custom_ring_arc(image, dpu=1000.0, segments=8, inner_radius=0.5, outer_radius=0.8, sample_rotation=0.0, sample_rotation+np.pi/segments, left_edge=False, right_edge=False) -> (ImageSample, ImageSample):\n        (image_sliced, extent, path, outline_curves) = ImageSlicer.custom_ring_arc_arc(image, dpu, inner_radius, outer_radius, sample_rotation, sample_rotation+np.pi/segments, left_edge, right_edge)\n        image_sample = ImageSample(image_sliced, extent, path, outline_curves)\n        ImageSampleTransformer.rotational_repeat_additive(image_sample, 2 * segments, None,\n                                                          rotation_offset=-sample_rotation+global_rotation",
    "def __isub__(self, figure: \"Figure\"):\n        if isinstance(figure, Figure):\n            self.Curves.pop()\n            self.PlotType.pop()\n        else:\n            raise TypeError(\"Operator -= can only be used with instance of class Figure\")\n    def __imul__(self, figure: \"Figure\"):\n        if isinstance(figure, Figure):\n            self.Images.pop()\n            self.PlotType.pop()\n        else:\n            raise TypeError(\"Operator *= can only be used with instance of class Figure\")\n    def __itruediv__(self, figure: \"Figure\"):\n        if isinstance(figure, Figure):\n            self.Images.pop()\n            self.PlotType.pop()\n        else:\n            raise TypeError(\"Operator /= can only be used with instance of class Figure\")\n    def __ifloordiv__(self, figure: \"Figure\"):\n        if isinstance(figure, Figure):\n            self.Images.pop()\n           ",
    "outline_curves = [np.vstack((curve2, curve1, np.array([[curve2[0, 0], curve2[0, 1]]])))]\n        elif left_side:\n            outline_curves = [np.vstack((curve1, curve2))]\n        elif right_side:\n            outline_curves = [np.vstack((curve2, curve1))]\n        else:\n            outline_curves = [np.vstack((curve1, curve2))]\n        (image, extent, path) = ImageSlicer.sample_from_curve(image, curve, dpu)\n        return image, extent, path, outline_curves\n    @staticmethod\n    def custom_ring_arc_with_outline(image, dpu=1000.0, inner_curve: (np.ndarray, int, float, float, str) = (np.array([[0",
    "def extract_code_segment(block: str, max_characters: int = 100, min_context_lines: int = 1, max_context_lines: int = -1) -> Tuple[str, str, str]:\n        \"\"\"Extract code segment with specified context and argument count limitations.\"\"\"\n        code_segments = find_code_segments(block)\n        lines = block.splitlines()\n        examples = []\n        for start_pos, end_pos in code_segments:\n            result = CodeSegmentExtractor.extract_code_segment(lines, start_pos, end_pos, max_characters, min_context_lines, max_context_lines)\n            if result:\n                examples.append(result)\n        return examples\n    @staticmethod\n    def extract_function_call_details(lines: List[str], call: dict) -> Tuple[str, str, str]:\n        \"\"\"Extract function call details with",
    "examples = []\n        for assignment in assignments:\n            result = CodeSegmentExtractor.extract_section(lines, assignment['start_line'], assignment['end_line'], max_characters, min_context_lines, max_context_lines)\n            if result:",
    "curve[:] = affine.transform(curve)\n            return curve\n    @staticmethod\n    def apply_affine_multi(curves: List[np.ndarray], affine: Affine2D, inplace=True) -> List[np.ndarray]:\n        if inplace:\n            curves[:] = affine.transform(curves)\n            return curves\n        else:\n            transformed_curves = []\n            for i in range(len(curves)):\n                transformed_curves.append(affine.transform(curves[i]))\n            return transformed_curves\n    @staticmethod\n    def apply_affine_single(curve: np.ndarray, affine: Affine2D, inplace=True) -> np.ndarray:\n        if inplace:\n            curve[:] = affine.transform(curve)\n            return curve\n        else:\n            transformed_curves = []\n            for i in range(len(curves)):\n                transformed_curves.append(affine.transform(curves",
    "targets = node.targets\n            value = node.value\n        elif isinstance(node, ast.AnnAssign):\n            targets = node.targets\n            value = node.value\n        else:\n            return\n        for target in targets:\n            self.assignments.append({\n                'target': target,\n                'value': value,\n            })\n    def visit_AnnAssign(self, node):\n        self.collect_assignment_info(node)\n        self.generic_visit(node)\n    def visit_AnnAssign(self, node):\n        self.collect_assignment_info(node)\n        self.generic_visit(node)\n    def visit_AnnAssign(self, node):\n        self.collect_assignment_info(node)\n        self.generic_visit(node)\n    def visit_AnnAssign(self, node):\n        self.collect_assignment_info(node)\n        self.generic_visit(node)\n    def visit_AnnAssign(",
    "if len(middle) > min_left:\n                middle = middle[:min_left]\n            if len(middle) < min_right:\n                continue\n            new_examples.append((prefix, middle, suffix))\n        return new_examples\n    @staticmethod\n    def random_split_middle_examples_with_constraints(examples: List[Tuple[str, str, str]], min_left: int = 5, min_right: int = 5) -> List[Tuple[str, str, str]]:\n        \"\"\"Randomly split the middle section of examples with specific constraints.\"\"\"\n        new_examples = []\n        for example in examples:\n            prefix, middle, suffix = example\n            if len(middle) < min_left + min_right:\n                continue\n            if len(middle) > min_left:\n                middle = middle[:min_left]\n            if len(middle) < min_right:\n                continue\n            new_examples.",
    "_list(curves)\n    @staticmethod\n    def sine_wave_linear(n=100, radius=0.5, theta1=0.0, theta2=np.pi/2, amplitude=0.1, n_periods=2, period_offset=0.25, offset=(0.0, 0.0)):\n        theta = np.linspace(theta1, theta2, n)\n        period = (theta2 - theta1)/n_periods\n        freq = 2*np.pi/period\n        rho = radius + amplitude*np.sin((theta-theta1+period_offset*period)*freq)\n        curve = CurveTransforms.polar_to_cartesian(np.vstack((rho, theta)).T)\n        CurveTransforms.translate_single(curve, offset[0], offset[1], inplace=True)\n        return curve\n    @staticmethod\n    def sine",
    "curve.extend(new_curves)\n    @staticmethod\n    def translate_figure(figure: \"Figure\", x=0.0, y=0.0):\n        Transformer.translate_curves(figure.Curves, x, y)\n        figure.evaluate_bounds()\n    @staticmethod\n    def translate_curve(curve: \"list\", x=0.0, y=0.0):\n        Transformer.translate_curves(curve, x, y)\n        curve.evaluate_bounds()\n    @staticmethod\n    def translate_curves_with_offset(curves: \"list\", x=0.0, y=0.0, offset=0.0):\n        Transformer.translate_curves(curves, x, y)\n        for i in range(len(curves)):\n            curves[i][0, :] += offset\n            curves[i][1, :] += offset\n    @staticmethod\n    def translate_",
    "self.Image = image\n        self.current_outline = 0\n        self.PersistentClipPaths = []\n        self.PersistentTransforms = []\n        self.AdditiveTransforms = []\n        self.AdditionalCurves = []\n    def add_persistent_transform(self, transform):\n        self.PersistentTransforms.append(transform)\n    def add_persistent_transforms(self, transforms):\n        self.PersistentTransforms.extend(transforms)\n    def add_additive_transform(self, transform):\n        self.AdditiveTransforms.append(transform)\n    def add_additive_transforms(self, transforms):\n        self.AdditiveTransforms.extend(transforms)\n    def add_additional_curve(self, curve):\n        self.AdditionalCurves.append(curve)\n    def add_additional_curves(self, curves):\n        self.AdditionalCurves.extend(curves)\n    def update_persistent_transform(self, transform):",
    "curve = CurveTransforms.polar_to_cartesian(np.vstack((x_values, y_values)).T)\n        CurveTransforms.translate_single(curve, offset[0], offset[1], inplace=True)\n        return curve\n    @staticmethod\n    def circle(radius=1.0, offset=(0.0, 0.0)):\n        theta = np.linspace(0, 2 * np.pi, radius + 1)\n        rho = radius * np.ones(radius + 1)\n        curve = CurveTransforms.polar_to_cartesian(np.vstack((rho, theta)).T)\n        CurveTransforms.translate_single(curve, offset[0], offset[1], inplace=True)\n        return curve\n    @staticmethod\n    def circle_arc(radius=1.0, offset=(0.0, 0.0)):\n        theta = np.linspace(0, 2",
    "return sliced_image, extent, path, outline_curves\n    @staticmethod\n    def circular_arc(outer_radius, theta1, theta2, amplitude, n_periods, period_offset):\n        inner_curve = CurveGenerator.circular_arc(outer_radius, theta1, theta2, amplitude, n_periods, period_offset)\n        outer_curve = np.flip(CurveGenerator.circular_arc(outer_radius, theta1, theta2, amplitude, n_periods, period_offset), 0)\n        outline_curves = [inner_curve, outer_curve]\n        curve = np.vstack((inner_curve, outer_curve))\n        (image, extent, path) = ImageSlicer.sample_from_curve(image, curve, dpu)\n        return image, extent, path, outline_curves\n    @staticmethod\n    def circular_arc_2(outer_radius",
    "return self.meteor_score(generated, expected)\n    def bert_score(self, generated, expected):\n        try:\n            P, R, F1 = bert_score([generated], [expected], lang='en', rescale_with_baseline=True)\n            return F1.item()\n        except Exception as e:\n            print(f\"Error calculating BERTScore: {e}\")\n            return None",
    "value = node.value\n        else:\n            raise ValueError('Unknown assignment type: %s' % type(node))\n        self.assignments.append({\n            'target': targets,\n            'value': value,\n        })\n    def visit_Name(self, node):\n        self.generic_visit(node)\n    def visit_Subscript(self, node):\n        self.generic_visit(node)\n    def visit_ListComp(self, node):\n        self.generic_visit(node)\n    def visit_TupleComp(self, node):\n        self.generic_visit(node)\n    def visit_DictComp(self, node):\n        self.generic_visit(node)\n    def visit_SetComp(self, node):\n        self.generic_visit(node)\n    def visit_DictComprehension(self, node):\n        self.generic_visit(node)\n    def visit_DictComprehension(self,",
    "self.AdditionalCurves.append(curve)\n    def add_additional_curve(self, curve):\n        self.AdditionalCurves.append(curve)\n    def add_persistent_curve(self, curve):\n        self.PersistentCurves.append(curve)\n    def add_persistent_curve(self, curve):\n        self.PersistentCurves.append(curve)\n    def add_persistent_curve(self, curve):\n        self.PersistentCurves.append(curve)\n    def add_persistent_curve(self, curve):\n        self.PersistentCurves.append(curve)\n    def add_persistent_curve(self, curve):\n        self.PersistentCurves.append(curve)\n    def add_persistent_curve(self, curve):\n        self.PersistentCurves.append(curve)\n    def add_persistent_curve(self, curve):\n        self.PersistentCurves.append(curve)\n    def add",
    "def fit_c2c_multi(curves, extent):\n        x_bounds = (np.min(curves[:, 0]), np.max(curves[:, 0]))\n        y_bounds = (np.min(curves[:, 1]), np.max(curves[:, 1]))\n        return CurveTransforms.remap_c2c(curves, x_bounds, y_bounds, extent[0:2], extent[2:4])\n    @staticmethod\n    def tight_remap_c2c_multi(curves, rho_bounds, theta_bounds):\n        x_bounds = (np.min(curves[:, 0]), np.max(curves[:, 0]))\n        y_bounds = (np.min(curves[:, 1]), np.max(curves[:, 1]))\n        return CurveTransforms.remap_c2c(curves, x_bounds, y",
    "transforms.append(Affine2D().rotate(rotation_offset).scale(1, -1).rotate(rotation_offset + local_rotation_offset).translate(radius, 0).rotate(i * angle + global_rotation_offset))\n        return transforms\n\n    @staticmethod\n    def rotation_repeat(repetitions: int = None, delta_angle: float = None, rotation_offset=0.0, use_flip=True, flip_angle=0.0, reverse_rotation=False):\n        if repetitions is None and delta_angle is None:\n            repetitions = 1\n            angle = None\n        elif repetitions is None:\n            repetitions = int(np.trunc(2 * np.pi / delta_angle))\n            angle = None\n        elif delta_angle is None:\n            repetitions = np.maximum(1, repetitions)\n            angle = None\n        else:\n            repetitions = np.maximum"
]