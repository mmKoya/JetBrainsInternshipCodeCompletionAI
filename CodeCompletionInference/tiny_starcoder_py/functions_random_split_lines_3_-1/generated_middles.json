[
    "sform.set_global_rotation(global_rotation)\n        ImageSample.set_global_rotation(global_rotation + np.pi / segments)\n        ImageSample.set_global_rotation(global_rotation + np.pi / segments)\n        ImageSample.set_global_rotation(global_rotation + np.pi / segments)\n        ImageSample.set_global_rotation(global_rotation + np.pi / segments)\n        ImageSample.set_global_rotation(global_rotation + np.pi / segments)\n        ImageSample.set_global_rotation(",
    "port numpy as np\n        curve = np.array(curve)\n        curve = curve.reshape(height, width)\n        curve = curve.astype(np.float32)\n        curve = curve.reshape(height, width, 1)\n        curve = curve.transpose((2, 0, 1))\n        curve = curve.reshape(height, width, 1, 1)\n        curve = curve.transpose((2, 0, 1, 3))\n        curve = curve.reshape(height, width, 1, 1, 1)\n        curve",
    "e(node, ast.Name):\n            targets = [node.id]\n            value = node.id\n        elif isinstance(node, ast.Subscript):\n            targets = [node.value]\n            value = node.value\n        elif isinstance(node, ast.Call):\n            targets = [node.func]\n            value = node.func\n        elif isinstance(node, ast.Attribute):\n            targets = [node.attr]\n            value = node.attr\n        elif isinstance(node, ast.Subscript):\n            targets = [node.value]\n            value = node.value\n        elif isinstance",
    "    \"name\": func_name,\n                \"args\": args,\n                \"start_line\": node.lineno,\n                \"end_line\": node.end_lineno,\n                \"col_offset\": node.col_offset,\n                \"end_col_offset\": node.end_col_offset\n            })\n        self.generic_visit(node)\n\n    def visit_Import(self, node):\n        self.generic_visit(node)\n\n    def visit_ImportFrom(self, node):\n        self.generic_visit(node)\n\n    def visit_ImportFromFrom(self,",
    "elf.num_swaps):\n        swap_count = min_swaps_to_transform(initial_perm, swap_counts)\n        swap_counts.append(swap_count)\n    plt.hist(swap_counts, bins=range(max(swap_counts) + 2), edgecolor='black')\n    plt.xlabel(\"Minimal number of swaps to return to original permutation\")\n    plt.ylabel(\"Frequency\")\n    plt.title(f\"Histogram of minimal swaps for {num_swaps} random swaps on a {n}-element permutation\")\n    plt",
    "t = (dataset_name, examples)\n                    datasets.append(data)\n        return datasets\n\n\ndef random_split_dataset(\n        dataset_name: str,\n        examples_split: List[Tuple[str, str, str]],\n        max_values: List[int],\n        max_context_lines: List[int],\n        dataset_type: str,\n        random_split_name: str\n) -> Tuple[str, List[Tuple[str, str, str]]]:\n    random_split_name = random_split_name.replace(' ', '_')\n    random",
    "_line += 1\n                start_idx = 0\n            else:\n                current_line += 1\n                start_idx = end_idx\n        prefix = lines[current_line][:start_idx]\n        arguments = ', '.join(function_call['arguments'])\n        suffix = lines[current_line][end_idx:]\n        return prefix, arguments, suffix\n\n    def extract_function_call_details_with_prefix(lines: List[str], function_call: dict) -> Tuple[str, str, str]:\n        \"\"\"Extract the components of a function call: prefix,",
    "ert):\n            targets = [node.target]\n            value = node.value\n        elif isinstance(node, ast.AnnAssign):\n            targets = [node.target]\n            value = node.value\n        else:\n            return\n        start_line = node.lineno\n        end_line = node.end_lineno\n        end_col = node.end_col_offset\n        start_col = value.col_offset if hasattr(value, 'col_offset') else 0\n        for target in targets:\n            assignment_info = {\n               'start_line': start_line,\n                '",
    "_curves(arc)\n        curves = []\n        for i in range(repetitions):\n            curve = CurveTransforms.translate_single(curve, i*(width+gap), 0, False)\n            curves.append(CurveTransforms.merge_curves(curve))\n        return CurveTransforms.merge_curves(curves)\n\n    def circle(n=100, width=0.8, gap=0.2, repetitions=1):\n        start = -(width+gap)/2\n        arc_start = -width/2\n        end = -start\n        arc",
    "image, inner_curve, outer_curve, segments, inner_radius, outer_radius, width, sample_rotation)\n        image_sample = ImageSample(image_sliced, extent, path, outline_curves)\n        image_sample.set_rotation(sample_rotation)\n        return image_sample\n\n    def test_rotational_repeat_additive(image, dpu=1000.0, segments=8, inner_radius=0.5, outer_radius=0.8, width=0.05, sample_rotation=0.0",
    "       else:\n            raise NotImplementedError(\n                'Unknown node type: {}'.format(type(node)))\n        else:\n            raise NotImplementedError(\n                'Unknown node type: {}'.format(type(node)))\n        return targets, value\n\n    def collect_assignment_info_for_node(self, node):\n        if isinstance(node, ast.Assign):\n            targets = node.targets\n            value = node.value\n        elif isinstance(node, ast.AugAssign):\n            targets = [node.target]\n            value = node.value\n        elif isinstance(node, ast.AnnAssign):\n            targets = [",
    "ER}}}\"\n        if match.group(0) == placeholder:\n            return placeholder\n        else:\n            return match.group(0)\n    for match in re.finditer(string_pattern, code):\n        strings[match.group(0)] = string_replacer(match)\n    for match in re.finditer(comment_pattern, code):",
    "r(nodes.T, degree=nodes.shape[0] - 1)\n        bezier_curve = Curve(nodes.T, degree=nodes.shape[0] - 1)\n        return bezier_curve.evaluate_multi(values).T\n",
    " = total.setdefault(key, 0) + value\n                    counts[key] += 1\n        return total, counts",
    "r < new_id:\n            similarities[(neighbour, new_id)] = similarity\n        else:",
    "              break\n            middle = middle[:split_idx]",
    "rho = curve_cartesian[:, 0] - y_bounds[0]\n        else:",
    " region2_id)\n    region1_info = regions[region1_id]\n    region2_info = regions[region2_id]\n    region1_id = region1_info['id']\n    region2_id = region2_info['id']\n    region1_info['neighbors'] = set()\n    region2_info['neighbors'] = set()\n    for neighbour in region1_info['neighbors']:\n        if neighbour < region1_id:\n            region1_info['neighbors'].add(neighbour)\n        else:\n            region1_info['neighbors'].",
    " = scale\n        else:\n            scales = np.array(scale)\n        base_curves = copy.deepcopy(curves)\n        Transformer.scale_curves(curves, scales[0])\n        for i in range(1, repetitions):\n            new_curves = copy.deepcopy(base_curves)\n            Transformer.rotate_curves(new_curves, i*angle)\n            Transformer.scale_curves(new_curves, scales[i])\n            curves.extend(new_curves)\n        return curves\n\n    def rotate_curves(cur",
    "_holder = match.group(0)\n        original = match.group(1)\n        if placeholder in strings:\n            strings[placeholder].append(original)\n        else:\n            strings[placeholder] = [original]\n    for line in code.splitlines():\n        for match in re.finditer(string_pattern, line):\n            string_replacer(match)",
    "  value = node.value\n        elif isinstance(node, ast.AnnAssign):\n            targets = [node.target]\n            value = node.value\n        elif isinstance(node, ast.AnnAssign):\n            targets = [node.target]\n            value = node.value\n        elif isinstance(node, ast.AnnAssign):\n            targets = [node.target]\n            value = node.value\n        elif isinstance(node, ast.AnnAssign):\n            targets = [node.target]\n            value = node.value\n        elif isinstance(node, ast.AnnAssign):\n            targets = [node.",
    "\n                for code_block in code_blocks:\n                    examples.extend(extract_method(code_block, max_value, max_context))\n                if examples:\n                    datasets.append((dataset_name, examples))\n        return datasets\n\n\nclass TextUtils:\n    def __init__(self, max_values: List[int], max_context_lines: List[int], dataset_type: str):\n        self.max_values = max_values\n        self.max_context_lines = max_context_lines\n        self.dataset_type = dataset_type\n\n    def random",
    "xt_lines,",
    ".set_image_sample(image_sample)\n        image_sample.set_global_rotation(global_rotation)\n        image_sample.set_global_rotation(global_rotation + np.pi / segments)\n        image_sample.set_global_rotation(global_rotation + np.pi / 2)\n        image_sample.set_global_rotation(global_rotation + np.pi / 4)\n        image_sample.set_global_rotation(global_rotation + np.pi / 8)\n        image_sample.set_global_rotation",
    "0 else middle_end))\n            prefix = lines[start_prefix:end_suffix]\n            suffix = '\\n' + '\\n'.join(lines[middle_start:middle_end])\n            examples.append((prefix, middle_text, suffix))\n        return examples\n\n\ndef extract_examples(block: str, min_context_lines: int = 1, max_context_lines: int = -1) -> List[Tuple[str, str, str]]:\n    \"\"\"Generate examples by extracting specified context lines with configurable context lines.\"\"\"\n    lines = block.splitlines()",
    "t,\n                                                                                   global_rotation,\n                                                                                   global_rotation + np.pi / segments,\n                                                                                   global_rotation + np.pi / segments,\n                                                                                   global_rotation + np.pi / segments,\n                                                                                   global_rotation + np.pi / segments,\n                                                                                   global_rotation + np.pi / segments,\n                                                                                   global_rotation + np.pi / segments,\n                                                                                   global_rotation + np.pi / segments,\n                                                                                   global_rotation + np.pi / segments,\n                                                                                   global_rotation + np.pi / segments,\n                                                                                   global_rotation + np",
    "_curve(x_bounds[0], y_bounds[0], subdivisions[0], line_width, fill) for _ in range(subdivisions[0])]\n        return DiamondFigure(diamonds, x_bounds[0], y_bounds[0], subdivisions[0], line_width, fill)\n\n    def diamond_figure_with_fill(x_bounds=(0.0, 1.0), y_bounds=(0.0, 1.0), subdivisions=(3, 3), line_width=1",
    " condition(node):\n            conditions.append(node)\n    return conditions\n\n\ndef find_conditions_from_code(code):\n    tree = ast.parse(code)\n    conditions = []\n    for node in ast.walk(tree):\n        if is_condition(node):\n            conditions.append(node)\n    return conditions\n\n\ndef is_condition(node):\n    if isinstance(node, ast.IfExp):\n        return True\n    elif isinstance(node, ast.Expr):\n        return isinstance(node.value, ast.IfExp)\n    elif isinstance(node, ast.Call",
    "d = middle_start\n            end_prefix = middle_end\n            end_suffix = middle_end\n            while start_prefix < end_prefix:\n                start_prefix += 1\n                end_suffix += 1\n            while start_prefix < end_prefix + middle_line_count:\n                start_prefix += 1\n                end_suffix += 1\n            while start_prefix < end_prefix + middle_line_count + middle_line_count:\n                start_prefix += 1\n                end_suffix += 1\n            while start_prefix < end_prefix + middle_",
    "ters\":\n            curve = np.array([function(x) for x in values])\n        else:\n            print(\"Invalid input_coordinate, curve will default to 0,0\")\n            curve = np.array([[0.0, 0.0]])\n        return curve\n\n    def polar_to_cartesian(curve):\n        if curve.shape[0] == 2:\n            x_values = curve[:, 0]\n            y_values = curve[:, 1]\n            curve = np.vstack((x_values, y_values)).T\n        elif curve.shape[",
    "ts) + 1), density=True)\n    plt.title(f\"Histogram of minimal swaps for {num_swaps} random swaps on a {n}-element permutation\")\n    plt.show()\n\ndef create_histogram_with_swaps(n, num_swaps, samples=1000):\n    initial_perm = np.random.permutation(n)\n    swap_counts = []\n    for _ in range(samples):\n        perm1 = np.random.permutation(n)\n        perm2 = np.random.permutation(n)\n       ",
    "attr(arg, \"id\") for arg in node.args]\n        if func_name is None:\n            return\n        self.function_calls.append({\n            \"function\": func_name,\n            \"arguments\": args,\n            \"start_line\": node.lineno,\n            \"end_line\": node.end_lineno,\n            \"col_offset\": node.col_offset,\n            \"end_col_offset\": node.end_col_offset\n        })\n\n    def visit_Assign(self, node):\n        func_name = None\n        if isinstance(node.value, ast",
    "t i == repetitions - 1:\n                angle = np.pi - angle\n            trans_data = Affine2D().rotate(angle).scale(1, -1).rotate(i * angle + flip_angle + rotation_offset)\n            transforms.append(trans_data)\n        return transforms\n\n    def rotate_and_scale(self, transforms: List[Affine2D], scale: float = 1.0, rotation_offset=0.0, use_flip=True, flip_angle=0.0, reverse_rotation=False):\n        if len(",
    "g = lines[current_line][start_idx]\n        arguments = ', '.join(function_call['arguments'])\n        suffix = lines[current_line][start_idx:]\n        return prefix, arguments, suffix\n\n    def extract_function_call_details_with_prefix(lines: List[str], function_call: dict) -> Tuple[str, str, str]:\n        \"\"\"Extract the components of a function call: prefix, arguments, and suffix.\"\"\"\n        current_line, start_idx, end_idx = (\n            function_call['end_line'] - 1",
    "height, half)\n        outline_curves = []\n        for i in range(len(curve)):\n            outline_curves.append(curve[i])\n        outline_curves = np.array(outline_curves)\n        outline_curves = outline_curves.reshape(1, -1)\n        outline_curves = outline_curves.astype(np.float32)\n        outline_curves = outline_curves.transpose(1, 2, 0)\n        outline_curves = outline_curves.reshape(1, -1",
    "str]]]]:\n        datasets: List[Tuple[str, List[Tuple[str, str, str]]] = []\n        for max_value in max_values:\n            for max_context in max_context_lines:\n                dataset_name = f'{dataset_type}_{max_value}_{max_context}'\n                examples = []\n                for block in code_blocks:\n                    examples.extend(extract_method(block, max_value, max_context))\n                if examples:\n                    datasets.append((dataset_name, examples))\n                    random_split_name = f'random_split",
    " np.vstack((x_values, y_values)).T\n        else:\n            print(\"Invalid input_coordinate, curve will default to 0,0\")\n            curve = np.array([[0.0, 0.0]])\n        return curve\n\n    def polar_to_cartesian(curve):\n        if curve.shape[0] == 2:\n            x_values = curve[:, 0]\n            y_values = curve[:, 1]\n            curve = np.vstack((x_values, y_values)).T\n        elif curve.shape[0] == ",
    "ode.func, ast.Name):\n            func_name = node.func.id\n        elif isinstance(node.func, ast.Attribute):\n            parts = []\n            current = node.func\n            while isinstance(current, ast.Attribute):\n                parts.insert(0, current.attr)\n                current = current.value\n            if isinstance(current, ast.Name):\n                parts.insert(0, current.id)\n            func_name = \".\".join(parts)\n        args = [ast.get_source_segment(self.source_code, arg) for arg in node",
    "turn results\n\n    def exact_match(self, generated, expected):\n        return self.exact_match_score(generated, expected)\n\n    def exact_match_score(self, generated, expected):\n        return self.exact_match_score_score(generated, expected)\n\n    def exact_match_score_score(self, generated, expected):\n        return self.exact_match_score_score_score(generated, expected)\n\n    def rouge_score(self, generated, expected):\n        return self.rouge_score_score(generated, expected)\n\n    def rouge",
    "eap1, theta2, segments)\n        inner_rho = np.linspace(inner_radius, outer_radius, segments)\n        outer_rho = np.linspace(outer_radius, theta1, segments)\n        theta = np.linspace(theta1, theta2, segments)\n        inner_rho = inner_rho.reshape(segments, 1)\n        outer_rho = outer_rho.reshape(segments, 1)\n        theta = theta.reshape(segments, 1)\n        inner_rho = inner_rho.reshape(segments, 1)\n        outer",
    "      'target': target,\n                'value': value,\n                'lineno': start_line,",
    "= []\n        self.LocalOutlineCurves = local_outline_curves\n        self.AdditionalCurves = []\n        self.PersistentTransforms.append(Affine2D())\n        self.PersistentTransforms.append(Affine2D())\n        self.PersistentTransforms.append(Affine2D())\n        self.PersistentTransforms.append(Affine2D())\n        self.PersistentTransforms.append(Affine2D())\n        self.PersistentTransforms.append(Affine2D())\n        self.PersistentTransforms.append(Affine2D())\n        self.PersistentTransforms.append(Affine2D())\n        self.",
    "  parentheses_balance += 1 if function_call['end_line'] == end_idx else -1 if function_call['end_line'] == start_idx else 0\n        prefix = '\\n'.join(lines[function_call['start_line'] - 1:current_line] + [lines[current_line][:start_idx + 2]])\n        arguments = ', '.join(function_call['arguments'])\n        suffix = lines[function_call['end_line'] - 1][end_idx:]\n        return prefix, arguments, suffix\n\n    def",
    "es\n        local_rotation_offset = np.random.uniform(-local_rotation_offset, local_rotation_offset)\n        global_rotation_offset = np.random.uniform(-global_rotation_offset, global_rotation_offset)\n        transforms = []\n        for i in range(repetitions):\n            if i % 2 == 0 or not use_flip:\n                trans_data = Affine2D().rotate(local_rotation_offset).translate(radius, 0).rotate(i * angle + global_rotation_offset)\n            else:\n                trans_",
    " 1], [1, 0], [1, 1], [0, 1], [0, 0]])\n        curve = np.array([[0, 0], [0, 1], [1, 0], [1, 1], [0, 1], [0, 0]])\n        curve = np.flip(curve, 0)\n        curve = np.flip(curve, 1)\n        curve = np.flip(curve, 2)\n        curve = np.flip(curve, 3)\n        curve = np.flip",
    " range(len(self.Curves)):\n            if self.PlotType[i] == \"fill\":\n                ax.fill(self.Curves[i][:, 0], self.Curves[i][:, 1], color=\"k\", zorder=self.z_order)\n            elif self.PlotType[i] > 0:\n                ax.plot(self.Curves[i][:, 0], self.Curves[i][:, 1], color=\"k\", solid_capstyle='round',\n                         linewidth=self.PlotType[i],",
    "_info['similarity'], region_info['size'], region_info['color_histogram'], region_info['size'])\n        if similarity > 0:\n            similarities[(new_id, neighbour)] = similarity",
    "] = True\n            cycle_length += 1\n            j += 1\n        if cycle_length == 0:\n            swaps += 1\n    return swaps\n\ndef min_swaps_to_transform_2(perm1, perm2):\n    n = len(perm1)\n    index_map = {value: i for i, value in enumerate(perm2)}  \n    perm1_mapped = [index_map[value] for value in perm1]  \n    visited = [False] * n\n    swaps = 0\n    for i in range(n):\n       ",
    "th, gap, pits_per_segment), 1, inner_radius, depth, \"cartesian\"), 1, outer_radius, depth, \"cartesian\")\n        image_sliced = image.rotate(outer_curve, sample_rotation)\n        image_sliced = image_sliced.rotate(inner_curve, sample_rotation)",
    "th from a line.\n\n        Args:\n            line: The line to split.\n\n        Returns:\n            A tuple containing the indentation and the code text.\n        \"\"\"\n        indentation_length = len(line) - len(line.lstrip())\n        code_text = line[indentation_length:]\n        return indentation_length, code_text\n\n    def split_code(line: str) -> Tuple[str, str]:\n        \"\"\"Separate code from a line.\n\n        Args:\n            line: The line to split.\n\n        Returns:\n            A tuple containing the indentation and the code text.\n        \"\"\"\n       "
]