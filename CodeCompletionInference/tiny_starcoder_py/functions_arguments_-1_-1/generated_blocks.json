[
    "def random_edge_ring(image, dpu=1000.0, segments=8, grid_size=(5, 3), inner_radius=0.5, outer_radius=0.8, width=0.1,\n                         sample_rotation=0.0, global_rotation=0.0, left_edge=False, right_edge=False, interpolation=\"spline\"):\n        (image_sliced, extent, path, outline_curves) = ImageSlicer.random_ring_arc(image, dpu, grid_size, (1, 1), inner_radius, outer_radius, width,\n                                                                                   sample_rotation, sample_rotation+np.pi/segments, left_edge, right_edge, interpolation)\n        image_sample = ImageSample(image_sliced, extent, path, outline_curves)\n        ImageSampleTransformer.rotational_repeat_additive(image_sample, global_rotation, interpolation)\n        return image_sample\n\n    def random_edge_ring_with_outline(image, dpu=1000.0, segments=8, grid_size=(5, 3), inner_radius=0.5, outer_radius=0.8, width=0.1,\n                                     sample_rotation)\n        return image_sample",
    "def edge_type1(width=1.0, height=0.2, flip=False, half=False):\n        if flip:\n            height = -height\n        triangle1 = np.array([[0, 0], [0.1*width, height], [0.2*width, 0]])\n        triangle2 = np.array([[0.8*width, 0], [0.9*width, height], [width, 0]])\n        curve_nodes = np.array([[0.2*width, 0], [0.4*width, height], [0.6*width, height], [0.8*width, 0]])\n        curve = CurveGenerator.bezier(curve_nodes, np.linspace(height, width, 100), half=half)\n        return CurveTransforms.merge_curves([triangle1, curve])\n\n    def edge_type2(width=1.0, height=0.2, flip=False, half=False):\n        if flip:\n            height = -height\n        triangle1 = np.array([[0, 0], [))\n        if half:\n            return CurveTransforms.merge_curves([triangle1, curve])\n        return CurveTransforms.merge_curves([triangle1, curve, triangle2])",
    "def random_ring_arc(image, dpu=2000.0, grid_size=(5, 5), step_size=(1, 1), inner_radius=0.5, outer_radius=0.8, width=0.1, theta1=0.0, theta2=np.pi/6,\n                        left_side=False, right_side=False, interpolation=\"spline\") -> (np.ndarray, (float, float, float, float), Path, List[np.ndarray]):\n        curve1 = CurveGenerator.random_edge(grid_size, step_size, interpolation)\n        curve2 = CurveGenerator.random_edge(grid_size, step_size, interpolation)\n        inner_curve = (curve1, 1, inner_radius, width, \"cartesian\")\n        outer_curve = (curve2, 1, outer_radius, width, \"cartesian\")\n        (image, extent, path, outline_curves) = ImageSlicer.custom_ring_arc(curve1, curve2, inner_curve, outer_curve, dpu, grid_size, step_size, inner_radius, outer_radius, width, theta1, theta2, left_side, right_side)\n        image = ImageSlicer.custom_ring_arc(curve1, curve2, inner_curve, outer_curve, dpu)\n        return image, extent, path, outline_curves",
    "def pit_ring(image, dpu=1000.0, segments=8, pits_per_segment=1, inner_radius=0.5, outer_radius=0.8, width=0.8, depth=0.4, gap=0.2, sample_rotation=0.0,\n                   global_rotation=0.0, half=False, left_edge=False, right_edge=False) -> ImageSample:\n        outer_curve = (CurveGenerator.pit(image, dpu, segments, pits_per_segment, inner_radius, outer_radius, width, depth, gap, sample_rotation, global_rotation, half, left_edge, right_edge)), 1, outer_radius, depth, \"cartesian\")\n        inner_curve = (CurveTransforms.scale_single(CurveGenerator.pit(100, width, gap, pits_per_segment), (1, -1)), 1, inner_radius, depth, \"cartesian\")\n        (image_sliced, extent, path, outline_curves) = ImageSlicer.custom_ring_arc(image, dpu, inner_curve, outer_curve, sample_rotation,\n                                                                                   sample_rotation + np.pi / segments, left_edge, right_edge)\n        image_sample = ImageSample(image_sliced, extent, path, outline_curves)\n        ImageSampleTransformer.rotational_repeat_additive(image_sample, 2 * segments, None,\n                                                          rotation_offset=-sample_rotation+global_rotation, use_flip=True,\n                                                          flip_angle=(2 * sample_rotation + np.pi / segments) / 2)\n        return image_sample",
    "def custom_ring_arc(image, dpu=1000.0, inner_curve: (np.ndarray, int, float, float, str) = (np.array([[0.0, 0.0]]), 1, 0.5, 0.05, \"cartesian\"),\n                        outer_curve: (np.ndarray, int, float, str) = (np.array([[0.0, 0.0]]), 1, 0.8, 0.05, \"cartesian\"), theta1=0.0, theta2=np.pi/6,\n                        left_side=False, right_side=False) -> (np.ndarray, (float, float, float, float), Path, List[np.ndarray]):\n        if inner_curve is None:\n            curve1 = np.array([[0, 0]])\n        else:\n            (curve1, periods1, radius1, width1, coordinate_type1) = inner_curve\n            if coordinate_type1 == \"polar\":\n                curve1 = CurveTransforms.tight_remap_polar_to_polar(curve1, (radius1, radius1+width1), (theta1, theta1 + (theta2-theta1)/periods1))\n                curve1 = CurveTransforms.polar_to_cartesian(curve1)\n            else:\n                curve1 = np.vstack((-curve1[:, 0], curve1[:, 1])).T\n                curve1 = CurveTransforms.tight_map_cartesian_to_polar(curve1, (radius1, radius1+width1), (theta1, theta1 + (theta2-theta1)/periods1))\n            curve1 = CurveTransforms.polar_to_cartesian(curve1)\n            curve1 = np.vstack([CurveTransforms.rotate_single(curve1, i * (theta2 - theta1) / periods1, inplace=False) for i in range(0, periods1)])\n        (curve2, periods2, radius2, width2, coordinate_type2) = outer_curve\n        if coordinate_type2 == \"polar\":\n            curve2 = CurveTransforms.tight_remap_polar_to_polar(curve2, (radius2 - width2, radius2), (theta1, theta1 + (theta2-theta1)/periods2))\n            curve2 = CurveTransforms.polar_to_cartesian(curve2)\n        else:\n            curve2 = np.vstack((-curve2[:, 0], curve2[:, 1])).T\n            curve2 = CurveTransforms.tight_map_cartesian_to_polar(curve2, (radius2 - width2, radius2), (theta1, theta1 + (theta2-theta1)/periods2))\n        curve2 = CurveTransforms.polar_to_cartesian(curve2)\n        curve2 = np.flip(np.vstack([CurveTransforms.rotate_single(curve2, i*(theta2-theta1)/periods2, inplace=False) for i in range(0, periods2)]), 0)\n        if left_side and right_side:\n            outline_curves = [np.vstack(curve1), np.vstack(curve2)]\n        elif right_side:\n            outline_curves = [np.vstack((curve2, curve1))]\n        elif left_side:\n            outline_curves = [np.vstack((curve1, curve2))]\n        else:\n            outline_curves = [curve2, curve1]\n        curve =)]\n        elif right_side:\n            outline_curves = [np.vstack((curve1, curve2))]\n        elif left_side:\n            outline_curves = [np.vstack((curve2, curve1))]\n        else:\n            outline_curves = [curve1, curve2]\n        curve = np.vstack((curve1, curve2))\n        (image, extent, path) = ImageSlicer.sample_from_curve(image, curve, dpu)\n        return image, extent, path, outline_curves",
    "def extract_lines(block: str, middle_line_count: int = 1, min_context_lines: int = 1, max_context_lines: int = -1) -> List[Tuple[str, str, str]]:\n        \"\"\"Generate examples by extracting specified middle lines with configurable context lines.\"\"\"\n        lines = block.splitlines()\n        num_lines = len(lines)\n        if num_lines < 2 * min_context_lines + middle_line_count:\n            return []\n        examples = []\n        for middle_start in range(min_context_lines, num_lines - min_context_lines - middle_line_count):\n            middle_end = middle_start + middle_line_count\n            start_prefix = max(0, middle_start - (max_context_lines if max_context_lines >= 0 else middle_start))\n            end_suffix = min(middle_end + middle_line_count, num_lines - middle_start)\n            prefix = '\\n'.join(lines[start_prefix:middle_start]) + '\\n' + '\\n'.join(lines[middle_start:middle_end])\n            suffix = '\\n' + '\\n'.join(lines[middle_end:end_suffix]))\n            indentation, middle_text = TextUtils.split_indentation('\\n'.join(lines[middle_start:middle_end]))\n            prefix = '\\n'.join(lines[start_prefix:middle_start]) + '\\n' + indentation\n            suffix = '\\n' + '\\n'.join(lines[middle_end:end_suffix])\n            examples.append((prefix, middle_text, suffix))\n        return examples",
    "def colorize_segments(segments):\n    num_segments = np.max(segments) + 1\n    colors = np.random.randint(1, num_segments, size=num_segments)\n    color_image = np.zeros((segments.shape[0], segments.shape[1], 3), dtype=np.uint8)\n    for i in range(num_segments):\n        color_image[segments == i] = colors[i]\n    return color_image\n\n\ndef colorize_)\n    color_image = np.zeros((segments.shape[0], segments.shape[1], 3), dtype=np.uint8)\n    for i in range(num_segments):\n        color_image[segments == i] = colors[i]\n    return color_image",
    "def regular_polygon_ring(image, dpu=1000.0, segments=8, sides_per_segment=1, inner_radius=0.5, outer_radius=0.8, sample_rotation=0.0, global_rotation=0.0, left_edge=False, right_edge=False):\n        (image_sliced, extent, path, outline_curves) = ImageSlicer.regular_polygon_ring_arc(image, dpu, sides_per_segment, inner_radius, outer_radius,\n                                                                                            sample_rotation, sample_rotation+np.pi/segments, left_edge, right_edge)\n        image_sample = ImageSample(image_sliced, extent, path, outline_curves)\n        ImageSampleTransformer.rotational_repeat_additive(image_sample, global_rotation, global_rotation+np.pi/segments, sides_per_segment, inner_radius, outer_radius,\n                                                                                            sample_rotation, sample_rotation+np.pi/segments, left_edge, right_edge)\n        return image_sample\n\n    def regular_polygon_ring_arc(image, dpu=10)\n        return image_sample",
    "def mirror_persistent(image_sample: ImageSample, mirror_angle=0.0):\n        transform = Affine2D().rotate(-mirror_angle).scale(image_sample.size)\n        image_sample.PersistentClipPaths.append(image_sample.PersistentClipPaths[0] + image_sample.PersistentClipPaths[1]).rotate(mirror_angle)\n        new_persistent_transforms = []\n        new_persistent_paths = []\n        for i in range(len(image_sample.PersistentTransforms)):\n            new_persistent_transforms.append(image_sample.PersistentTransforms[i] + transform)\n            new_persistent_paths.append(image_sample.PersistentClipPaths[i])\n        image_sample.PersistentClipPaths.extend(new_persistent_paths)\n        image_sample.PersistentTransforms.extend(new_persistent_transforms)",
    "def rotation_repeat_curves(curves: \"list\", number_of_segments=None, delta_angle=None, scale=1.0, reverse_rotation=False):\n        if number_of_segments is None and delta_angle is None:\n            repetitions = 1\n            angle = None\n        elif number_of_segments is None:\n            repetitions = np.trunc(2*np.pi/delta_angle)\n            angle = None\n        elif delta_angle is None:\n            repetitions = np.maximum(1, number_of_segments)\n            angle = None\n        else:\n            repetitions = np.maximum(np.ceil(number_of_segments/delta_angle), number_of_segments)\n            angle = delta_angle\n        if angle is None:\n            angle = 2*np.pi/repetitions\n        if reverse_rotation:\n            angle = -angle\n        scale = np.array(scale)\n        if scale.size == 1:\n            scales = scale)\n            angle = delta_angle\n        if angle is None:\n            angle = 2*np.pi/repetitions\n        if reverse_rotation:\n            angle = -angle\n        scale = np.array(scale)\n        if scale.size == 1:\n            scales = scale*np.ones(repetitions)\n        elif scale.size == 2:\n            scales = np.linspace(scale[0], scale[1], repetitions)\n        elif scale.size == repetitions:\n            scales = scale\n        else:\n            scales = np.ones(repetitions)\n        base_curves = copy.deepcopy(curves)\n        Transformer.scale_curves(curves, scales[0])\n        for i in range(1, repetitions):\n            new_curves = copy.deepcopy(base_curves)\n            Transformer.rotate_curves(new_curves, i*angle)\n            Transformer.scale_curves(new_curves, scales[i])\n            curves.extend(new_curves)",
    "def math_function(function, values, input_coordinate=\"x_input\", polar=False):\n        if input_coordinate == \"x_input\":\n            x_values = values\n            y_values = np.array([function(x) for x in x_values])\n            curve = np.vstack((x_values, y_values)).T\n        elif input_coordinate == \"y_input\":\n            y_values = values\n            x_values = np.array([function(x) for x in x_values])\n            curve = np.vstack((x_values, y_values)).T\n        elif input_coordinate == \"parametric\":\n            result = [function(value) for value in values]\n            curve = np.array(result)\n        else:\n            print(\"Invalid input_coordinate, curve will default to 0,0\")) for y in y_values])\n            curve = np.vstack((x_values, y_values)).T\n        elif input_coordinate == \"parametric\":\n            result = [function(value) for value in values]\n            curve = np.array(result)\n        else:\n            print(\"Invalid input_coordinate, curve will default to 0,0\")\n            curve = np.array([[0.0, 0.0]])\n        if polar:\n            curve = CurveTransforms.polar_to_cartesian(curve)\n        return curve",
    "def ring(image, dpu=1000.0, segments=8, inner_radius=0.5, outer_radius=0.8, sample_rotation=0.0) -> ImageSample:\n        (image_sliced, extent, path, outline_curves) = ImageSlicer.ring_arc(image, dpu, segments, inner_radius, outer_radius, sample_rotation)\n        image_sample = ImageSample(image_sliced, extent, path, outline_curves)\n        ImageSampleTransformer.rotational_repeat_additive(image_sample, 2*segments, None, rotation_offset=-sample_rotation,\n                                                          use_flip=True)\n        image_sample = ImageSample(image_sliced, extent, path, outline_curves)\n        ImageSampleTransformer.rotational_repeat_additive(image_sample, 2*segments, None, rotation_offset=-sample_rotation,\n                                                          use_flip=True, flip_angle=(2*sample_rotation+np.pi/segments)/2)\n        return image_sample",
    "def tight_map_cartesian_to_polar(curve_cartesian, rho_bounds, theta_bounds):\n        x_bounds = (np.min(curve_cartesian[:, 0]), np.max(curve_cartesian[:, 0]))\n        y_bounds = (np.min(curve_cartesian[:, 1]), np.max(curve_cartesian[:, 1]))\n        rho_bounds = (np.min(curve_cartesian[:, 2]), np.max(curve_cartesian[:, 2]))\n        theta_bounds = (np.min(curve_cartesian[:, 3]), np.max(curve_cartesian[:, 3]))\n        return CurveTransforms.cartesian_to_))\n        return CurveTransforms.square_map_cartesian_to_polar(curve_cartesian, x_bounds, y_bounds, rho_bounds, theta_bounds)",
    "def rotate_curves(curves: \"list\", angle=0):\n        transform = Affine2D().rotate(curves[0], angle)\n        for i in range(len(curves)):\n            curves[i] = transform.transform(curves[i])",
    "def merge_regions(mask, regions, similarities, region1_id, region2_id):\n    new_id = min(region1_id, region2_id)\n    region1_info = regions[region1_id]\n    region2_info = regions[region2_id]\n    for neighbour in region1_info['neighbors']:\n        if neighbour < region1_id:\n            del similarities[(neighbour, region1_id)]\n        else:\n            del similarities[(region1_id, neighbour)]\n    similarities[(region1_id, region2_id)] = 0\n    for neighbour in region2_info['neighbors']:\n        if neighbour < region2_id:\n            del similarities[(neighbour, region2_id)]\n        else:\n            del similarities[(region2_id, neighbour)]\n    new_mask = np.logical_or(region1_info['mask'], region2_info['mask'])\n    mask[new_mask] = new_id\n    new_region = {\n        'mask': new_mask,\n        'neighbors': region1_info['neighbors'].union(region2_info['neighbors']),\n        'color_histogram': merge_histograms(region1_info['color_histogram'],\n                                            region1_info['size'],\n                                            region2_info['color_histogram'],\n                                            region2_info['size']),\n        'size': region1_info['size'] + region2_info['size'],\n    }\n    new_region['neighbors'].discard(new_id)\n    new_region['neighbors'].discard(max(region1_id, region2_id))\n    for neighbour in new_region['neighbors']:\n        similarity = histogram_intersection(similarities, similarities, neighbour, new_id)\n        if neighbour < new_id:\n            similarities[(neighbour, new_id)] = similarity\n        else:\n            similarities[(new_id, neighbour)] = similarity\n    del regions[region1_id]\n    del regions[region2_id]\n    regions[new_id] = new_region\n   )\n        if neighbour < new_id:\n            similarities[(neighbour, new_id)] = similarity\n        else:\n            similarities[(new_id, neighbour)] = similarity\n    del regions[region1_id]\n    del regions[region2_id]\n    regions[new_id] = new_region\n    for neighbor in regions[new_id]['neighbors']:\n        regions[neighbor]['neighbors'].discard(max(region1_id, region2_id))\n        regions[neighbor]['neighbors'].add(new_id)",
    "def regular_polygon_ring(image, dpu=1000.0, segments=8, sides_per_segment=1, inner_radius=0.5, outer_radius=0.8, sample_rotation=0.0, global_rotation=0.0, left_edge=False, right_edge=False):\n        (image_sliced, extent, path, outline_curves) = ImageSlicer.regular_polygon_ring_arc(image, dpu, segments, sides_per_segment, inner_radius, outer_radius, sample_rotation, global_rotation, left_edge, right_edge)\n        image_sample = ImageSample(image_sliced, extent, path, outline_curves)\n        ImageSampleTransformer.rotational_repeat_additive(image_sample, 2 *)\n        image_sample = ImageSample(image_sliced, extent, path, outline_curves)\n        ImageSampleTransformer.rotational_repeat_additive(image_sample, 2 * segments, None,\n                                                          rotation_offset=-sample_rotation + global_rotation,\n                                                          use_flip=True,\n                                                          flip_angle=(2 * sample_rotation + np.pi / segments) / 2)\n        return image_sample",
    "def regular_polygon(n, radius=1.0, offset=(0.0, 0.0)):\n        theta = np.linspace(0, 2 * np.pi, n + 1)\n        rho = radius * np.ones(n + 1)\n        curve = CurveTransforms.polar_to_cartesian(np.vstack((theta, rho)))\n        curve = CurveTransforms.translate_single(curve, offset[0], offset[1], inplace=True)\n        return curve\n\n    def translate_single(curve, offset, scale, inplace=False):\n        curve = curve.copy()\n        curve.translate(offset[0], offset[1], scale[0], scale[1], inplace=).T)\n        CurveTransforms.translate_single(curve, offset[0], offset[1], inplace=True)\n        return curve",
    "def circular_placement(radius=0.5, repetitions: int = None, delta_angle: float = None, local_rotation_offset=0.0,\n                           global_rotation_offset=0.0, use_flip=False, flip_angle=0.0, reverse_rotation=False):\n        if repetitions is None and delta_angle is None:\n            repetitions = 1\n            angle = None\n        elif repetitions is None:\n            repetitions = np.trunc(2 * np.pi / delta_angle)\n            angle = None\n        elif delta_angle is None:\n            repetitions = np.maximum(1, repetitions)\n            angle = None\n        else:\n            repetitions = np.maximum(1, repetitions)\n            angle = delta_angle\n        if angle is None:\n            angle = 2 * np.pi / repetitions\n        if reverse_rotation:\n            angle = -angle\n        transforms = []\n        for i in range(repetitions):\n            if i % 2 == 0 or not use_flip:\n                trans_data = Affine2D().rotate(local_rotation_offset).translate(radius, 0).rotate(i * angle + global_rotation_offset)\n            else:\n                trans_data = Affine2D().rotate(-flip_angle).scale(1, -1).rotate(flip_angle + local_rotation_offset).translate(radius, 0).rotate(i * angle + global_rotation_offset)\n            transforms.append(trans_data)\n        return transforms\n\n    def rotate_transforms(self, transforms: List[Affine2D]):\n        transforms = [t.rotate(t.translate(t.scale(1, -1)).rotate(t.translate(t.scale(1, -1)).rotate(t.)\n            transforms.append(trans_data)\n        return transforms",
    "def diamond_figure(x_bounds=(0.0, 1.0), y_bounds=(0.0, 1.0), subdivisions=(3, 3), line_width=1.0, fill=False):\n        x_delta = np.abs(x_bounds[0] - x_bounds[1]) / subdivisions[0]\n        y_delta = np.abs(y_bounds[0] - y_bounds[1]) / subdivisions[1]\n        base_diamond = CurveGenerator.polyline([0, x_delta/2, x_delta, x_delta/2, 0], [y_delta/2, y_delta, y_delta/2, 0, y_delta/2])\n        diamonds = [base_diamond]\n        print(diamonds)\n        Transformer.translation_repeat_curves(diamonds, subdivisions, (x_delta, y_delta))\n        Transformer.translate_curves(diamonds, x_bounds[0], y_bounds[0])\n        figure = Figure()\n        for curve in diamonds:\n            figure.add_curve(curve, line_width)\n        if fill and line_width:\n            for curve in diamonds:\n                figure.add_curve(curve, line_width)\n        return figure\n\n    def diamond_figure_with_fill(x_bounds=(0.0, 1.0), y_bounds=(0.0, 1.0), subdivisions=(3, 3), line_width=1.0, fill=False):\n        x_delta = np.abs(x_)\n        figure.evaluate_bounds()\n        return figure",
    "def circular_placement(radius=0.5, repetitions: int = None, delta_angle: float = None, local_rotation_offset=0.0,\n                           global_rotation_offset=0.0, use_flip=False, flip_angle=0.0, reverse_rotation=False):\n        if repetitions is None and delta_angle is None:\n            repetitions = 1\n            angle = None\n        elif repetitions is None:\n            repetitions = np.trunc(2 * np.pi / delta_angle)\n            angle = None\n        elif delta_angle is None:\n            repetitions = np.maximum(1, repetitions)\n            angle = None\n        else:\n            repetitions = np.maximum(1, repetitions)\n            angle = delta_angle\n        if angle is None:\n            angle = 2 * np.pi / repetitions\n        if reverse_rotation:\n            angle = -angle\n        transforms = []\n        for i in range(repetitions):\n            if i % 2 == 0 or not use_flip:\n                trans_data = Affine2D().rotate(local_rotation_offset).translate(radius, 0).rotate(i * angle + global_rotation_offset)\n            else:\n                trans_data = Affine2D().rotate(-flip_angle).scale(1, -1).rotate(flip_angle + local_rotation_offset).translate(local_rotation_offset, 0).scale(1, 1)\n            transforms.append(trans_data)\n        return transforms\n\n    def rotate_transforms(self, transforms: List[Affine2D]):\n        transforms = np.array(transforms)\n        transforms = transforms.reshape(-1, 3)\n        transforms = np.concatenate(transforms, axis=0)).rotate(i * angle + global_rotation_offset)\n            transforms.append(trans_data)\n        return transforms",
    "def bleu_score(self, generated, expected):\n        generated_tokens = nltk.word_tokenize(generated)\n        expected_tokens = nltk.word_tokenize(expected)\n        sentence_bleu = nltk.translate.bleu_score.sentence_bleu\n        sentence_bleu = sentence_bleu(generated_tokens, expected_tokens)\n        return sentence_bleu([expected_tokens], generated_tokens)",
    "def merge_regions(mask, regions, similarities, region1_id, region2_id):\n    new_id = min(region1_id, region2_id)\n    region1_info = regions[region1_id]\n    region2_info = regions[region2_id]\n    for neighbour in region1_info['neighbors']:\n        if neighbour < region1_id:\n            del similarities[(neighbour, region1_id)]\n        else:\n            del similarities[(region1_id, neighbour)]\n    similarities[(region1_id, region2_id)] = 0\n    for neighbour in region2_info['neighbors']:\n        if neighbour < region2_id:\n            del similarities[(neighbour, region2_id)]\n        else:\n            del similarities[(region2_id, neighbour)]\n    new_mask = np.logical_or(region1_info['mask'], region2_info['mask'])\n    mask[new_mask] = new_id\n    new_region = {\n        'mask': new_mask,\n        'neighbors': region1_info['neighbors'].union(similarities[(region1_id, neighbour)])\n    }\n    new_region['neighbors'].discard(new_id)\n    new_region['neighbors'].discard(max(region1_id, region2_id))\n    for neighbour in new_region['neighbors']:\n        similarity = histogram_intersection(regions[neighbour]['color_histogram'], regions[new_id]['),\n        'color_histogram': merge_histograms(region1_info['color_histogram'],\n                                            region1_info['size'],\n                                            region2_info['color_histogram'],\n                                            region2_info['size']),\n        'size': region1_info['size'] + region2_info['size'],\n    }\n    new_region['neighbors'].discard(new_id)\n    new_region['neighbors'].discard(max(region1_id, region2_id))\n    for neighbour in new_region['neighbors']:\n        similarity = histogram_intersection(regions[neighbour]['color_histogram'], regions[new_id]['color_histogram'])\n        if neighbour < new_id:\n            similarities[(neighbour, new_id)] = similarity\n        else:\n            similarities[(new_id, neighbour)] = similarity\n    del regions[region1_id]\n    del regions[region2_id]\n    regions[new_id] = new_region\n    for neighbor in regions[new_id]['neighbors']:\n        regions[neighbor]['neighbors'].discard(max(region1_id, region2_id))\n        regions[neighbor]['neighbors'].add(new_id)",
    "def random_split_middle_examples(examples: List[Tuple[str, str, str]], min_left: int = 5, min_right: int = 5) -> List[Tuple[str, str, str]]:\n        \"\"\"Randomly split the middle section of examples with specific constraints.\"\"\"\n        new_examples = []\n        for example in examples:\n            prefix, middle, suffix = example\n            if len(middle) < min_left + min_right:\n                continue\n            while True:\n                split_idx = random.randint(min_left, min_left + (len(middle) - min_right - min_left) // 2 + 1)\n                if middle[split_idx - 1:split_idx + 1] != r'\\n':\n                    break\n            prefix += middle[:split_idx]\n            middle = middle[split_idx:]\n            new_examples.append(prefix)\n        return new_examples",
    "def sine_wave_ring_arc(image, dpu=1000.0, n_periods=2, period_offset=0.25, inner_radius=0.5, outer_radius=0.8,\n                           amplitude=0.1, theta1=0.0, theta2=np.pi/2):\n        inner_curve = CurveGenerator.sine_wave_circular_arc(100, inner_radius+amplitude, theta1, theta2, amplitude, n_periods, period_offset)\n        outer_curve = np.flip(CurveGenerator.sine_wave_circular_arc(100, outer_radius-amplitude, theta1, theta2, amplitude, n_periods, period_offset), 0)\n        outline_curves = [inner_curve, outer_curve]\n        curve = np.vstack(curve)\n        (image, extent, path) = ImageSlicer.sample_from_curve(image, curve, dpu)\n        return image, extent, path, outline_curves",
    "def random_edge_ring(image, dpu=1000.0, segments=8, grid_size=(5, 3), inner_radius=0.5, outer_radius=0.8, width=0.1,\n                         sample_rotation=0.0, global_rotation=0.0, left_edge=False, right_edge=False, interpolation=\"spline\"):\n        (image_sliced, extent, path, outline_curves) = ImageSlicer.random_ring_arc(image, dpu, segments, grid_size, inner_radius, outer_radius, width, sample_rotation, global_rotation, left_edge, right_edge, interpolation)\n        image_sample = ImageSample(image_sliced, extent, path, outline_curves)\n        ImageSampleTransformer.rotational_repeat_additive(image_sample, )\n        image_sample = ImageSample(image_sliced, extent, path, outline_curves)\n        ImageSampleTransformer.rotational_repeat_additive(image_sample, 2 * segments, None,\n                                                          rotation_offset=-sample_rotation+global_rotation, use_flip=True,\n                                                          flip_angle=(2 * sample_rotation + np.pi / segments) / 2)\n        return image_sample",
    "def serrated_ring_arc(image, dpu=1000.0, segments=3, aligned=True, teeth_width=0.05, inner_radius=0.0,\n                          outer_radius=1.0, theta1=0.0, theta2=np.pi / 6):\n        segments = np.maximum(1, segments)\n        theta = np.linspace(theta1, theta2, segments + 1)\n        inner_rho = np.array([inner_radius + (i % 2) * teeth_width for i in range(segments + 1)])\n        outer_rho = np.array([outer_radius - ((i + aligned) % 2) * teeth_width for i in range(segments + 1)])\n        curve1 = np.vstack((inner_rho, theta)).T\n        curve2 = np.vstack((outer_rho, np.flip(theta))).T\n        curve1 = CurveTransforms.polar_to_cartesian(curve1)\n        curve2 = CurveTransforms.polar_to_cartesian(curve2)\n        outline_curves = [curve1, curve2]\n        curve = np.vstack((curve1, curve2))\n        (image, extent, path) = ImageSlicer.sample_from_curve(curve, outline_curves, dpu=dpu)\n        image = ImageSlicer.rotate_image(image, theta, inner_rho, outer_rho)\n        image = ImageSlicer.rotate_image(image, theta, inner_rho, outer_rho, angle_in_degrees=True)\n        image = ImageSlicer.rotate_image()\n        return image, extent, path, outline_curves",
    "def pit_ring(image, dpu=1000.0, segments=8, pits_per_segment=1, inner_radius=0.5, outer_radius=0.8, width=0.8, depth=0.4, gap=0.2, sample_rotation=0.0,\n                   global_rotation=0.0, half=False, left_edge=False, right_edge=False) -> ImageSample:\n        outer_curve = (CurveGenerator.pit(100, width, gap, pits_per_segment), 1, outer_radius, depth, \"cartesian\")\n        inner_curve = (CurveTransforms.scale_single(CurveGenerator.pit(100, width, gap, pits_per_segment), 1, inner_radius, depth, \"cartesian\")\n        (image_sliced, extent, path, outline_curves) = ImageSlicer.custom_ring_arc(image, dpu, inner_curve, outer_curve, sample_rotation,\n                                                                                   sample_rotation + np), (1, -1)), 1, inner_radius, depth, \"cartesian\")\n        (image_sliced, extent, path, outline_curves) = ImageSlicer.custom_ring_arc(image, dpu, inner_curve, outer_curve, sample_rotation,\n                                                                                   sample_rotation + np.pi / segments, left_edge, right_edge)\n        image_sample = ImageSample(image_sliced, extent, path, outline_curves)\n        ImageSampleTransformer.rotational_repeat_additive(image_sample, 2 * segments, None,\n                                                          rotation_offset=-sample_rotation+global_rotation, use_flip=True,\n                                                          flip_angle=(2 * sample_rotation + np.pi / segments) / 2)\n        return image_sample",
    "def leaf_center(image, dpu=1000.0, segments=8, radius=0.4, height=0.2, sample_rotation=0.0, global_rotation=0.0, left_edge=True, right_edge=False, leaf_type=\"sharp\"):\n        if leaf_type == \"sharp\":\n            leaf = CurveGenerator.bezier(np.array([[-1, 0], [-1, 1], [0, 1], [0, 2]]))\n        else:\n            leaf = CurveGenerator.bezier(np.array([[-1, 0], [-1, 1], [0, 2]]))\n        (image_sliced, extent, path, outline_curves) = ImageSlicer.custom_ring_arc(image, dpu, None, (leaf, 1, radius, height, \"cartesian\"),\n                                                                                    sample_rotation, sample_rotation+np.pi/segments, left_edge, right_edge)\n        image_sample = ImageSample(image_sliced, extent, path, outline_curves)\n        image_sample.set_global_rotation(global_rotation)\n        image_sample.set_global_rotation_offset(global_rotation + np.pi / segments)\n        image_sample.set_global_rotation_offset_angle(global_rotation + np.pi / segments)\n        image)\n        ImageSampleTransformer.rotational_repeat_additive(image_sample, 2 * segments, None,\n                                                          rotation_offset=-sample_rotation + global_rotation, use_flip=True,\n                                                          flip_angle=(2 * sample_rotation + np.pi / segments) / 2)\n        return image_sample",
    "def find_function_calls_with_args(source_code):\n    tree = ast.parse(source_code)\n    visitor = FunctionCallVisitor(source_code)\n    visitor.visit(tree)\n    return visitor.function_calls\n\n\ndef find_function_calls_with_kwargs(source_code):\n    tree = ast.parse(source_code)\n    visitor = FunctionCallVisitor(source_code)\n    visitor.visit(tree)\n    return visitor.function_calls\n\n\ndef find_function_calls_with_return(source_code)\n    return visitor.function_calls",
    "def merge_regions(mask, regions, similarities, region1_id, region2_id):\n    new_id = min(region1_id, region2_id)\n    region1_info = regions[region1_id]\n    region2_info = regions[region2_id]\n    for neighbour in region1_info['neighbors']:\n        if neighbour < region1_id:\n            del similarities[(neighbour, region1_id)]\n        else:\n            del similarities[(region1_id, neighbour)]\n    similarities[(region1_id, region2_id)] = 0\n    for neighbour in region2_info['neighbors']:\n        if neighbour < region2_id:\n            del similarities[(neighbour, region2_id)]\n        else:\n            del similarities[(region2_id, neighbour)]\n    new_mask = np.logical_or(region1_info['mask'], region2_info['mask'])\n    mask[new_mask] = new_id\n    new_region = {\n        'mask': new_mask,\n        'neighbors': region1_info['neighbors'].union(region2_info['neighbors']),\n        'color_histogram': merge_histograms(region1_info['color_histogram'],\n                                            region1_info['size'],\n                                            region2_info['color_histogram'],\n                                            region2_info['size']),\n        'size': region1_info['size'] + region2_info['size'],\n    }\n    new_region['neighbors'].discard(new_id)\n    new_region['neighbors'].discard(new_id)\n    return new_region\n\n\ndef merge_histograms(histogram1, histogram2, size1, size2):\n    histogram1 = np.array(histogram1)\n    histogram2 = np.array(histogram2)\n    size1 = np.array(size1)\n    size2 = np.array(size2)\n    if histogram1.)\n    for neighbour in new_region['neighbors']:\n        similarity = histogram_intersection(regions[neighbour]['color_histogram'], regions[new_id]['color_histogram'])\n        if neighbour < new_id:\n            similarities[(neighbour, new_id)] = similarity\n        else:\n            similarities[(new_id, neighbour)] = similarity\n    del regions[region1_id]\n    del regions[region2_id]\n    regions[new_id] = new_region\n    for neighbor in regions[new_id]['neighbors']:\n        regions[neighbor]['neighbors'].discard(max(region1_id, region2_id))\n        regions[neighbor]['neighbors'].add(new_id)",
    "def min_swaps_to_transform(perm1, perm2):\n    n = len(perm1)\n    index_map = {value: i for i, value in enumerate(perm2)}\n    index_map = {value: index_map[value] for value in perm1}\n    return index_map\n\ndef min_swaps_to_transform_2(perm1, perm2):\n    n = len(perm1)\n    index_map = {value: i for i, value in enumerate(perm2)}\n    index_)}  \n    perm1_mapped = [index_map[value] for value in perm1]  \n    visited = [False] * n\n    swaps = 0\n    for i in range(n):\n        if visited[i] or perm1_mapped[i] == i:\n            continue\n        cycle_length = 0\n        j = i\n        while not visited[j]:\n            visited[j] = True\n            j = perm1_mapped[j]\n            cycle_length += 1\n        if cycle_length > 0:\n            swaps += cycle_length - 1  \n    return swaps",
    "def serrated_ring_arc(image, dpu=1000.0, segments=3, aligned=True, teeth_width=0.05, inner_radius=0.0,\n                          outer_radius=1.0, theta1=0.0, theta2=np.pi / 6):\n        segments = np.maximum(1, segments)\n        theta = np.linspace(theta1, theta2, segments + 1)\n        inner_rho = np.array([inner_radius + (i % 2) * teeth_width for i in range(segments + 1)])\n        outer_rho = np.array([outer_radius - ((i + aligned) % 2) * teeth_width for i in range(segments + 1)])\n        curve1 = np.vstack((inner_rho, theta)).T\n        curve2 = np.vstack((outer_rho, np.flip(theta))).T\n        curve1 = CurveTransforms.polar_to_cartesian(curve1)\n        curve2 = CurveTransforms.polar_to_cartesian(curve2)\n        outline_curves = [curve1, curve2]\n        curve = np.vstack(curve1)\n        outline_curves = [curve2]\n        outline_curves = [outline_curves[0]]\n        outline_curves = [outline_curves[1]]\n        outline_curves = [outline_curves[2]]\n        outline_curves = [outline_curves[3]]\n        outline_curves = [outline_)\n        (image, extent, path) = ImageSlicer.sample_from_curve(image, curve, dpu)\n        return image, extent, path, outline_curves",
    "def bert_score(self, generated, expected):\n        try:\n            P, R, F1 = bert_score([generated], [expected], lang='en', rescale_with_baseline=True)\n            return F1.item()\n        except Exception as e:\n            print(e)\n            return None",
    "def extract_datasets(\n        code_blocks: List[str],\n        max_values: List[int],\n        max_context_lines: List[int],\n        dataset_type: str,\n        extract_method: Callable[[str, Any, Any], List[Tuple[str, str, str]]]\n    ) -> List[Tuple[str, List[Tuple[str, str, str]]]]:\n        datasets = []\n        for max_value in max_values:\n            for max_context in max_context_lines:\n                dataset_name = f'{dataset_type}_{max_value}_{max_context}'\n                examples = []\n                for block in code_blocks:\n                    examples.extend(extract_method(block, max_value, max_context))\n                if examples:\n                    datasets.append((dataset_name, examples))\n                    random_split_name = f'random_split_{dataset_type}_{max_value}_{max_context}'\n                    examples_split = TextUtils.random_split_middle_examples(examples, min_left=5, min_right=5)\n                    if examples_split:\n                        datasets.append(datasets_split_to_datasets(examples_split, random_split_name))\n        return datasets\n\n\ndef datasets_split_to_datasets(examples: List[Tuple[str, List[Tuple[str, str, str]]]], random_split_name: str) -> List[Tuple[str, List[Tuple[str, str, str]]]]:\n   )\n        return datasets",
    "def leaf(values=np.linspace(0, 1, 100), width=0.1, height=0.2, half=False):\n        control_nodes = np.array([[0, 0], [0, 1], [-1, 1], [-1, 2], [0, 2], [0, 3]])\n        curve = CurveGenerator.bezier(values, control_nodes, width, height, half)\n        curve = CurveTransforms.fit_c2c(curve, (-width/2, 0, 0, height))\n        curve = CurveTransforms.fit_c2c(curve, (-width/2, 0, 0, height))\n        curve = CurveTransforms.fit_c2c()\n        curve = CurveTransforms.fit_c2c(curve, (-width/2, 0, 0, height))\n        if not half:\n            curve = np.vstack((curve, np.flip(CurveTransforms.scale_single(curve, (-1, 1), inplace=False), 0)))\n        return curve",
    "def interpolate(curve: np.ndarray, samples=100, kind=\"cubic\", inplace=True) -> np.ndarray:\n        spline = interp1d(np.linspace(0, 1, curve.shape[0]), curve.T, kind=kind)\n        t_fine = np.linspace(0, 1, samples)\n        x_fine, y_fine = spline(t_fine)\n        interpolated_curve = np.vstack(spline(t_fine).T\n        if inplace:\n            curve.resize((2, samples), refcheck=False)\n            curve[:] = interpolated_curve\n            return curve\n        else:\n            return interpolated_curve",
    "def sample_from_curve(image, curve, dpu=1000.0):\n        height = image.shape[0]\n        width = image.shape[1]\n        image_ar = width / height\n        x1 = np.min(curve[:, 0])\n        x2 = np.max(curve[:, 0])\n        y1 = np.min(curve[:, 1])\n        y2 = np.max(curve[:, 1])\n        extent = (x1, x2, y1, y2)\n        x_abs = x2 - x1\n        y_abs = y2 - y1\n        clip_ar = x_abs / y_abs\n        if clip_ar < image_ar:\n            new)\n        y2 = np.max(curve[:, 1])\n        extent = (x1, x2, y1, y2)\n        x_abs = x2 - x1\n        y_abs = y2 - y1\n        clip_ar = x_abs / y_abs\n        if clip_ar < image_ar:\n            new_height = np.minimum(int(np.minimum(height, y_abs*dpu)), height-1)\n            new_width = int(new_height * clip_ar)\n        else:\n            new_width = np.minimum(int(np.minimum(width, x_abs*dpu)), width-1)\n            new_height = int(new_width / clip_ar)\n        origin = (np.random.randint(0, width - new_width), np.random.randint(0, height - new_height))\n        sliced_image = image[origin[1]:origin[1] + new_height, origin[0]:origin[0] + new_width]\n        path = Path(curve)\n        return sliced_image, extent, path",
    "def custom_ring_arc(image, dpu=1000.0, inner_curve: (np.ndarray, int, float, float, str) = (np.array([[0.0, 0.0]]), 1, 0.5, 0.05, \"cartesian\"),\n                        outer_curve: (np.ndarray, int, float, str) = (np.array([[0.0, 0.0]]), 1, 0.8, 0.05, \"cartesian\"), theta1=0.0, theta2=np.pi/6,\n                        left_side=False, right_side=False) -> (np.ndarray, (float, float, float, float), Path, List[np.ndarray]):\n        if inner_curve is None:\n            curve1 = np.array([[0, 0]])\n        else:\n            (curve1, periods1, radius1, width1, coordinate_type1) = inner_curve\n            if coordinate_type1 == \"polar\":\n                curve1 = CurveTransforms.tight_remap_polar_to_polar(curve1, (radius1, radius1+width1), (theta1, theta1 + (theta2-theta1)/periods1))\n                curve1 = CurveTransforms.polar_to_cartesian(curve1)\n            else:\n                curve1 = np.vstack((-curve1[:, 0], curve1[:, 1])).T\n                curve1 = CurveTransforms.tight_map_cartesian_to_polar(curve1, (radius1, radius1+width1), (theta1, theta1 + (theta2-theta1)/periods1))\n            curve1 = CurveTransforms.polar_to_cartesian(curve1)\n            curve1 = np.vstack([CurveTransforms.rotate_single(curve1, i*(theta2-theta1)/periods1, inplace=False) for i in range(0, periods1)])\n            (curve2, periods2, radius2, width2, coordinate_type2) = outer_curve\n            if coordinate_type2 == \"polar\":\n                curve2 = CurveTransforms.tight_remap_polar_to_polar() for i in range(0, periods1)])\n        (curve2, periods2, radius2, width2, coordinate_type2) = outer_curve\n        if coordinate_type2 == \"polar\":\n            curve2 = CurveTransforms.tight_remap_polar_to_polar(curve2, (radius2 - width2, radius2), (theta1, theta1 + (theta2-theta1)/periods2))\n            curve2 = CurveTransforms.polar_to_cartesian(curve2)\n        else:\n            curve2 = np.vstack((-curve2[:, 0], curve2[:, 1])).T\n            curve2 = CurveTransforms.tight_map_cartesian_to_polar(curve2, (radius2 - width2, radius2), (theta1, theta1 + (theta2-theta1)/periods2))\n        curve2 = CurveTransforms.polar_to_cartesian(curve2)\n        curve2 = np.flip(np.vstack([CurveTransforms.rotate_single(curve2, i*(theta2-theta1)/periods2, inplace=False) for i in range(0, periods2)]), 0)\n        if left_side and right_side:\n            outline_curves = [np.vstack((curve1, curve2, np.array([[curve1[0, 0], curve1[0, 1]]])))]\n        elif right_side:\n            outline_curves = [np.vstack((curve1, curve2))]\n        elif left_side:\n            outline_curves = [np.vstack((curve2, curve1))]\n        else:\n            outline_curves = [curve1, curve2]\n        curve = np.vstack((curve1, curve2))\n        (image, extent, path) = ImageSlicer.sample_from_curve(image, curve, dpu)\n        return image, extent, path, outline_curves",
    "def custom_ring_arc(image, dpu=1000.0, inner_curve: (np.ndarray, int, float, float, str) = (np.array([[0.0, 0.0]]), 1, 0.5, 0.05, \"cartesian\"),\n                        outer_curve: (np.ndarray, int, float, str) = (np.array([[0.0, 0.0]]), 1, 0.8, 0.05, \"cartesian\"), theta1=0.0, theta2=np.pi/6,\n                        left_side=False, right_side=False) -> (np.ndarray, (float, float, float, float), Path, List[np.ndarray]):\n        if inner_curve is None:\n            curve1 = np.array([[0, 0]])\n        else:\n            (curve1, periods1, radius1, width1, coordinate_type1) = inner_curve\n            if coordinate_type1 == \"polar\":\n                curve1 = CurveTransforms.tight_remap_polar_to_polar(curve1, (radius1, radius1+width1), (theta1, theta1 + (theta2-theta1)/periods1))\n                curve1 = CurveTransforms.polar_to_cartesian(curve1)\n            else:\n                curve1 = np.vstack((-curve1[:, 0], curve1[:, 1])).T\n                curve1 = CurveTransforms.tight_map_cartesian_to_polar(curve1, (radius1, radius1+width1), (theta1, theta1 + (theta2-theta1)/periods1))\n            curve1 = CurveTransforms.polar_to_cartesian(curve1)\n            curve1 = np.vstack([CurveTransforms.rotate_single(curve1, i * (theta2 - theta1) / periods1, inplace=False) for i in range(0, periods1)])\n        (curve2, periods2, radius2, width2, coordinate_type2) = outer_curve\n        if coordinate_type2 == \"polar\":\n            curve2 = CurveTransforms.tight_remap_polar_to_polar(curve2, (radius2 - width2, radius2), (theta1, theta1 + (theta2-theta1)/periods2))\n            curve2 = CurveTransforms.polar_to_cartesian(curve2)\n        else:\n            curve2 = np.vstack((-curve2[:, 0], curve2[:, 1])).T\n            curve2 = CurveTransforms.tight_map_cartesian_to_polar(curve2, (radius2 - width2, radius2), (theta1, theta1 + (theta2-theta1)/periods2))\n        curve2 = CurveTransforms.polar_to_cartesian(curve2)\n        curve2 = np.flip(curve2, 0)\n        return curve1, curve2, radius1, radius2, width1, width2, coordinate_type1, coordinate_type2\n\n    def sample_from_curve(image, curve, dpu=1000.0) -> (np.ndarray, (float, float, float, float), Path, List[np.)\n        if left_side and right_side:\n            outline_curves = [np.vstack((curve1, curve2, np.array([[curve1[0, 0], curve1[0, 1]]])))]\n        elif right_side:\n            outline_curves = [np.vstack((curve1, curve2))]\n        elif left_side:\n            outline_curves = [np.vstack((curve2, curve1))]\n        else:\n            outline_curves = [curve1, curve2]\n        curve = np.vstack((curve1, curve2))\n        (image, extent, path) = ImageSlicer.sample_from_curve(image, curve, dpu)\n        return image, extent, path, outline_curves",
    "def visit_Call(self, node):\n        func_name = None\n        if isinstance(node.func, ast.Name):\n            func_name = node.func.id\n        elif isinstance(node.func, ast.Attribute):\n            parts = []\n            current = node.func\n            while isinstance(current, ast.Attribute):\n                parts.insert(0, current.attr)\n                current = current.value\n            if isinstance(current, ast.Name):\n                parts.insert(current.id, current.attr)\n            func_name = \".\".join(parts)\n            func_name = \".\".join(parts)\n        args = [ast.get_source_segment(self.source_code, arg) for arg in node.args]\n        if func_name:\n            self.function_calls.append({\n                \"function\": func_name,\n                \"arguments\": args,\n                \"start_line\": node.lineno,\n                \"end_line\": node.end_lineno,\n                \"col_offset\": node.col_offset,\n                \"end_col_offset\": node.end_col_offset\n            })\n        self.generic_visit(node)",
    "def regular_polygon(n, radius=1.0, offset=(0.0, 0.0)):\n        theta = np.linspace(0, 2 * np.pi, n + 1)\n        rho = radius * np.ones(n)\n        rho[n] = 0.0\n        rho[0] = offset[0]\n        rho[-1] = offset[1]\n        return np.vstack((rho, theta)).T\n\n    def polar_to_cartesian(theta):\n        rho = np.zeros(n)\n        curve = CurveTransforms.polar_to_cartesian(np.vstack((rho, theta)).T)\n        CurveTransforms.translate_single(curve, offset[0], offset[1], inplace=True)\n        return curve",
    "def neighbouring_regions(segments_mask, region_mask):\n    mask = region_mask.astype(np.uint8)\n    segments_mask = segments_mask.astype(np.uint8)\n    segments_mask = np.logical_and(segments_mask, mask)\n    segments_mask = np.logical_and(segments_mask, mask)\n    segments_mask = np.logical_and(segments_mask, mask)\n    segments_mask = np)\n    kernel = np.array([[0, 1, 0], [1, 1, 1], [0, 1, 0]], dtype=np.uint8)\n    mask_dilated = cv2.dilate(mask, kernel, iterations=1)\n    return np.unique(segments_mask[(mask_dilated - mask) == 1])",
    "def colorize_segments(segments):\n    num_segments = np.max(segments) + 1\n    colors = np.random.randint(0, 255, size=(num_segments, 3), dtype=np.uint8)\n    color_image = np.zeros((segments.shape[0], segments.shape[1], 3), dtype=np.uint8)\n    for i in range(num_segments):\n        color_image[segments == i] = colors[i]\n    return color_image\n\n\ndef colorize_segments_with_color(segments, color_image):\n    num_segments = np.max(segments) + 1\n    colors = np.random.randint(0, 255, size=(num_segments, ):\n        color_image[segments == i] = colors[i]\n    return color_image",
    "def extract_function_arguments(block: str, max_arguments: int = 5, min_context_lines: int = 1, max_context_lines: int = -1) -> List[Tuple[str, str, str]]:\n        \"\"\"Extract function arguments with specified context and argument count limitations.\"\"\"\n        function_calls = find_function_calls_with_args(block, max_arguments, min_context_lines, max_context_lines)\n        if function_calls:\n            return function_calls\n        else:\n            return []\n\n    def extract_function_call_details(block: str, call: dict) -> Tuple[str, str, str]:\n        \"\"\"Extract function call details with specified context and argument count limitations.\"\"\"\n        function)\n        lines = block.splitlines()\n        num_lines = len(lines)\n        examples = []\n        for call in function_calls:\n            if len(call['arguments']) > max_arguments > 0:\n                continue\n            if call['start_line'] - 1 < min_context_lines or num_lines - call['end_line'] < min_context_lines:\n                continue\n            prefix, middle, suffix = TextUtils.extract_function_call_details(lines, call)\n            if not middle:\n                continue\n            start = max(0, call['start_line'] - 1 - (max_context_lines if max_context_lines >= 0 else call['start_line'] - 1))\n            end = min(num_lines, call['end_line'] + (max_context_lines if max_context_lines >= 0 else num_lines))\n            prefix = '\\n'.join(lines[start:call['start_line'] - 1] + [prefix])\n            suffix = '\\n'.join([suffix] + lines[call['end_line']:end])\n            examples.append((prefix, middle, suffix))\n        return examples",
    "def ring_type1(image, dpu=1000.0, segments=8, inner_radius=0.5, outer_radius=0.8, edge_width=0.05, sample_rotation=0.0,\n                   global_rotation=0.0, half=False, left_edge=False, right_edge=False) -> ImageSample:\n        inner_curve = (CurveGenerator.edge_type1(half=half), 1, inner_radius, edge_width, \"cartesian\")\n        outer_curve = (CurveGenerator.edge_type1(half=half), 1, outer_radius, edge_width, \"cartesian\")\n        (image_sliced, extent, path, outline_curves) = ImageSlicer.custom_ring_arc(image, dpu, inner_curve, outer_curve, sample_rotation,\n                                                                                   sample_rotation + np.pi / segments, left_edge, right_edge)\n        image_sample = ImageSample(image_sliced, extent, path, outline_curves)\n        return image_sample\n\n    def ring_type2(image, dpu=1000.0, segments=8, inner_radius=0.5, outer_radius=0.8, edge_width=0.05, sample_rotation=0.0,\n                   global_rotation)\n        ImageSampleTransformer.rotational_repeat_additive(image_sample, 2 * segments, None,\n                                                          rotation_offset=-sample_rotation+global_rotation, use_flip=True,\n                                                          flip_angle=(2 * sample_rotation + np.pi / segments) / 2)\n        return image_sample",
    "def rotate_multi(curves: List[np.ndarray], angle=0.0, pivot=(0.0, 0.0), inplace=True) -> List[np.ndarray]:\n        transform = Affine2D().translate(-pivot[0], -pivot[1]).rotate(angle).translate(pivot[0], pivot[1]).rotate(angle).translate(pivot[0], pivot[1])\n        if inplace:\n            return CurveTransforms.apply_affine_multi(curves, transform, inplace)\n        return CurveTransforms.apply_affine_multi(curves, transform, inplace)\n\n    def rotate_multi_with_offset(curves: List[np)\n        return CurveTransforms.apply_affine_multi(curves, transform, inplace)",
    "def sample_from_curve(image, curve, dpu=1000.0):\n        height = image.shape[0]\n        width = image.shape[1]\n        image_ar = width / height\n        x1 = np.min(curve[:, 0])\n        x2 = np.max(curve[:, 0])\n        y1 = np.min(curve[:, 1])\n        y2 = np.max(curve[:, 1])\n        extent = (x1, x2, y1, y2)\n        x_abs = x2 - x1\n        y_abs = y2 - y1\n        clip_ar = x_abs / y_abs\n        if clip_ar < image_ar:\n            new_height = np.minimum(int(np.minimum(height, y_abs*dpu)), height-1)\n            new_width = int(np.minimum(width, x_abs*dpu))\n            new_image = image[origin[1]:origin[1] + new_height, origin[0]:origin[0] + new_width]\n            return new_image, extent, path\n        else:\n            new_height = np.minimum(int(np.minimum(height, x_abs)\n        else:\n            new_width = np.minimum(int(np.minimum(width, x_abs*dpu)), width-1)\n            new_height = int(new_width / clip_ar)\n        origin = (np.random.randint(0, width - new_width), np.random.randint(0, height - new_height))\n        sliced_image = image[origin[1]:origin[1] + new_height, origin[0]:origin[0] + new_width]\n        path = Path(curve)\n        return sliced_image, extent, path",
    "def translate_curves(curves: \"list\", x=0.0, y=0.0):\n        for i in range(1, len(curves)):\n            curves[i][0, :] += x\n            curves[i][1, :] += y",
    "def sample_from_curve(image, curve, dpu=1000.0):\n        height = image.shape[0]\n        width = image.shape[1]\n        image_ar = width / height\n        x1 = np.min(curve[:, 0])\n        x2 = np.max(curve[:, 0])\n        y1 = np.min(curve[:, 1])\n        y2 = np.max(curve[:, 1])\n        extent = (x1, x2, y1, y2)\n        x_abs = x2 - x1\n        y_abs = y2 - y1\n        clip_ar = x_abs / y_abs\n        if clip_ar < image_ar:\n            new_height = np.minimum(x_abs, image_ar)\n            new_width = int(new_height * clip_ar)\n        else:\n            new_width = np.minimum(int(np.minimum(width, x_abs*dpu)), width-1)\n            new_height = int(new_width / clip_ar)\n        origin = (np.random.randint)\n            new_width = int(new_height * clip_ar)\n        else:\n            new_width = np.minimum(int(np.minimum(width, x_abs*dpu)), width-1)\n            new_height = int(new_width / clip_ar)\n        origin = (np.random.randint(0, width - new_width), np.random.randint(0, height - new_height))\n        sliced_image = image[origin[1]:origin[1] + new_height, origin[0]:origin[0] + new_width]\n        path = Path(curve)\n        return sliced_image, extent, path",
    "def add_curve(self, curve, plot_type, bounds=None, evaluate_bounds=False):\n        self.Curves.append(curve)\n        self.PlotType.append(plot_type)\n        if bounds:\n            self.update_curve_bounds(curve, bounds)\n        if evaluate_bounds:\n            self.update_curve_bounds(self.evaluate_curve_bounds(curve))\n\n    def update_curve_bounds(self, curve, bounds):\n        if bounds:\n            self.Curves[0].update_bounds(curve, bounds)\n        else:\n            self.Curves[0].update_bounds()\n        elif evaluate_bounds:\n            self.update_curve_bounds(self.evaluate_curve_bounds(curve))"
]