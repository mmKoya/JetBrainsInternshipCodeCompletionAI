[
    "1",
    "control_points",
    "[node.target]",
    "Affine2D().rotate(angle)",
    "AssignmentVisitor()",
    "(theta2 - theta1)/n_periods",
    "CurveTransforms.polar_to_cartesian(np.vstack((rho, theta)).T)",
    "{}",
    "ImageSlicer.leaf(image, dpu, width, outer_radius-inner_radius, True)",
    "1",
    "delta_angle",
    "np.min(curve[:, 1])",
    "CurveTransforms.polar_to_cartesian(curve2)",
    "[base_diamond]",
    "len(lines)",
    "True",
    "ImageSlicer.serrated_ring_arc(image, dpu, teeth_per_segment, aligned,\n                                                                                     teeth_width, inner_radius, outer_radius, sample_rotation, sample_rotation + np.pi / segments)",
    "np.array([inner_radius + (i % 2) * teeth_width for i in range(segments + 1)])",
    "self.chrf_score(generated, expected)",
    "None",
    "node.end_lineno",
    "[]",
    "match.group(0)",
    "[curve1, curve2]",
    "ast.get_source_segment(self.code, node)",
    "[curve]",
    "Affine2D().rotate(-mirror_angle).scale(1, -1).rotate(mirror_angle)",
    "0",
    "region_mask.astype(np.uint8)",
    "delta_angle",
    "ImageSlicer.custom_ring_arc(image, dpu, inner_curve, outer_curve, sample_rotation,\n                                                                                   sample_rotation + np.pi / segments, left_edge, right_edge)",
    "find_conditions(block)",
    "figure",
    "ImageSlicer.leaf(image, dpu, leaf_width, leaf_height, False)",
    "np.ones(100) * radius",
    "np.vstack((-curve1[:, 0], curve1[:, 1])).T",
    "CurveTransforms.polar_to_cartesian(curve1)",
    "CurveTransforms.polar_to_cartesian(control_points)",
    "ImageSample.outline_colors[ImageSample.current_outline]",
    "polar_curve[:, 0] * np.cos(polar_curve[:, 1])",
    "{value: i for i, value in enumerate(perm2)}",
    "1",
    "np.vstack((inner_curve, outer_curve))",
    "[curve1, curve2]",
    "Affine2D().translate(-pivot[0], -pivot[1]).rotate(angle).translate(pivot[0], pivot[1])",
    "CurveTransforms.polar_to_cartesian(curve)",
    "[line for line in lines if line.strip()]",
    "np.max(segments) + 1",
    "interpolated_curve",
    "np.asfortranarray(nodes)"
]