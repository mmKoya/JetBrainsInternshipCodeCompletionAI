[
    "ints=np.linspace(0.0, 1.0, 100), degree=10):\n        control_points = np.asfortranarray(control_points)\n        bezier_curve = bezier.Curve(control_points.T, degree=control_points.shape[0] - 1)\n        return bezier_curve.evaluate_multi(values).T\n    @staticmethod\n    def math_function(function, values, input_coordinate=\"x_input\", polar=False):\n        if input_coordinate == \"x_input\":\n            x_values = values\n            y_values = np.array([function(x) for x in x_values])\n            curve = np.vstack((x_values, y_values)).T\n        elif input_coordinate == \"y_input\":\n            y",
    "debug_colors:\n            for transform in self.AdditiveTransforms:",
    "n = -1) -> List[Tuple[str, str, str]]:\n        \"\"\"Extract section with specified context and argument count limitations.\"\"\"\n        examples = []\n        for line in lines:\n            if len(line) > max_characters:\n                continue\n            if line[0] == '#':\n                continue\n            if line[0] == '(':\n                continue\n            if line[0] == ')':\n                continue\n            if line[0] == '[':\n                continue\n            if line[0] == ']':\n                continue\n            if line[0] == '{':\n                continue\n            if line[0] == '}':\n                continue\n            if line[0] == '[':\n                continue\n            if line[0] == ']':\n                continue\n            if line[0] == '}':\n                continue\n            if line[0] == '[':\n                continue\n            if line[0",
    "ne_thickness, debug_colors):\n        for transform in self.PersistentTransforms:\n            self.plot_persistent(ax, transform, z_order, outline_thickness, debug_colors)\n            z_order += 0.001\n        ImageSample.current_outline = (ImageSample.current_outline+1) % 20\n    def plot_persistent_with_additional_curves(self, ax: \"Axes\", transform, additional_curves, z_order, outline_thickness, debug_colors):\n        for additional_curve in additional_curves:\n            self.plot_persistent(ax, transform, z_order, outline_thickness, debug_colors)\n            z_order += 0.001\n        ImageSample.current_outline = (ImageSample.current_outline+1) % ",
    "[i] == \"line\":\n                ax.plot(self.Curves[i][:, 0], self.Curves[i][:, 1], color=\"w\", zorder=self.z_order)\n                ax.plot(self.Curves[i][:, 0], self.Curves[i][:, 1], color=\"k\", solid_capstyle='round',\n                         linewidth=self.PlotType[i], zorder=self.z_order)\n            elif self.PlotType[i] == \"scatter\":\n                ax.scatter(self.Curves[i][:, 0], self.Curves[i][:, 1], color=\"w\", zorder=self.z_order)\n                ax.plot(self.Curves[i][:, 0], self.Curves",
    "polar_to_polar(curve2, (radius2, radius2+width2), (theta1, theta1 + (theta2-theta1)/periods2))\n            curve2 = CurveTransforms.polar_to_cartesian(curve2)\n        else:\n            curve2 = np.vstack((-curve2[:, 0], curve2[:, 1])).T\n            curve2 = CurveTransforms.tight_map_cartesian_to_polar(curve2, (radius2 - width2, radius2), (theta1, theta1 + (theta2-theta1)/periods2))\n        curve2 = CurveTransforms.polar_to_cartesian(curve2)\n        curve2 = np.flip(np.vstack([CurveTransforms.rotate_single(curve2, i*(theta2-theta1)/periods2,",
    "nter_right - min_left))\n                if split_idx == 0:\n                    break\n                if split_idx == len(examples) - 1:\n                    break\n                prefix, middle, suffix = examples[split_idx]\n                if len(middle) < min_left + min_right:\n                    continue\n                while True:\n                    split_idx = random.randint(min_left, min_left + (min_right - min_left))\n                    if split_idx == 0:\n                        break\n                    if split_idx == len(examples) - 1:\n                        break\n                    prefix, middle, suffix = examples[split_idx]\n                    if len(middle) < min_left + min_right:\n                        continue\n                    while True:\n                        split_idx = random.randint(min_left, min_left + (min_",
    "CurveTransforms.apply_affine_single(curves[0], CurveTransforms.apply_affine_multi(curves[1], CurveTransforms.apply_affine_single(curves[2], CurveTransforms.apply_affine_multi(curves[3], CurveTransforms.apply_affine_single(curves[4], CurveTransforms.apply_affine_multi(curves[5], CurveTransforms.apply_affine_single(curves[6], CurveTransforms.apply_affine_multi(curves[7], CurveTransforms.apply_affine_single(curves[8], CurveTransforms.apply_affine_multi(curves[9], CurveTransforms.apply_affine_single(curves[10], CurveTransforms.apply_affine_multi(curves[11], CurveTransforms.apply_affine_",
    "ode.func.value\n            if isinstance(current, ast.Name):\n                parts.insert(0, current.id)\n            func_name = \".\".join(parts)\n        args = [ast.get_source_segment(self.source_code, arg) for arg in node.args]\n        if func_name:\n            self.function_calls.append({\n                \"function\": func_name,\n                \"arguments\": args,\n                \"start_line\": node.lineno,\n                \"end_line\": node.end_lineno,\n                \"col_offset\": node.col_offset,\n                \"end_col_offset\": node.end_col_offset\n            })\n        self.generic_visit(node)\n    def visit_Name(self, node):\n        parts = []\n        current = node.id\n        if isinstance(",
    "   image_sample = ImageSample(image_sliced, extent, path, outline_curves)\n        ImageSampleTransformer.rotational_repeat_additive(image_sample, 2 * segments, None,\n                                                          rotation_offset=-sample_rotation+global_rotation, use_flip=True,\n                                                          flip_angle=(2 * sample_rotation + np.pi / segments) / 2)\n        return image_sample\n    @staticmethod\n    def test_sine_wave_ring(image, dpu=1000.0, segments=8, periods_per_segment=3, period_offset=0.25, inner_radius=0.5, outer_radius=0.8, width=0.05, sample_rotation=0.0) -> ImageSample:\n        inner_curve =",
    "_(self, z_order=0):\n        self.z_order = z_order\n        self.Curves = []\n        self.PlotType = []\n        self.Images = []\n    def __iadd__(self, curve):\n        self.Curves.append(curve)\n        self.PlotType.append(\"clear\")\n        if self.X_bounds is None:\n            self.X_bounds = curve[0, :]\n            self.Y_bounds = curve[1, :]\n            self.Rho_bounds = curve[2, :]\n            self.Theta_bounds = curve[3, :]\n        else:\n            self.X_bounds = (np.minimum(self.X_bounds[0], curve[0][0]),\n                             np.maximum(self.X_bounds[1], curve[0][1]))\n           ",
    "gth=0.0, flip=False):\n        if flip:\n            height = -height\n        polygon = np.array([[0, 0], [0.1*radius, height], [0.2*radius, 0]])\n        curve = CurveGenerator.bezier(polygon, np.linspace(0, 1 - 0.5 * half, 100))\n        if half:\n            return CurveTransforms.merge_curves([polygon, curve])\n        return CurveTransforms.merge_curves([polygon, curve, polygon])\n    @staticmethod\n    def merge_curves(curves):\n        curve = CurveTransforms.interpolate(curves, 100, \"cubic\", False)\n        curve = CurveTransforms.fit_c2c(curve, (-width/2, 0, 0, height))",
    "ed, expected)\n        results['meteor'] = self.meteor_score(generated, expected)\n        results['syntax_valid'] = self.syntax_validity(generated)\n        if check_syntax:",
    "     code_blocks,\n            num_lines,\n            max_context_lines,\n            'lines',\n            lambda block, num_l, max_pf: CodeSegmentExtractor.extract_line_sections(block, num_lines=num_l, max_context_lines=max_pf),\n        )\n    @staticmethod\n    def extract_conditions_assignments_datasets(code_blocks: List[str], max_characters: List[int], max_context_lines: List[int]) -> List[Tuple[str, List[Tuple[str, str, str]]]]:\n        return DatasetBuilder.extract_datasets(\n            code_blocks,\n            max_characters,\n            max_context_lines,\n            'conditions_assignments',\n            lambda block, max_c, max_pf: CodeSegmentExtractor.extract_condition_assignments(block",
    "range(repetitions):\n            if i % 2 == 0 or not use_flip:\n                trans_data = Affine2D().rotate(rotation_offset).translate(radius, 0).rotate(i * angle + rotation_offset)\n            else:\n                trans_data = Affine2D().rotate(-flip_angle).scale(1, -1).rotate(flip_angle + rotation_offset).translate(radius, 0).rotate(i * angle + rotation_offset)\n            transforms.append(trans_data)\n        return transforms\n\n    @staticmethod\n    def rotation_shift(radius=0.5, repetitions: int = None, delta_angle: float = None, local_rotation_offset=0.0, global_rotation_offset=0.0, use_flip=False, flip_",
    "ds[1]-old_y_bounds[0]))\n        return CurveTransforms.apply_affine_single(curve, transform, inplace)\n    @staticmethod\n    def remap_c2c_multi(curves: List[np.ndarray], old_x_bounds, old_y_bounds, new_x_bounds, new_y_bounds):\n        transform = Affine2D().translate(-old_x_bounds[0], -old_y_bounds[0])\n        transform = transform.scale((new_x_bounds[1]-new_x_bounds[0])/(old_x_bounds[1]-old_x_bounds[0]),\n                                    (new_y_bounds[1]-new_y_bounds[0])/(old_y_bounds[1]-old_y_bounds[0]))",
    "self, bounds):\n        if bounds:\n            if self.X_bounds is None:\n                self.X_bounds = bounds[0]\n                self.Y_bounds = bounds[1]\n                self.Rho_bounds = bounds[2]\n                self.Theta_bounds = bounds[3]\n            elif self.Y_bounds is None:\n                self.X_bounds = bounds[0]\n                self.Y_bounds = bounds[1]\n                self.Rho_bounds = bounds[2]\n                self.Theta_bounds = bounds[3]\n            elif self.Rho_bounds is None:\n                self.X_bounds = bounds[0]\n                self.Y_bounds = bounds[1]\n                self.Rho_bounds = bounds[2]\n                self.Theta_bounds = bounds[3]\n            elif self",
    "0, sides+1)))\n        outline_curves = [curve]\n        (image, extent, path) = ImageSlicer.sample_from_curve(image, curve, dpu)\n        return image, extent, path, outline_curves\n    @staticmethod\n    def circular_arc(image, dpu=1000.0, inner_radius=0.0, outer_radius=1.0, theta1=0.0, theta2=np.pi / 6) -> (np.ndarray, (float, float, float, float), Path, List[np.ndarray]):\n        curve = CurveGenerator.circular_arc(100, inner_radius, theta1, theta2)\n        outline_curves = [curve]\n        (image, extent, path) = ImageSlicer.sample",
    "onvert_start in range(min_context_lines, num_lines - min_context_lines - max_arguments):\n            c = c_start\n            c_end = c_start + max_arguments\n            indentation, middle_text = TextUtils.split_indentation('\\n'.join(lines[c:c_end]))\n            prefix = '\\n'.join(lines[c:c_start]) + '\\n' + indentation\n            suffix = '\\n' + '\\n'.join(lines[c_end:c_end])\n            examples.append((prefix, middle_text, suffix))\n        return examples\n    @staticmethod\n    def extract_function_call_details(lines: List[str], call: dict) -> Tuple[int, int, str]:\n        \"\"\"Extract function call details with specified context and argument count limitations.\"\"\"",
    " rotate_figure_with_curves(figure: \"Figure\", angle=0):\n        Transformer.rotate_curves(figure.Curves, angle)\n        figure.evaluate_bounds()\n        return figure\n    @staticmethod\n    def scale_curves(curves: \"list\", scale=1.0):\n        Transformer.scale_curves(curves, scale)\n        curves.clear()\n        curves.append(curves)\n    @staticmethod\n    def scale_figure(figure: \"Figure\", scale=1.0):\n        Transformer.scale_curves(figure.Curves, scale)\n        figure.evaluate_bounds()\n    @staticmethod\n    def scale_figure_with_curves(figure: \"Figure\", scale=1.0):\n        Transformer.scale_curves(figure.Curves, scale)\n        figure.evaluate",
    "lgebraicTransform()\n        for curve in curves:\n            transform.rotate_curves(curve)\n        return transform\n    @staticmethod\n    def translate_curves(curves: \"list\", x=0.0, y=0.0):\n        for i in range(len(curves)):\n            curves[i][0, :] += x\n            curves[i][1, :] += y\n    @staticmethod\n    def translation_repeat_curves(curves: \"list\", repetitions=(2, 2), step=(0.1, 0.1), scale=1.0):\n        x_repetitions = np.maximum(repetitions[0], 1)\n        y_repetitions = np.maximum(repetitions[1], 1)\n        base_curves = copy.deepcopy(cur",
    " List[str],\n        max_lines: List[int],\n        max_conditions: List[int],\n        max_assignments: List[int],\n        max_arguments: List[int],\n        max_lines_assignments: List[int],\n        max_conditions_assignments: List[int],\n        max_assignments_assignments: List[int],\n        max_arguments_assignments: List[int],\n        max_lines_assignments_assignments: List[int],\n        max_conditions_assignments_assignments: List[int],\n        max_assignments_assignments_assignments: List[int],\n        max_arguments_assignments_assignments: List[int],\n        max_lines_assignments_assignments_assignments: List[int],\n        max_conditions_assignments_assignments_assignments: List[int],\n        max_assignments_assignments_assignments_assignments:",
    "en >= 0 else num_lines))\n        prefix = '\\n'.join(lines[start:start_line] + [lines[start_line][:start_idx]] + lines[start_line + 1:])\n        suffix = '\\n' + '\\n'.join(lines[end:end_line] + [lines[end_line][:end_idx]] + lines[end_line + 1:])\n        examples.append((prefix, middle_text, suffix))\n        return middle_text, middle_text, suffix\n    @staticmethod\n    def extract_assignment(block: str, max_characters: int = 100, min_context_lines: int = 1, max_context_lines: int = -1) -> Tuple[str, str, str]:\n        \"\"\"Extract assignment with character limit and surrounding",
    "nt = None, delta_angle: float = None, local_rotation_offset=0.0,\n                           global_rotation_offset=0.0, use_flip=False, flip_angle=0.0, reverse_rotation=False):\n        if repetitions is None and delta_angle is None:\n            repetitions = 1\n            angle = None\n        elif repetitions is None:\n            repetitions = np.trunc(2 * np.pi / delta_angle)\n            angle = None\n        elif delta_angle is None:\n            repetitions = np.maximum(1, repetitions)\n            angle = None\n        else:\n            repetitions = np.maximum(1, repetitions)\n            angle = delta_angle\n        if angle is None:\n            angle = 2 * np.pi / repetitions\n        if reverse_rotation:\n           ",
    "aluate_bounds())\n        else:\n            self.update_curve_bounds(self.evaluate_bounds())\n    def append_figure(self, figure):\n        self.Images.append(figure)",
    "        curve = CurveGenerator.bezier(gap1, gap2)\n        curve = CurveTransforms.fit_c2c(curve, (-width/2, 0, 0, height))\n        curve = CurveTransforms.fit_c2c(curve, (-width/2, 0, 0, height))\n        curve = CurveTransforms.fit_c2c(curve, (-width/2, 0, 0, height))\n        curve = CurveTransforms.fit_c2c(curve, (-width/2, 0, 0, height))\n        curve = CurveTransforms.fit_c2c(curve, (-width/2, 0, 0, height))\n        curve = CurveTransforms.fit_c2c(curve, (-width/2, 0, 0, height))\n       ",
    "\n        for i in range(len(curve)):\n            curve[i][0, :] = curve[i][0, :] + curve[i][1, :]\n    @staticmethod\n    def interpolate_curve(curve, samples=100, kind=\"cubic\"):\n        spline = interp1d(np.linspace(0, 1, curve.shape[1]), curve, kind=kind)\n        t_fine = np.linspace(0, 1, samples)\n        x_fine, y_fine = spline(t_fine)\n        curve.resize((2, samples), refcheck=False)\n        curve[:] = np.vstack((x_fine, y_fine))\n    @staticmethod\n    def interpolate_figure(figure, samples=100, kind=\"cubic\"):\n        spline = interp1d(np.linspace(",
    "l_to_cartesian(curve_cartesian, rho_bounds, theta_bounds, rho_bounds_new, theta_bounds_new):\n        x_bounds = (np.min(curve_cartesian[:, 0]), np.max(curve_cartesian[:, 0]))\n        y_bounds = (np.min(curve_cartesian[:, 1]), np.max(curve_cartesian[:, 1]))\n        return CurveTransforms.remap_polal_to_cartesian(curve_cartesian, rho_bounds, theta_bounds, rho_bounds_new, theta_bounds_new)\n    @staticmethod\n    def remap_c2c(curve, old_x_bounds, old_y_bounds, new_x_bounds, new_y_bounds):\n        transform = Affine2D",
    "ate[:, 1])\n        y = polar_curve[:, 0] * np.sin(polar_curve[:, 1])\n        return np.vstack((x, y))\n    @staticmethod\n    def cartesian_to_polar(x, y):\n        rho = np.sqrt(x ** 2 + y ** 2)\n        theta = np.arctan2(y, x)\n        return np.vstack((rho, theta))\n    @staticmethod\n    def polar_to_cartesian(polar_curve):\n        x = polar_curve[:, 0] * np.cos(polar_curve[:, 1])\n        y = polar_curve[:, 0] * np.sin(polar_curve[:, 1])\n        return np.vstack((x, y))\n    @staticmethod\n    def cartesian_to_",
    "\n        for i in range(repetitions):\n            curves[i] = np.array(curves[i])\n            curves[i] = curves[i].reshape(1, -1)\n    @staticmethod\n    def rotate_figure_with_curves(figure: \"Figure\", angle=0):\n        Transformer.rotate_curves(figure.Curves, angle)\n        figure.evaluate_bounds()\n        return figure\n    @staticmethod\n    def rotate_figure_with_curves_with_curves(figure: \"Figure\", angle=0):\n        Transformer.rotate_curves(figure.Curves, angle, reverse=True)\n        figure.evaluate_bounds()\n        return figure\n    @staticmethod\n    def rotate_figure_with_curves_with_curves_with_curves(figure: \"Figure\", angle",
    "n theta in theta1])\n        outer_rho = np.array([outer_radius + (i % 2) * teeth_width for i in theta1])\n        theta = np.linspace(theta1, theta2, segments + 1)\n        inner_rho = np.array([inner_radius + (i % 2) * teeth_width for i in theta2])\n        outer_rho = np.array([outer_radius + (i % 2) * teeth_width for i in theta2])\n        theta = np.linspace(theta1, theta2, segments + 1)\n        inner_rho = np.array([inner_radius + (i % 2) * teeth_width for i in theta1])\n        outer_rho = np.array([outer_radius + (i",
    " str) -> Tuple[int, int, int]:\n        \"\"\"Split a line into a tuple of indentation and code text.\"\"\"\n        indentation = 0\n        code_text = ''\n        for char in line:\n            if char == '\\n':\n                indentation += 1\n            elif char == '\\t':\n                code_text += char\n            elif char == '\\r':\n                code_text += '\\n'\n            elif char == '\\b':\n                code_text += '\\b'\n            elif char == '\\f':\n                code_text += '\\f'\n            elif char == '\\n':\n                code_text += '\\n'\n            elif char == '\\r':\n                code_text += '\\r'\n            elif char == '\\t':\n                code_text += '\\t'\n            elif char == '\\v':\n                code_text += '\\v'\n            elif char == '\\",
    "ageSlicer.sample_from_curve(image, curve, dpu)\n        return image, extent, path, outline_curves\n    @staticmethod\n    def circular_arc(image, dpu=1000.0, inner_radius=0.0, outer_radius=1.0, theta1=0.0, theta2=np.pi / 6) -> (np.ndarray, (float, float, float, float), Path, List[np.ndarray]):\n        curve1 = CurveGenerator.circular_arc(100, inner_radius, theta1, theta2)\n        curve2 = np.flip(CurveGenerator.circular_arc(100, outer_radius, theta1, theta2), 0)\n        outline_curves = [curve1, curve2]\n       ",
    "       for i in range(length):\n            for key in expected:\n                total[key] += 1\n            for key in generated:\n                counts[key] += 1\n        averaged = {key: (total[key] / counts[key]) if counts[key] > 0 else None for key in total}\n        return averaged\n    def evaluate_multi_with_baseline(self, generated: List[str], expected: List[str], check_syntax=False):\n        length = len(generated)\n        if length!= len(expected):\n            return None\n        total = defaultdict(float)\n        counts = defaultdict(int)\n        for i in range(length):\n            for key in expected:\n                total[key] += 1\n            for key in generated:\n                counts[key] += 1\n        averaged = {key:",
    "ds[0])\n        return CurveTransforms.apply_affine_single(curve, transform, inplace)\n    @staticmethod\n    def remap_c2c_multi(curves: List[np.ndarray], old_x_bounds, old_y_bounds, new_x_bounds, new_y_bounds):\n        transform = Affine2D().translate(-old_x_bounds[0], -old_y_bounds[0])\n        transform = transform.scale((new_x_bounds[1]-new_x_bounds[0])/(old_x_bounds[1]-old_x_bounds[0]),\n                                    (new_y_bounds[1]-new_y_bounds[0])/(old_y_bounds[1]-old_y_bounds[0]))\n        transform = transform.translate(new",
    "_line + 1:end_idx])\n        )\n        if middle_text:\n            prefix = '\\n'.join(lines[start_line:start_line] + [lines[start_line][:start_idx]])\n            suffix = '\\n'.join([lines[end_line][end_idx:]] + lines[end_line + 1:end])\n            return prefix, middle_text, suffix\n        else:",
    " curve = np.vstack((inner_rho, np.flip(theta))).T\n        outline_curves = [curve]\n        (image, extent, path) = ImageSlicer.sample_from_curve(image, curve, dpu)\n        return image, extent, path, outline_curves\n    @staticmethod\n    def serrated_sine_wave_arc(image, dpu=1000.0, n_periods=2, period_offset=0.25, inner_radius=0.5, outer_radius=0.8,\n                           amplitude=0.1, theta1=0.0, theta2=np.pi/2):\n        inner_curve = CurveGenerator.sine_wave_circular_arc(100, inner_radius+amplitude, theta1,",
    "      \"\"\"Extract assignment sections with character limit and surrounding context.\"\"\"\n        assignments = find_assignments(block)\n        lines = block.splitlines()\n        examples = []\n        for start_pos, end_pos in assignments:\n            result = CodeSegmentExtractor.extract_section(lines, start_pos, end_pos, max_characters, min_context_lines, max_context_lines)\n            if result:\n                examples.append(result)\n        return examples\n    @staticmethod\n    def extract_assignment_lines(block: str, max_characters: int = 100, min_context_lines: int = 1, max_context_lines: int = -1) -> List[Tuple[str, str, str]]:\n        \"\"\"Extract assignment lines with character limit and surrounding context.\"\"\"\n        assignments = find_assignments(block)\n       ",
    "ns.polar_to_cartesian(nodes)\n        curve = CurveGenerator.bezier(nodes, values)\n        curve = CurveTransforms.fit_c2c(curve, (-width/2, 0, 0, height))\n        return curve\n    @staticmethod\n    def fit_c2c(curve, x_values, y_values):\n        curve = CurveTransforms.interpolate(curve, 100, \"cubic\", False)\n        curve = CurveTransforms.scale_single(curve, (1, 2 * (y_values - x_values) / x_values), (0, y_values))\n        return curve\n    @staticmethod\n    def translate_single(curve, x_value, y_value, inplace=False):\n        curve = CurveTransforms.interpolate(curve, 100, \"cubic\",",
    "d_angle + rotation_offset, angle)\n            else:\n                trans_data = Affine2D().rotate(i * angle + rotation_offset).translate(radius, 0).rotate(i * angle + rotation_offset)\n            transforms.append(trans_data)\n        return transforms\n    @staticmethod\n    def mirror_placement(radius=0.5, repetitions: int = None, delta_angle: float = None, local_rotation_offset=0.0, global_rotation_offset=0.0, use_flip=False, flip_angle=0.0, reverse_rotation=False):\n        if repetitions is None and delta_angle is None:\n            repetitions = 1\n            angle = None\n        elif repetitions is None:\n            repetitions = np.trunc(2 * np.pi / delta",
    "_arc(image, dpu=10.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.",
    "np.pi/2)\n        return image_sample\n    @staticmethod\n    def sine_wave_ring_arc(image, dpu=1000.0, segments=8, periods_per_segment=3, period_offset=0.25, inner_radius=0.5, outer_radius=0.8, amplitude=0.1, sample_rotation=0.0, sample_rotation + np.pi / segments) -> (ImageSample, ImageSample, ImageSample):\n        (image_sliced, extent, path, outline_curves) = ImageSlicer.serrated_ring_arc(image, dpu, periods_per_segment,\n                                                                                      period_offset, inner_radius, outer_radius, amplitude, sample_rotation, sample_rotation + np.pi / segments",
    " rotate_figure_with_scale(figure: \"Figure\", scale=1.0):\n        Transformer.rotate_figure(figure.Curves, scale)\n        figure.evaluate_bounds()\n    @staticmethod\n    def scale_figure_with_scale(figure: \"Figure\", scale=1.0):\n        Transformer.scale_figure(figure.Curves, scale)\n        figure.evaluate_bounds()\n    @staticmethod\n    def rotate_figure_with_angle(figure: \"Figure\", angle=0):\n        Transformer.rotate_figure(figure.Curves, angle)\n        figure.evaluate_bounds()\n    @staticmethod\n    def scale_figure_with_angle(figure: \"Figure\", angle=0):\n        Transformer.scale_figure(figure.Curves, angle)\n        figure.evaluate_bounds()\n    @staticmethod\n    def rotate",
    "min_context_lines:\n                continue\n            if call['end_line'] - 1 < min_context_lines or num_lines - call['start_line'] < min_context_lines:\n                continue\n            prefix = '\\n'.join(lines[call['start_line']:call['start_line'] - 1] + [lines[call['start_line']][:call['start_line'] - 1]])\n            suffix = '\\n'.join([lines[call['end_line']:end_line]] + lines[call['start_line']:end_line] + [lines[call['end_line']][:end_line]])\n            examples.append((prefix, middle_text, suffix))\n        return examples\n    @staticmethod\n    def extract_assignment_arguments(block: str, max_arguments: int",
    "        repetitions = 1\n            angle = delta_angle\n        elif delta_angle is None:\n            repetitions = np.trunc(2 * np.pi / delta_angle)\n            angle = None\n        else:\n            repetitions = np.maximum(1, repetitions)\n            angle = delta_angle\n        if angle is None:\n            angle = 2 * np.pi / repetitions\n        if reverse_rotation:\n            angle = -angle\n        transforms = []\n        for i in range(repetitions):\n            if i % 2 == 0 or not use_flip:\n                trans_data = Affine2D().rotate(rotation_offset).rotate(i * angle + flip_angle + rotation_offset)\n            else:\n                trans_data = Affine2D().rotate(-flip_angle).scale(1, -1",
    "h=0.1, half=False):\n        theta = np.linspace(0, 2 * np.pi, n)\n        rho = radius * np.ones(n + 1)\n        curve = CurveTransforms.polar_to_cartesian(np.vstack((rho, theta)).T)\n        CurveTransforms.translate_single(curve, offset[0], offset[1], inplace=True)\n        return curve\n    @staticmethod\n    def sine_wave_linear(n=100, width=0.1, height=0.2, half=False):\n        theta = np.linspace(0, 2 * np.pi, n)\n        rho = radius * np.ones(n + 1)\n        curve = CurveTransforms.polar_to_cartesian(np.vstack((rho,",
    "eitions = int(np.trunc(2 * np.pi / delta_angle))\n            angle = delta_angle\n        if rotation_offset is None:\n            rotation_offset = 0.0\n        if use_flip:\n            flip_angle = 0.0\n        transforms = []\n        for i in range(repetitions):\n            if i % 2 == 0 or not use_flip:\n                trans_data = Affine2D().rotate(rotation_offset).translate(radius, 0).rotate(i * angle + rotation_offset)\n            else:\n                trans_data = Affine2D().rotate(-flip_angle).scale(1, -1).rotate(flip_angle + rotation_offset).translate(radius, 0).rotate(i * angle + rotation_offset)\n            transforms.append(",
    "rrent_outline_color, linewidth=outline_thickness, color=outline_color, zorder=z_order)\n            ax.set_title(f\"Persistent {self.PersistentClipPaths[i]}\")\n            ax.set_xlabel(\"x\")\n            ax.set_ylabel(\"y\")\n            ax.set_zlabel(\"z\")\n            ax.set_xlim(0, self.Extent[1])\n            ax.set_ylim(0, self.Extent[0])\n            ax.set_zlim(0, self.Extent[2])\n            ax.set_aspect(\"equal\")\n            ax.set_facecolor(outline_color)\n            ax.set_edgecolor(\"black\")\n            ax.set_alpha(0.5)\n            ax.set_facecolor(\"white\")\n            ax.set_",
    "h, y_abs*dpu)), height-1)\n            new_height = np.maximum(int(np.maximum(height, y_abs*dpu)), height+1)\n            new_width = int(new_height * clip_ar)\n        else:\n            new_width = np.maximum(int(np.maximum(width, y_abs*dpu)), width-1)\n            new_height = np.maximum(int(np.maximum(height, y_abs*dpu)), height+1)\n        new_image = np.zeros((new_height, new_width, 3), dtype=np.uint8)\n        new_image[:, :, 0] = image\n        new_image[:, :, 1] = curve\n        new_image[:, :, 2] = dpu\n       ",
    "\n        Transformer.rotation_repeat_curves(figure.Curves, number_of_segments, delta_angle, scale)\n        figure.evaluate_bounds()\n    @staticmethod\n    def rotate_figure_with_rotation(figure: \"Figure\", angle=0):\n        Transformer.rotate_figure(figure.Figure, angle)\n        figure.evaluate_bounds()\n    @staticmethod\n    def scale_figure_with_rotation(figure: \"Figure\", scale=1.0):\n        Transformer.scale_figure(figure.Figure, scale)\n        figure.evaluate_bounds()\n    @staticmethod\n    def rotate_figure_with_scale(figure: \"Figure\", angle=0):\n        Transformer.rotate_figure_with_rotation(figure.Figure, angle)\n        figure.evaluate_bounds()\n    @staticmethod\n    def scale_figure_with_"
]