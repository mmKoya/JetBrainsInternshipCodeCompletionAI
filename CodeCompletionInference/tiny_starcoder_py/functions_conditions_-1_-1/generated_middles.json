[
    "inplace",
    "self.is_empty()",
    "input_coordinate == \"z_input\":\n            z_values = values\n            x_values = np.array([function(z) for z in z_values])\n            curve = np.vstack((x_values, y_values)).T\n        elif input_",
    "isinstance(node.func, ast.Name):\n            func_name = node.func.id\n        elif isinstance(node.func, ast.Attribute):\n            parts = []\n            current = node.func\n            while isinstance(current, ast.Attribute):\n                parts.insert",
    "rotation_offset is None:\n            rotation_offset = 0.0\n        elif rotation_offset is not None:\n            rotation_offset = np.maximum(0.0, rotation_offset)\n        else:\n            rotation_offset = 0.0\n        if use",
    "i == 0:\n                trans_data = Affine2D().rotate(local_rotation_offset).translate(radius, 0).rotate(i * angle + global_rotation_offset)\n            else:\n                trans_data = Affine2D().rotate",
    "max_characters > 0 and len(middle_text) > max_characters:\n            return None\n        prefix, middle_text, suffix = extract_prefix_middle_text(middle_text, max_characters)\n        return prefix, middle_text, suffix\n\n   ",
    "neighbour < region2_id:\n            del similarities[(neighbour, region2_id)]\n        else:\n            del similarities[(region2_id, neighbour)]\n    new_mask = np.logical_or(region1_info['mask'], region2",
    "rotation_offset is None:\n            rotation_offset = 0.0\n        else:\n            rotation_offset = np.maximum(0.0, rotation_offset)\n        if reverse_rotation:\n            transforms = transforms[::-1]\n        transforms = np.array(",
    "node.target is None:\n            return\n        if isinstance(node, ast.Assign)",
    "inner_curve[0] == \"cartesian\":\n            inner_curve = CurveTransforms.cartesian_to_polar(inner_curve)\n        else:\n            inner_curve = np.vstack((-inner_curve[:, 0], inner_curve[:, 1",
    "isinstance(node, ast.Expr) and isinstance(node.value, ast.IfExp)",
    "max_arguments > 0 and call['end_line'] - 1 < max_arguments:\n                continue\n            if max_arguments > 0 and call['end_line'] - 1 < min_context_lines:\n                continue\n            if max_arguments >",
    "neighbour_id not in similarities:\n                similarities[(region_id, neighbour_id)] = 0\n            similarities[(region_id, neighbour_id)] += region['similarity']\n    return similarities\n\n\ndef histogram_intersection(histogram1, histogram",
    "repetitions is None:\n            repetitions = 1\n            angle = None\n        elif repetitions is None:\n            repetitions = np.trunc(2 * np.pi / delta_angle)\n            angle = None\n        elif delta_angle is None:\n            repetitions",
    "split_idx >= len(examples)",
    "number_of_segments is None:\n            curves = []\n            for i in range(repetitions):\n                curves.append(curves[i])\n        else:\n            curves = np.array(curves)\n            curves = curves[::-1]\n        if delta",
    "debug_colors:\n            for curve in self.AdditionalCurves:\n                ax.plot(curve[:, 0], curve[:, 1], color=curve[:, 2], solid_capstyle='round', zorder=z_order, transform=ax.transData",
    "interpolation_type == \"bezier\":\n            curve = control_nodes\n        elif interpolation_type == \"linear\":\n            curve = control_nodes\n        else:\n            curve = CurveTransforms.interpolate(control_nodes, 100, \"cubic\", False)\n        return curve",
    "isinstance(node, ast.Assign)",
    "number_of_segments is None",
    "self.PlotType[i] == \"line\":\n                ax.plot(self.Curves[i][:, 0], self.Curves[i][:, 1], color=\"k\", zorder=self.z_order)\n            elif self.Plot",
    "scale.size == 2",
    "current_line >= end_idx:\n                break\n        prefix = lines[current_line][:start_idx]\n        arguments = ', '.join(function_call['arguments'])\n        suffix = lines[current_line][end_idx:]\n        return prefix, arguments, suffix",
    "cycle_length == 0:\n            swaps += 1\n    return swaps\n\ndef min_swaps_to_transform_2(perm1, perm2):\n    n = len(perm1)\n    index_map = {value: i for i",
    "function == \"sin\":\n            x_values = values\n            y_values = np.array([function(x) for x in x_values])\n            curve = np.vstack((x_values, y_values)).T\n        elif function == \"cos\":\n           ",
    "num_lines < min_context_lines",
    "polar",
    "repetitions > 1:\n            curves = []\n            for i in range(repetitions):\n                angle = np.pi/2 - i*angle\n                new_curves = copy.deepcopy(curves)\n                Transformer.rotate_curves(new_",
    "self.is_empty()",
    "isinstance(node.func, ast.Name)",
    "node.test.id == 'if'",
    "current is not None:\n                parts.append(current.attr)\n                current = current.value\n            if isinstance(current, ast.Name):\n                parts.insert(0, current.id)\n            func_name = \".\".join(parts)\n        args = [",
    "clip_ar < 1.0:\n            clip_ar = 1.0\n        if clip_ar > 1.0:\n            clip_ar = 1.0\n        if clip_ar < 0.0:\n            clip_ar = 0",
    "isinstance(node.func, ast.Attribute)",
    "j < n and not visited[j]",
    "delta_angle is None:\n            repetitions = np.trunc(2 * np.pi / delta_angle)\n            angle = None\n        elif delta_angle is None:\n            repetitions = np.maximum(1, repetitions)\n            angle = delta_angle\n       ",
    "rotation_offset is None and delta_angle is None:\n            rotation_offset = 0.0\n            delta_angle = 0.0\n        elif rotation_offset is None and delta_angle is not None:\n            rotation_offset = delta_angle\n            delta_",
    "input_coordinate == \"y_input\"",
    "max_characters < len(lines[start_line])",
    "flip:\n            curve = curve.flip()\n        if half:\n            curve = curve.half()\n        return CurveTransforms.merge_curves([triangle1, curve])\n\n    def edge_type2(width=1.0, height=0.2, flip=",
    "coordinate_type2 == \"polar\":\n            curve2 = CurveTransforms.tight_remap_polar_to_polar(curve2, (radius2, radius2+width2), (theta1, theta1 + (theta2-theta1)/periods2))\n           ",
    "i == 0:\n                trans_data = Affine2D().rotate(i * angle)\n            elif i == repetitions - 1:\n                trans_data = Affine2D().rotate(i * angle + rotation_offset)\n            else",
    "isinstance(current, ast.Name):\n                func_name = current.id\n            else:\n                func_name = \".\".join(parts)\n        else:\n            func_name = None\n        self.generic_visit(node)\n        return func_name\n\n    def visit",
    "key not in total",
    "neighbour < region2_id:\n            del similarities[(neighbour, region2_id)]\n        else:\n            del similarities[(region2_id, neighbour)]\n    similarities[(region1_id, region2_id)] = 0\n    for neighbour",
    "result is not None",
    "min_left <= len(prefix) <= min_right",
    "x_bounds[0] == x_bounds[1]",
    "evaluate_bounds:\n            self.update_curve_bounds(self.evaluate_curve_bounds(curve))\n\n    def update_curve_bounds(self, bounds):\n        for curve in self.Curves:\n            curve.update_bounds(bounds)\n\n    def evaluate"
]