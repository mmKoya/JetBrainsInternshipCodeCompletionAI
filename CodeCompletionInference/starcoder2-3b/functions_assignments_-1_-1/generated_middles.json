[
    "(CurveGenerator.bezier(np.array([[0, 0], [0, 1], [1, 1], [1, 2]])), 1, inner_radius, width, \"cartesian\")",
    "CurveTransforms.merge_curves([arc, gap1, arc, gap2, arc])",
    "ImageSample(image_sliced, extent, path, outline_curves)",
    "[]",
    "source_code\n        self.function_calls = []\n\n    def __init__(self, source_code, function_calls):\n        self.source_code = source_code",
    "min(num_lines, end_line + 1 + (max_context_lines if max_context_lines >= 0 else end_line))",
    "CodeBlockExtractor()",
    "CurveTransforms.tight_map_cartesian_to_polar(curve2, (radius2 - width2, radius2), (theta1, theta1 + (theta2-theta1)/periods2))",
    "bounds[1]",
    "ast.parse(code)",
    "np.minimum(int(np.minimum(height, y_abs*dpu)), height-1)",
    "bounds[0]",
    "nltk.word_tokenize(expected)",
    "CurveTransforms.interpolate(control_nodes, 100, \"bezier\", False)",
    "min(num_lines, call['end_line'] + (max_context_lines if max_context_lines >= 0 else num_lines - call['end_line']))",
    "perm.copy()\n  ",
    "CurveGenerator.generate_curves(image, outline_curves, dpu)",
    "[]",
    "np.histogram(region[:, 2], range=(0.0, 1.0), bins=n_bins)\n    hist_r = hist_r / size\n    hist_b = hist_b / size\n    hist_g = hist_g / size",
    "1",
    "CurveGenerator.draw_curves(image, curve, dpu, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1",
    "[]",
    "delta_angle",
    "-width/2",
    "None\n        else:\n            repetitions = np.maximum(1, number_of_segments)\n            angle = delta_angle\n        if angle is None:\n            angle = 2*np.pi/repetitions\n        scale = np.array(scale)\n        if scale.size == 1:\n            scales = scale*np.ones(repetitions)\n       ",
    "node.value.test.end_lineno",
    "bert_score(generated, expected, lang=\"en\", verbose=False)",
    "np.abs(x_bounds[0] - x_bounds[1]) / subdivisions[0]",
    "nltk.word_tokenize(generated)",
    "affine.transform(curve)\n        else:\n            return affine.transform(curve)\n\ndef apply_affine_batch(curves: np.ndarray, affine: Affine2D, inplace=True) -> np.ndarray: \n    if inplace:\n        affine.transform(curves)\n    else:\n        return affine.transform(curves)\n\ndef apply",
    "i",
    "local_outline_curves",
    "cart2pol(curve[0, :], curve[1, :])",
    "curves[0]\n        for i in range(1, len(curves)):\n            curve = np.concatenate((curve, curves[i]), axis=0)",
    "[]",
    "self.chrf_score(generated, expected)",
    "delta_angle\n        if angle is None:\n            angle = 2 * np.pi / repetitions\n        if reverse_rotation:\n            angle = -angle\n        transforms = []\n        for i in range(repetitions):\n            trans_data = Affine2D().rotate(i * angle + rotation_offset)\n            transforms.append(trans_data)\n        return",
    "'\\n'.join(lines[start:start_line])",
    "[]",
    "1 if char == '(' else parentheses_balance\n            parentheses_balance -= 1 if char == ')' else parentheses_balance",
    "CurveGenerator.generate_curves(image, outline_curves, dpu)",
    "outer_curve",
    "spline(t_fine)",
    "np.array([[0.0, 0.0]])\n            periods1 = 1\n            radius1 = 0.0\n            width1 = 0.0\n            coordinate_type1 = \"cartesian\"",
    "x",
    "1",
    "np.array(result)",
    "values\n            x_values = np.array([function(y) for y in y_values])\n            curve = np.vstack((x_values, y_values)).T\n        elif input_coordinate == \"parametric\":\n            result = [function(value) for value in values]\n            curve = np.array(result)\n        else:\n            print(\"Invalid",
    "current.value",
    "[]\n        self.X_data = []\n        self.Y_data = []\n        self.Rho_data = []\n        self.Theta_data = []\n        self.X_labels = []\n        self.Y_labels = []\n        self.Rho_labels = []\n        self.Theta_labels = []\n        self.X_units = []\n        self"
]