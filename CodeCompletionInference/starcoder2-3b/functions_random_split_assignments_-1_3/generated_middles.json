[
    "ments(block, max_characters, min_context_lines, max_context_lines)\n        assignments = sorted(assignments, key=lambda x: x[0])\n        assignments = [assignments[0]] + assignments[1:]\n        assignments = [assignments[0]] + assignments[1:]\n        assignments = [assignments[0]] + assignments[1:]\n        assignments = [assignments[0]] + assignments[1:]\n        assignments = [assignments[0]] + assignments[",
    "um(1, repetitions)",
    "x_bounds[0] - x_bounds[1]) / subdivisions[0]",
    "alue",
    "segments)",
    "2-theta1)/n_periods\n        period = period + period_offset*period",
    "), 0, inner_radius, edge_width, \"cartesian\")",
    "ource(node)",
    "le_image(curve, 1000)",
    "sforms.tight_map_polar_to_cartesian(curve1, (radius1, radius1+width1), (theta1, theta1 + (theta2-theta1)/periods1))\n            else:\n                curve1 = CurveTransforms.tight_map_cartesian_to_polar(curve1, (radius1, radius1+width1), (theta1, theta1 + (theta2-theta1)/periods1))\n            if coordinate_",
    "rve[:, 0]), np.max(curve[:, 0]))",
    "] - (max_context_lines if max_context_lines >= 0 else 0))",
    ".transform(curve)\n        else:\n            return affine.transform(curve)\n\ndef apply_affine_batch(curves: np.ndarray, affine: Affine2D, inplace=True) -> np.ndarray: \n    if inplace:\n        affine.transform(curves)\n    else:\n        return affine.transform(curves)\n\ndef apply_affine_single_batch(curves: np.ndarray, affine: Affine2D, inplace=",
    "gion_mask]",
    "ors']),\n        'id': new_id,\n        'centroid': (region1_info['centroid'] + region2_info['centroid']) / 2\n    }\n    new_region['neighbors'].discard(region1_id)\n    new_region['neighbors'].discard(region2_id)\n    for neighbour in new_region['neighbors']:\n        similarities[(neighbour, new_id)] = similarities[(neighbour, region1_id)] + similarities",
    "es, middle_end + (max_context_lines if max_context_lines >= 0 else middle_end))",
    "- 1, start_pos[1]\n        if start_line < min_context_lines or num_lines - end_line - 1 < min_context_lines:\n            return None, None, None\n        if max_characters > 0:\n            start_idx = max(0, start_idx - max_characters)\n            end_idx = min(len(lines[start_line]), end_idx + max_characters)\n        if max_",
    "es(examples, max_value, max_context)",
    "_pos, end_pos)",
    "all['start_idx'],\n            function_call['end_idx']\n        )\n        prefix = lines[current_line][start_idx:end_idx]\n        start_idx += len(prefix)\n        end_idx = start_idx\n        while end_idx < len(lines[current_line]) and lines[current_line][end_idx]!= ')':\n            end_idx += 1\n        arguments = lines[current_line][start_idx:",
    ", theta)).T",
    "r_curve, outer_curve, segments, sample_rotation)",
    "unds[1]) / subdivisions[1]\n        print(x_delta, y_delta)",
    "mations.polar_to_cartesian(curve)",
    "on_call['arguments'])\n        end_idx = len(lines[current_line]) - 1",
    "offset).translate(radius, 0).rotate(i * angle + global_rotation_offset)\n            else:\n                trans_data = Affine2D().rotate(-flip_angle).scale(1, -1).rotate(flip_angle + local_rotation_offset).translate(radius, 0).rotate(i * angle + global_rotation_offset)\n            transforms.append(trans_data)\n        return transforms\n\n    def get_transforms_for_rotation",
    "e(code)",
    "nd_line'] - 1]",
    "flipud(curve)))\n        else:\n            curve = np.vstack((curve, np.flipud(curve)))",
    "neTransform(1, 0, 0, 1, 0, 0)]\n        self.LocalOutlineCurves = []\n        self.LocalOutlineCurves = local_outline_curves\n        self.AdditiveTransforms = []\n        if local_outline_curves:\n            self.LocalOutlineCurves = local_outline_curves\n        else:\n            self.LocalOutlineCurves = []\n\n    def __init__(self, extent, main_clip_",
    "ndint(0, 255, (num_segments, 3))",
    "().rotate(-i * angle + rotation_offset)",
    "es[current_line:function_call['start_line']])\n        end_idx = function_call['arguments_start_idx']",
    "ple(image_sliced, extent, path, outline_curves)\n        ImageSampleTransformer.rotate_persistent(image_sample, sample_rotation)",
    "np.ceil(2 * np.pi / angle))",
    "ner_radius, outer_radius, width,\n                                                                                    sample_rotation, global_rotation, left_edge, right_edge, interpolation)",
    "n_calls(block)\n        if not function_calls:\n            return []\n        function_calls = sorted(function_calls, key=lambda x: x[0])\n        function_calls = [x for x in function_calls if x[1] < max_arguments]\n        function_calls = [x for x in function_calls if x[0] > min_context_lines]\n        if max_context_lines > 0:\n            function_calls",
    "line_curves",
    "ing_pattern, replace_string, code)",
    "rator.generate_curve(control_nodes, values)\n        curve = CurveTransforms.fit_c2c(curve, (0, 0, width, 0))",
    "i + aligned) % 2 * teeth_width for i in range(segments + 1)])",
    "ho), np.max(rho))",
    "dditive(inner_curve, outer_curve, segments,\n                                                                                       global_rotation=global_rotation, half=half, left_edge=left_edge, right_edge=right_edge)",
    "plit_idx + 1:]\n        if middle:\n            suffix = middle[split_idx + 1:]",
    "_scores(generated, expected)",
    "(curve[:, 0])",
    "alue",
    "match.group(1)}}}}\"",
    "lip_path\n        self.LocalOutlineCurves = local_outline_curves",
    "image, dpu, segments, sides_per_segment, inner_radius, outer_radius, sample_rotation, global_rotation, left_edge, right_edge)\n        image_sample = ImageSample(image_sliced, extent, path, outline_curves)\n        ImageSampleTransformer.rotational_repeat_additive(image_sample, 2 * segments, None,\n                                                          rotation_offset=-sample_rotation + global_rotation,\n                                                          rotation_"
]