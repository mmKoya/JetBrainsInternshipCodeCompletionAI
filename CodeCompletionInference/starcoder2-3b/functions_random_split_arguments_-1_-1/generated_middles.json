[
    "ast.Assign",
    "d, region2_id",
    " curve2)",
    "Curves",
    "Theta_bounds[0], bounds[3][0]",
    " (radius2, radius2+width2), (theta1, theta1 + (theta2-theta1)/periods2)",
    "[:, 0]",
    "heta)",
    "nt, path, outline_curves)\n        ImageSampleTransformer.rotational_repeat_additive(image_sample, segments, None,\n                                                          rotation_offset=sample_rotation+global_rotation, use_flip=True,\n                                                          flip_angle=(sample_rotation + np.pi /",
    "ze, interpolation",
    "], -old_y_bounds[0]",
    "urves)):\n                transformed_curves.append(affine.transform(curves[i]))\n            return transformed_curves\n\n\ndef apply_affine_multi_inplace(curves: List[np.ndarray], affine: Affine2D) -> List[np.ndarray]:\n    for",
    " rotation_offset",
    "ters, min_context_lines, max_context_lines",
    "offset*freq)",
    "o['neighbors']) - {new_id},\n        'color_histogram': merge_histograms(region1_info['color_histogram'],\n                                            region1_info['size'],\n                                            region2_info['color_histogram'],\n                                            region2_info['size']",
    "riods2)]), 0)\n        if left_side and right_side:\n            outline_curves = [np.vstack((curve1, curve2, np.array([[curve1[0, 0], curve1[0, 1]]])))]\n        elif right_side",
    "1, 1))\n        CurveTransforms.translate_single(arc, -width/2, 0, False",
    "_text, suffix)",
    " None), segments, radius, height, left_edge, right_edge",
    "curves)\n            Transformer.rotate_curves(new_curves, i*angle)\n            Transformer.scale_curves(new_curves, scales[i])\n            curves.extend(new_curves)\n        return curves\n\n    def rotation_repeat_curves_with_offset",
    "tart_col), (end_line, end_col)))\n        elif isinstance(node, ast.IfExp):\n            condition = ast.get_source_segment(code, node.test)\n            start_line = node.test.lineno\n            start_col = node.test.col",
    "1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 10",
    "rves)",
    "0], -pivot[1]",
    "size[1] + 1",
    "_points",
    "t.AnnAssign",
    ", (1, 1",
    "tions)\n        curves = []\n        for i in range(repetitions):\n            new_curves = copy.deepcopy(curves)\n            Transformer.rotate_curves(new_curves, i*angle)\n            Transformer.scale_curves(new_curves, scales[i",
    "tesian[:, 0]",
    "sistent_paths",
    "urves)",
    "_axis(curve, -1), axis=0)))\n        else:\n            curve = np.vstack((curve, np.flip(CurveTransforms.scale_single_axis(curve, -1), axis=0)))\n            curve = np.vstack((curve, np.flip(Curve",
    " extent, path, outline_curves",
    " theta2, n)\n        period = (theta2 - theta1)/n_periods\n        freq = 2*np.pi/period\n        rho = radius + amplitude*np.sin((theta-theta1+period_offset*period)*freq)\n        curve = CurveTransforms.polar_to",
    "tesian[:, 1]",
    "PersistentClipPaths)):\n            ax.add_patch(self.PersistentClipPaths[i])\n        for i in range(len(self.PersistentClipPaths",
    "_sample.PersistentTransforms",
    ", expected)\n        results['chrf++'] = self.chrf_plus_score(generated, expected",
    "cartesian[:, 1]",
    "angle",
    " segments + 1",
    "_code",
    "iods1)])\n        if outer_curve is None:\n            curve2 = np.array([[0, 0]])\n        else:\n            (curve2, periods2, radius2, width2, coordinate_type2) = outer_curve\n            if coordinate_type2 == \"polar\":\n               ",
    "nc, ast.Name",
    "0, 1, 100))\n        if half:\n            return CurveTransforms.merge_curves([triangle1, curve])\n        return CurveTransforms.merge_curves([triangle1, curve, triangle2])\n\n\nclass EdgeType2(object):\n    @staticmethod\n    def edge",
    "angle + local_rotation_offset).translate(radius, 0).rotate(i * angle + global_rotation_offset)\n            transforms.append(trans_data)\n        for i in range(repetitions):\n            if i % 2 == 0 or not use_flip:\n               ",
    " expected",
    "rves)"
]