[
    "ast.Assign",
    "d, region2_id",
    " curve2, np.array([[curve1[0, 0], curve1[0, 1]]]))",
    "Curves",
    "Theta_bounds[0], bounds[3][0]",
    " (radius2 - width2, radius2), (theta1, theta1 + (theta2-theta1)/periods2)",
    "[:, 0]",
    "heta)",
    "nt, path, outline_curves",
    "ze, interpolation",
    "], -old_y_bounds[0]",
    "urves)",
    " flip_angle + rotation_offset",
    "ters, min_context_lines, max_context_lines",
    "offset*period)*freq",
    "o['neighbors']",
    "riods2",
    "1, -1)",
    "_text, suffix)",
    " 1, radius, height, \"cartesian\"), sample_rotation, sample_rotation+np.pi/segments, left_edge, right_edge",
    "curves",
    "tart_col), (end_line, end_col))",
    "radius",
    "rves)",
    "0], -pivot[1]",
    "size[1] + 1",
    "_points",
    "t.AnnAssign",
    ", (-1, 1)",
    "tions",
    "tesian[:, 0]",
    "sistent_paths",
    "urves)",
    "(curve, (-1, 1), inplace=False), 0",
    " extent, path, outline_curves",
    " theta2, n",
    "tesian[:, 1]",
    "PersistentClipPaths",
    "_sample.PersistentTransforms",
    ", expected",
    "cartesian[:, 1]",
    "angle",
    " segments + 1",
    "_code",
    "iods1",
    "nc, ast.Name",
    "0, 1 - 0.5 * half, 100)",
    "angle",
    " expected",
    "rves)"
]