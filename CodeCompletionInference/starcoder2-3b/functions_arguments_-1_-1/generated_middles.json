[
    "image_sample, global_rotation, segments",
    "0, 1, 100",
    "image, dpu, inner_curve, outer_curve, theta1, theta2, left_side, right_side",
    "100, width, gap, pits_per_segment), 1, outer_radius, depth, \"cartesian\")\n        inner_curve = (CurveGenerator.pit(100, width, gap, pits_per_segment), 1, inner_radius, depth, \"cartesian\")\n        (image_sliced, extent, path,",
    "(curve2, curve1))]\n        elif left_side and right_side:\n            outline_curves = [np.vstack((curve1, curve2))]\n        elif left_side:\n            outline_curves = [np.vstack((curve2, curve1))]\n        else:\n            outline_curves = [curve1, curve2]\n        curve =",
    "num_lines, middle_end + (max_context_lines if max_context_lines >= 0 else num_lines - middle_end)",
    "0, 255, num_segments",
    "image_sample, global_rotation, segments",
    "-1",
    "1, number_of_segments)\n            angle = 2*np.pi/repetitions\n        if angle is None:\n            angle = 2*np.pi/repetitions\n        if reverse_rotation:\n            angle = -angle\n        scale = np.array(scale)\n        if scale.size == 1:\n            scales = scale*np.ones(",
    "y",
    "image, dpu, segments, inner_radius, outer_radius",
    "curve_cartesian[:, 1]",
    "angle",
    "regions[neighbour]['color_histogram'],\n                                            regions[new_id]['color_histogram']",
    "image, dpu, segments, sides_per_segment, inner_radius, outer_radius, sample_rotation, global_rotation, left_edge, right_edge",
    "(rho, theta)",
    "i * angle + global_rotation_offset).scale(1, -1).rotate(-flip_angle",
    "curve, 0.0",
    "radius, 0",
    "expected",
    "region2_info['neighbors'])\n    }\n    new_region['neighbors'].discard(region2_id)\n    new_region['neighbors'].discard(region1_id)\n    for neighbour in new_region['neighbors']:\n        similarity = histogram_intersection(regions[neighbour]['color_histogram'], new_region['color_histogram'])\n        if neighbour < new_id",
    "(prefix, middle, suffix)",
    "outline_curves",
    "image, dpu, segments, grid_size, inner_radius, outer_radius, width,\n                                                                                    sample_rotation, global_rotation, left_edge, right_edge, interpolation",
    "image, curve, dpu=dpu",
    "100, width, gap, pits_per_segment), 1, inner_radius, depth, \"cartesian\")\n        (image_sliced, extent, path, outline_curves) = ImageSlicer.custom_ring_arc(image, dpu, inner_curve, outer_curve, sample_rotation,\n                                                                                   sample_rotation +",
    "image_sliced, extent, path, outline_curves)\n        ImageSampleTransformer.rotational_repeat_additive(image_sample, segments, None,\n                                                          rotation_offset=sample_rotation + global_rotation, use_flip=True,\n                                                          flip_angle=(sample_rotation + np.pi / segments) / 2",
    "tree",
    "region2_id",
    "perm1",
    "outline_curves",
    "e",
    "(random_split_name, examples_split)",
    "control_nodes, values)\n        curve = CurveTransforms.fit_c2c(curve, (0, 0, width, 0))\n        curve = CurveTransforms.fit_c2c(curve, (0, 0, 0, height))\n        if not half:\n            curve = np.vstack((curve, np.flip(CurveTransforms.",
    "(x_fine, y_fine)",
    "curve[:, 1]",
    "curve1, i*(theta2-theta1)/periods1, inplace=False",
    "curve2, axis=0)\n        curve2 = np.vstack([CurveTransforms.rotate_single(curve2, i * (theta2 - theta1) / periods2, inplace=False) for i in range(0, periods2)])\n        curve = np.vstack((curve1, curve2))\n        (image, extent, path) = ImageS",
    "0, current.id",
    "n + 1)\n        theta = np.hstack((theta, theta[0]))\n        rho = np.hstack((rho, rho[0])",
    "np.uint8",
    "num_segments",
    "block)\n        if not function_calls:\n            return []\n        function_calls = sorted(function_calls, key=lambda x: x['start_line'])\n        function_calls = [call for call in function_calls if call['start_line'] == call['end_line']]\n        function_calls = [call for call in function_calls if call['arguments",
    "image_sliced, extent, path, outline_curves)\n        ImageSampleTransformer.rotational_repeat_additive(image_sample, segments, None,\n                                                          rotation_offset=sample_rotation+global_rotation, use_flip=True,\n                                                          flip_angle=(sample_rotation + np.pi / segments) / 2",
    "pivot[0], pivot[1]",
    "new_height * clip_ar",
    "len(curves)",
    "int(np.minimum(height, y_abs*dpu)), height-1",
    "bounds"
]