[
    "raise ValueError(\"Either number_of_segments or delta_angle must be specified\")\n        if number_of_segments is None:\n            repetitions = np.maximum(1, int(np.ceil(np.pi/delta_angle)))",
    "y_values = values\n            x_values = np.array([function(y) for y in y_values])\n            curve = np.vstack((x_values, y_values)).T\n        elif input_coordinate == \"polar\":\n            result = []\n            for i in range(len(values)):\n                result.append(function(values[i][0], values[i][1]))",
    "return CurveTransforms.apply_affine_multi(curves, transform, inplace)\n    @staticmethod\n    def translate_single(curve: np.ndarray, x=0.0, y=0.0, inplace=True) -> np.ndarray:\n        transform = Affine2D().translate(x, y)\n        return CurveTransforms.apply_affine_single(curve, transform, inplace)",
    "\"name\": func_name,\n                \"args\": args,\n                \"start_line\": node.lineno,\n                \"start_col_offset\": node.col_offset,",
    "elif left_side:\n            outline_curves = [np.vstack((curve1, curve2, np.array([[curve1[0, 0], curve1[0, 1]]])))]\n        elif right_side:\n            outline_curves = [np.vstack((curve1, curve2, np.array([[curve2[-1, 0], curve2[-1, 1]]])))]\n        else:",
    "outline_curves = [inner_curve, outer_curve]\n        curve = np.vstack((inner_curve, outer_curve))\n        (image, extent, path) = ImageSlicer.sample_from_curve(image, curve, dpu)\n        return image, extent, path, outline_curves\n    @staticmethod\n    def sine_wave_ring_arc_with_hole(image, dpu=1000.0, n_periods=2, period_offset=0.25, inner_radius=0.5, outer_radius=0.8,\n                                     amplitude=0.1, theta1=0.0, theta2=np.pi/2, hole_radius=0.2, hole_theta1=0.0, hole_theta2=np.pi/2):\n        inner_curve = CurveGenerator.sine_wave_circular_arc(10",
    "(image, extent, path) = ImageSlicer.sample_from_curve(image, curve, dpu)\n        return image, extent, path, outline_curves\n    @staticmethod\n    def circular_arc(image, dpu=1000.0, radius=1.0, theta1=0.0, theta2=np.pi/6) -> (np.ndarray, (float, float, float, float), Path, List[np.ndarray]):\n        curve = CurveGenerator.circular_arc(100, radius, theta1, theta2)\n        outline_curves = [curve]\n        (image, extent, path) = ImageSlicer.sample_from_curve(image, curve, dpu)\n        return image, extent, path, outline_curves\n    @staticmethod\n    def teeth_ring_arc(image, dpu=1000.0, inner_radius",
    "curve = np.vstack((curve, np.flip(curve, 0)))\n        else:\n            curve = np.vstack((curve, np.flip(curve, 0), np.flip(curve, 0)))\n        CurveTransforms.translate_single(curve, 0, height, inplace=True)\n        return curve\n    @staticmethod\n    def edge_type2(width=1.0, height=0.2, flip=False, half=False):\n        if flip:\n            height = -height\n        triangle1 = np.array([[0, 0], [0.1*width, height], [0.2*width, 0]])\n        triangle2 = np.array([[0.8*width, 0], [0.9*width, height], [width, 0]])\n        curve_nodes = np.array([[0.2*width, 0], [0.4*width,",
    "func_name = current.id\n            else:\n                func_name = \".\".join(parts)\n        if func_name:\n            args = []\n            for arg in node.args:\n                if isinstance(arg, ast.Name):\n                    args.append(arg.id)\n                elif isinstance(arg, ast.Str):\n                    args.append(arg.s)\n                elif isinstance(arg, ast.Num):\n                    args.append(arg.n)\n                elif isinstance(arg, ast.List):\n                    args.append(self.source_code[arg.lineno-1:arg.end_lineno])\n                elif isinstance(arg, ast.Call):\n                    args.append(self.source_code[arg.lineno-1:arg.end_lineno])\n                else:\n                    args.append(self.source_code[arg.lineno-1:arg.end_lineno])\n            self.function_calls.append({",
    "curve = CurveTransforms.interpolate(nodes, len(values), \"cubic\", polar)\n        return curve\n    @staticmethod\n    def parametric(function, values=np.linspace(0.0, 1.0, 100), input_coordinate=\"x_input\", polar=False):",
    "curves[i][0, :] = -curves[i][0, :]\n    @staticmethod\n    def flip_vertical(curves):\n        for i in range(len(curves)):\n            curves[i][1, :] = -curves[i][1, :]\n    @staticmethod\n    def flip_figure(figure: \"Figure\"):\n        Transformer.flip_horizontal(figure.Curves)\n        figure.evaluate_bounds()\n    @staticmethod\n    def translate_figure(figure: \"Figure\", x=0.0, y=0.0):\n        Transformer.translate_curves(figure.Curves, x, y)\n        figure.evaluate_bounds()",
    "self.function_calls.append({\n                \"func_name\": func_name,\n                \"args\": args,\n                \"line_offset\": node.lineno,",
    "dataset_name = f'{dataset_type}_{max_value}_{max_context}'\n                examples = extract_method(code_blocks, max_value, max_context)\n                if examples:",
    "def evaluate_curve_bounds(self, curve):\n        x = curve[:, 0]\n        y = curve[:, 1]\n        rho = np.sqrt(x**2 + y**2)\n        theta = np.arctan2(y, x)\n        x_bounds = (np.min(x), np.max(x))\n        y_bounds = (np.min(y), np.max(y))",
    "def fit_polar_to_polar(curve_polar, extent):\n        rho_bounds = (np.min(curve_polar[:, 0]), np.max(curve_polar[:, 0]))\n        theta_bounds = (np.min(curve_polar[:, 1]), np.max(curve_polar[:, 1]))\n        return CurveTransforms.remap_polar_to_polar(curve_polar, rho_bounds, theta_bounds, extent[0:2], extent[2:4])\n    @staticmethod\n    def fit_polar_to_cartesian(curve_polar, extent):\n        x_bounds = (np.min(curve_polar[:, 0]), np.max(curve_polar[:, 0]))\n        y_bounds = (np.min(curve_polar[:, 1]), np.max(curve_polar[:, 1]))\n        return CurveTransforms.remap_polar_to_polar(curve_",
    "new_figure = Figure()\n        new_figure.append_figure(self)\n        if isinstance(figure, Figure):\n            new_figure.append_figure(figure)\n        else:",
    "local_rotation_offset=0.0, global_rotation_offset=0.0, use_flip=False, flip_angle=0.0, reverse_rotation=False, calculate_overlap=False):\n        additive_transforms = TransformsGenerator.circular_placement(radius, repetitions, delta_angle, local_rotation_offset,\n                                                                     global_rotation_offset, use_flip, flip_angle, reverse_rotation)\n        image_sample.AdditiveTransforms = additive_transforms\n        if calculate_overlap:\n            (new_persistent_paths, new_persistent_transforms, outline_curves) = paths_self_overlap(image_sample.PersistentClipPaths, image_sample.PersistentTransforms,\n                                                                                                   additive_transforms[0], additive_transforms[1])\n            image_sample.PersistentTransforms = new_persistent_transforms\n            image_sample.PersistentClipPaths = new_persistent_paths",
    "transform = Affine2D().translate(x, y)\n        return CurveTransforms.apply_affine_multi(curves, transform, inplace)\n    @staticmethod\n    def scale_single(curve: np.ndarray, scale=(1.0, 1.0), pivot=(0.0, 0.0), inplace=True) -> np.ndarray:\n        transform = Affine2D().translate(-pivot[0], -pivot[1]).scale(scale[0], scale[1]).translate(pivot[0], pivot[1])",
    "@staticmethod\n    def translate_multi(curves: List[np.ndarray], x=0.0, y=0.0, inplace=True) -> List[np.ndarray]:\n        transform = Affine2D().translate(x, y)\n        return CurveTransforms.apply_affine_multi(curves, transform, inplace)\n    @staticmethod",
    "if kind == \"cubic\":\n            interpolated_curve = np.linspace(0, 1, samples)\n            interpolated_curve = np.vstack((interpolated_curve, np.interp(interpolated_curve, np.linspace(0, 1, curve.shape[1]), curve[0, :])))\n            interpolated_curve = np.vstack((interpolated_curve, np.interp(interpolated_curve, np.linspace(0, 1, curve.shape[1]), curve[1, :])))\n            interpolated_curve = np.vstack((interpolated_curve, np.interp(interpolated_curve, np.linspace(0, 1, curve.shape[1]), curve[2, :])))\n            interpolated_curve = np.vstack((interpolated_curve, np.interp(interpolated_curve, np.linspace(0, 1, curve.shape[1]), curve[3",
    "def sample_from_curve(image, curve, dpu=1000.0):\n        height = image.shape[0]\n        width = image.shape[1]\n        image_ar = width / height\n        x1 = np.min(curve[:, 0])\n        x2 = np.max(curve[:, 0])\n        y1 = np.min(curve[:, 1])\n        y2 = np.max(curve[:, 1])\n        extent = (x1, x2, y1, y2)\n        x_abs = x2 - x1\n        y_abs = y2 - y1\n        clip_ar = x_abs / y_abs\n        if clip_ar < image_ar:\n            new_height = np.minimum(int(np.minimum(height, y_abs*dpu)), height-1)\n            new_width = int(new_height * clip_ar",
    "curve2 = np.vstack((outer_rho, theta)).T\n        outline_curves = [curve1, curve2]\n        curve = np.vstack((curve1, curve2))",
    "image_sample = ImageSample(image_sliced, extent, path, outline_curves)\n        ImageSampleTransformer.rotational_repeat_additive(image_sample, 2 * segments, None,\n                                                          rotation_offset=-sample_rotation+global_rotation, use_flip=True,\n                                                          flip_angle=(2 * sample_rotation + np.pi / segments) / 2)\n        return image_sample\n    @staticmethod\n    def leaf_ring(image, dpu=1000.0, segments=8, inner_radius=0.5, outer_radius=0.8, width=0.1, sample_rotation=0.0, global_rotation=0.0, left_edge=False, right_edge=False):\n        (image_sliced, extent, path, outline_curves) = ImageSlicer.leaf(image, dpu, width, outer_radius-",
    "if self.PlotType[i] > 0:\n                ax.plot(self.Curves[i][:, 0], self.Curves[i][:, 1], color=\"k\", solid_capstyle='round',\n                         linewidth=self.PlotType[i], zorder=self.z_order)\n            elif self.PlotType[i] < 0:\n                ax.fill(self.Curves[i][:, 0], self.Curves[i][:, 1], color=\"w\", zorder=self.z_order)\n                ax.plot(self.Curves[i][:, 0], self.Curves[i][:, 1], color=\"k\", solid_capstyle='round',\n                         linewidth=self.PlotType[i], zorder=self.z_order)\n        Figure.z_order += 1\n    def plot_with_bounds(self, ax",
    "def translate_single(curve: np.ndarray, x=0.0, y=0.0, inplace=True) -> np.ndarray:\n        transform = Affine2D().translate(x, y)\n        return CurveTransforms.apply_affine_single(curve, transform, inplace)\n    @staticmethod\n    def translate_multi(curves: List[np.ndarray], x=0.0, y=0.0, inplace=True) -> List[np.ndarray]:",
    "np.maximum(self.X_bounds[1], bounds[0][1]))\n            self.Y_bounds = (np.minimum(self.Y_bounds[0], bounds[1][0]),\n                             np.maximum(self.Y_bounds[1], bounds[1][1]))\n            self.Rho_bounds = (np.minimum(self.Rho_bounds[0], bounds[2][0]),\n                               np.maximum(self.Rho_bounds[1], bounds[2][1]))",
    "image_ar = width / height",
    "self.classes = []\n    def visit_FunctionDef(self, node):\n        function_source = ast.get_source_segment(self.code, node)\n        self.functions.append(function_source)\n        self.generic_visit(node)",
    "if reverse_rotation:\n            angle = -angle\n        if angle is None:\n            angle = 2*np.pi/repetitions",
    "curves.sort(key=lambda curve: curve.shape[1])\n        new_curves = []\n        for i in range(len(curves)):\n            new_curves.append(curves[i])\n            if i < len(curves)-1:\n                new_curves.append(curves[i] + curves[i+1])\n        curves[:] = new_curves\n    @staticmethod\n    def reverse_curve(curve):\n        curve[0, :] = np.flip(curve[0, :])\n        curve[1, :] = np.flip(curve[1, :])\n        curve[0, :] = np.flip(curve[0, :])\n        curve[1, :] = np.flip(curve[1, :])\n    @staticmethod\n    def reverse_curve_x(curve):\n        curve[0, :] = np.flip(curve[0, :])\n    @staticmethod\n   ",
    "image_sample.PersistentTransforms.extend(new_persistent_transforms)\n        return\n    @staticmethod\n    def additive_persistent(image_sample: ImageSample, additive_transforms: List[Affine2D]):\n        image_sample.AdditiveTransforms.extend(additive_transforms)\n        return\n    @staticmethod\n    def additive_persistent_from_paths(image_sample: ImageSample, additive_paths: List[Path]):\n        additive_transforms = []\n        for path in additive_paths:\n            additive_transforms.append(path.transform)\n        image_sample.AdditiveTransforms.extend(additive_transforms)\n        return\n    @staticmethod\n    def additive_persistent_from_paths_and_transforms(image_sample: ImageSample, additive_paths: List[Path], additive_transforms: List[Affine2D]):\n        image_sample.AdditiveTransforms.extend(additive_transforms",
    "curve2 = CurveGenerator.circular_arc(100, outer_radius, theta1, theta2)\n        outline_curves = [curve1, curve2]\n        curve = np.vstack((curve1, curve2))\n        (image, extent, path) = ImageSlicer.sample_from_curve(image, curve, dpu)\n        return image, extent, path, outline_curves\n    @staticmethod\n    def random_ring_arc(image, dpu=2000.0, grid_size=(5, 5), step_size=(1, 1), inner_radius=0.5, outer_radius=0.8, width=0.1, theta1=0.0, theta2=np.pi/6,\n                        left_side=False, right_side=False, interpolation=\"spline\") -> (np.ndarray, (float, float, float, float",
    "def test_ring_arc(image, dpu=1000.0, segments=8, inner_radius=0.5, outer_radius=0.8, sample_rotation=0.0) -> ImageSample:\n        (image_sliced, extent, path, outline_curves) = ImageSlicer.test_ring_arc(image, dpu, inner_radius, outer_radius, sample_rotation, sample_rotation + np.pi / segments)\n        image_sample = ImageSample(image_sliced, extent, path, outline_curves)",
    "    return self\n    def __add__(self, figure: \"Figure\"):\n        if isinstance(figure, Figure):\n            new_figure = Figure()\n            new_figure.append_figure(self)\n            new_figure.append_figure(figure)\n            return new_figure",
    "outline_curves = [np.vstack((curve1, curve2))]\n        else:\n            outline_curves = [np.vstack((curve1, curve2, np.array([[curve1[0, 0], curve1[0, 1]]])))]",
    "def extract_function_calls(block: str, max_arguments: int = 5, min_context_lines: int = 1, max_context_lines: int = -1) -> List[Tuple[str, str, str]]:\n        \"\"\"Extract function calls with specified context and argument count limitations.\"\"\"\n        function_calls = find_function_calls_with_args(block)\n        lines = block.splitlines()\n        num_lines = len(lines)\n        examples = []\n        for call in function_calls:\n            if len(call['arguments']) > max_arguments > 0:\n                continue\n            if call['start_line'] - 1 < min_context_lines or num_lines - call['end_line'] < min_context_lines:\n                continue\n            prefix, middle, suffix = TextUtils.extract_function_call_details(lines, call)\n            if not middle:\n                continue\n            start =",
    "lines = block.splitlines()\n        examples = []\n        for start_pos, end_pos in assignments:\n            result = CodeSegmentExtractor.extract_section(lines, start_pos, end_pos, max_characters, min_context_lines, max_context_lines)\n            if result:",
    "transformed_curve = affine.transform(curve)\n            return transformed_curve\n    @staticmethod\n    def apply_affine_multi(curves: List[np.ndarray], affine: Affine2D, inplace=True) -> List[np.ndarray]:\n        if inplace:\n            for i in range(len(curves)):",
    "targets = [node.target]\n            value = node.value",
    "split_idx = random.randint(min_left, len(middle) - min_right)\n            prefix += middle[:split_idx]",
    "rho = radius * np.ones(n)\n        curve = CurveTransforms.polar_to_cartesian(np.vstack((rho, theta)).T)\n        CurveTransforms.translate_single(curve, offset[0], offset[1], inplace=True)\n        return curve\n    @staticmethod",
    "new_curves = copy.deepcopy(base_curves)\n            curves.extend(new_curves)\n    @staticmethod\n    def translation_repeat_figure(figure: \"Figure\", repetitions=(2, 2), step=(0.1, 0.1), scale=1.0):\n        Transformer.translation_repeat_curves(figure.Curves, repetitions, step, scale)\n        figure.evaluate_bounds()\n    @staticmethod\n    def mirror_curves(curves: \"list\", axis=0):\n        for i in range(len(curves)):\n            curves[i][axis, :] = -curves[i][axis, :]\n    @staticmethod\n    def mirror_figure(figure: \"Figure\", axis=0):\n        Transformer.mirror_curves(figure.Curves, axis)\n        figure.evaluate_bounds()\n    @staticmethod\n    def mirror_repeat_curves(curves: \"",
    "self.Image = image\n    def update_extent(self, extent):\n        self.Extent = extent\n    def update_main_clip_path(self, main_clip_path):\n        self.MainClipPath = main_clip_path\n        self.PersistentClipPaths = [main_clip_path]\n    def update_persistent_clip_paths(self, persistent_clip_paths):\n        self.PersistentClipPaths = persistent_clip_paths\n    def update_persistent_transforms(self, persistent_transforms):\n        self.PersistentTransforms = persistent_transforms\n    def update_local_outline_curves(self, local_outline_curves):\n        self.LocalOutlineCurves = local_outline_curves\n    def update_additional_curves(self, additional_curves):\n        self.AdditionalCurves = additional_curves\n    def update_additive_transforms(self, additive_transforms):\n        self.Add",
    "curve = np.vstack((x_values, y_values)).T\n        return curve\n    @staticmethod\n    def circular_arc(n=100, radius=0.5, theta1=0.0, theta2=np.pi/2, offset=(0.0, 0.0)):\n        theta = np.linspace(theta1, theta2, n)\n        rho = radius * np.ones(n)",
    "return sliced_image, extent, path\n    @staticmethod\n    def sample_from_outline(image, outline_curves, dpu=1000.0):\n        height = image.shape[0]\n        width = image.shape[1]\n        image_ar = width / height\n        x1 = np.min(outline_curves[:, 0])\n        x2 = np.max(outline_curves[:, 0])\n        y1 = np.min(outline_curves[:, 1])\n        y2 = np.max(outline_curves[:, 1])\n        extent = (x1, x2, y1, y2)\n        x_abs = x2 - x1\n        y_abs = y2 - y1\n        clip_ar = x_abs / y_abs\n        if clip_ar < image_ar:\n            new_height = np.minimum(int(np.minimum",
    "try:\n            return chrf_score([generated], [expected], lang='en')\n        except Exception as e:\n            print(f\"Error calculating CHRF: {e}\")\n            return None",
    "value = node.annotation\n        else:\n            return\n        start_line = node.lineno\n        end_line = node.end_lineno",
    "self.AdditionalCurves.append(curve)\n    def add_persistent_clip_path(self, clip_path):\n        self.PersistentClipPaths.append(clip_path)\n    def add_persistent_transform(self, transform):\n        self.PersistentTransforms.append(transform)\n    def add_persistent_transforms(self, transforms):\n        self.PersistentTransforms.extend(transforms)\n    def update_image(self, image):\n        self.Image = image",
    "def remap_polar_to_c2c(curve_polar, rho_bounds, theta_bounds, extent):\n        return CurveTransforms.remap_polar_to_polar(curve_polar, rho_bounds, theta_bounds, extent[0:2], extent[2:4])\n    @staticmethod\n    def fit_polar_to_c2c(curve_polar, extent):\n        rho_bounds = (np.min(curve_polar[:, 0]), np.max(curve_polar[:, 0]))\n        theta_bounds = (np.min(curve_polar[:, 1]), np.max(curve_polar[:, 1]))\n        return CurveTransforms.remap_polar_to_c2c(curve_polar, rho_bounds, theta_bounds, extent)\n    @staticmethod\n    def interpolate_single(curve: np.ndarray, samples: int, inplace=True) -> np.ndarray:\n        if inplace",
    "if i % 2 == 0 or not use_flip:\n                trans_data = Affine2D().rotate(rotation_offset).rotate(i * angle + flip_angle)\n            else:\n                trans_data = Affine2D().rotate(-flip_angle).scale(1, -1).rotate(flip_angle + rotation_offset).rotate(i * angle + flip_angle)\n            transforms.append(trans_data)"
]