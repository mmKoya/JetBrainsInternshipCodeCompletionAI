[
    "one and delta_angle is None:\n            raise ValueError(\"Either repetitions or delta_angle must be specified\")\n        elif repetitions is not None and delta_angle is not None:\n            raise ValueError(\"Only one of repetitions or delta_",
    "in_left + min_right:\n                continue\n            if len(middle) > max_left + max_right:\n                continue\n            if len(prefix) + len(suffix) > max_prefix + max_suffix",
    "node, ast.AugAssign)",
    "olation_type == \"linear\":\n            curve = CurveGenerator.linear(control_nodes)\n        elif interpolation_type == \"linear_closed\"",
    "ddle",
    "ate_bounds:\n            self.update_curve_bounds(self.evaluate_curve_bounds(curve))\n        else",
    "eTransforms) > 0",
    "node, ast.Assign)",
    "s None",
    "yntax",
    "split_idx] == middle[split_idx:]:\n                    continue\n                if middle[split_idx - 1:split_idx] == middle[split_idx:split_idx + 1]:\n                    continue\n                if middle[split",
    " == 0",
    "(current, ast.Attribute)",
    "es_balance!= 0:\n            current_line += 1\n            if current_line >= len(lines):\n                break\n            parentheses_balance += 1 if lines[current_line][0] == ')' else -1 if lines[",
    "ode.func, ast.Name)",
    "in similarities",
    "xt_lines:\n                continue\n            if call['end_line'] + 1 > max_context_lines:\n                continue\n            if call['start_line'] - 1 < min_context_lines:\n                continue\n            if call['",
    "PlotType[i] == \"fill\"",
    "_persistent_paths",
    "rent, ast.Name)",
    "d right_side",
    "r graph[i][i] == 0:\n            continue\n        if not dfs(i):\n            swaps += 1\n    return swaps\n\n\ndef dfs(i):\n    global graph, visited\n    visited[i] = True\n   ",
    "unc, ast.Attribute)",
    "unds is None:\n            self.X_bounds = bounds[0]\n            self.Y_bounds = bounds[1]\n            self.Rho_bounds = bounds[2]\n        else",
    " min_context_lines + middle_line_count:\n            return []\n        middle_end = middle_start + middle_line_count\n        middle_lines = lines[middle_start:middle_end]\n        if len(middle_",
    "s None and delta_angle is None:\n            raise ValueError(\"Either repetitions or delta_angle must be specified\")\n        if repetitions is not None and delta_angle is not None:\n            raise ValueError(\"Only one of repetitions or delta",
    "ited[j]",
    "cters_per_line < len(lines[start_line])",
    " len(expected):\n            return None\n        total = defaultdict(float)\n        counts = defaultdict(int)\n        for i in range(length):\n            total[generated[i]] += 1\n            counts[generated[i]] += 1\n           ",
    "']) == 0:\n                continue\n            if call['start_line'] - 1 < 0 or num_lines - call['end_line'] < 0",
    "ure, Figure)",
    "m_lines - end_line < min_context_lines:\n            return None\n        if start_line < 0 or end_line >= num_lines:\n            return None\n        if start_idx < 0 or end_idx >",
    "ngth > 1",
    "_id not in regions:\n                continue\n            if neighbour_id not in regions",
    " == region2_id:\n            continue\n        if (region1_id, neighbour) in similarities:\n            del similarities[(region1_id, neighbour)]\n        elif (neighbour, region1_id) in similarities",
    ", ast.If):\n            condition = ast.get_source_segment(code, node.test)\n            start_line = node.test.lineno\n            start_col = node.test.col_offset\n            end_line = node",
    "urve:\n            curve = input_curve\n        else",
    "se",
    ".size == repetitions",
    "gments is None and angle is None:\n            repetitions = 1\n            delta_angle = None\n        elif number_of_segments is None and angle is not None:\n            repetitions = np.trunc(2*np.pi/angle",
    "ngle is None:\n            delta_angle = 2 * np.pi / repetitions\n            angle = None\n        elif repetitions is None",
    " 0",
    "[i] == \"line\"",
    "type == \"bezier\"",
    "curve == (np.array([[0.0, 0.0]]), 1, 0.5, 0.05, \"cartesian\") and outer_curve == (np.array([[0.0, ",
    "e2 == 'polar'",
    "_colors",
    "_side",
    "s not None:\n                    total[key] += value\n                    counts[key] += 1\n        averaged = {key: (total[key] / counts[key]) if counts[key] > 0 else None for key in total",
    "e"
]