[
    "\"\"\"\n        Generates a random edge in the grid.\n        :param grid_size:\n        :param grid_step:\n        :param interpolation_type:\n        :return:\n        \"\"\"\n        control_nodes = []\n        for i in range(2):\n            control_nodes.append(np.array([np.random.uniform(0, grid_size[i]), np.random.uniform(0, grid_size[i])]))\n        control_nodes = np.array(control_nodes)\n        if interpolation_type == \"bezier\":\n            curve = CurveGenerator.bezier(control_nodes)\n        elif interpolation_type == \"linear\":\n            curve = control_nodes\n        else:\n            curve = CurveTransforms.interpolate(control_nodes, 100, \"cubic\", False)\n        return curve\n\n    @staticmethod\n    def random_edge_",
    " outer_radius=0.05, theta=np.linspace(0, 2 * np.pi, segments + 1)) -> (np.ndarray, np.ndarray, np.ndarray, list):\n    \"\"\"\n    Creates a serrated ring arc.\n\n    :param image: The image to draw on.\n    :param dpu: The distance between pixels.\n    :param segments: The number of segments.\n    :param aligned: Whether the segments are aligned.\n    :param teeth_width: The width of the teeth.\n    :param inner_radius: The inner radius.\n    :param outer_radius: The outer radius.\n    :param theta: The theta values.\n    :return: The image, the extent, the path and the outline curves.\n    \"\"\"",
    "targets = [node.target]\n            value = node.annotation\n        else:",
    "results['rouge'] = self.rouge_score(generated, expected)",
    "for assignment in assignments:\n            result = extract_assignment_section(lines, assignment, max_characters, min_context_lines, max_context_lines)\n            if result:",
    "x_fine = np.linspace(curve[0, 0], curve[-1, 0], samples)\n        y_fine = np.interp(x_fine, curve[:, 0], curve[:, 1], kind=kind)",
    "    Figure.z_order += 1\n        for i in range(len(self.Curves)):\n            if self.PlotType[i] == \"line\":\n                ax.plot(self.Curves[i][:, 0], self.Curves[i][:, 1], color=\"k\", solid_capstyle='round',\n                         linewidth=self.PlotType[i], zorder=self.z_order)",
    "extent = (inner_radius, outer_radius, width)\n        path = Path.ring(inner_radius, outer_radius, width, segments, sample_rotation)\n        image_sliced = ImageSlicer.slice_path(image, path, dpu,",
    "Transformer.scale_curves(new_curves, scale)\n            curves.extend(new_curves)\n        for y in range(1, y_repetitions):",
    "self.X = None\n        self.Y = None\n        self.Rho = None\n        self.Theta = None",
    "ax.fill(self.Curves[i][:, 0], self.Curves[i][:, 1], color=\"w\", zorder=self.z_order)\n                ax.plot(self.Curves[i][:, 0], self.Curves[i][:, 1], color=\"k\", solid_capstyle='round',",
    "func_name = node.func.id\n        elif isinstance(node.func, ast.Attribute):\n            parts = []",
    "self.Extent = extent\n        self.MainClipPath = main_clip_path",
    "scales = scale*np.ones(repetitions)",
    "function_call['start_line'],\n            function_call['start_idx'],\n            function_call['end_idx'],",
    "clip_ar = image_ar / (x_abs / dpu)\n        if clip_ar > 1:\n            new_height = int(new_width / clip_ar)",
    "rho = (curve_cartesian[:, 1] - y_bounds[0]) / (y_bounds[1] - (y_bounds[0])) * (rho_bounds[1] - rho_bounds[0]) + rho_bounds[0]\n        if x_bounds[0] == x_bounds[1]:",
    "function_call['start_idx'],\n            function_call['end_idx']\n        )",
    "results = {}",
    "curve1 = CurveTransforms.tight_remap_polar_to_polar(curve1, (radius1, radius1+width1), (theta1, theta1 + (theta2-theta1)/periods1))\n                curve1 = CurveTransforms.polar_to_cartesian(curve1)\n            else:",
    "if clip_ar > image_ar:\n            new_height = np.minimum(int(np.minimum(height, y_abs*dpu)), height-1)\n            new_width = int(new_height * clip_ar)",
    "dataset_name = f'{dataset_type}_{max_value}_{max_context}'\n                examples = []\n                for block in code_blocks:",
    "                   global_rotation, half, left_edge, right_edge)\n        image_sample = ImageSample(image_sliced, extent, path, outline_curves, segments, pits_per_segment, dpu,",
    "if start_pos[0] < 0 or start_pos[0] >= num_lines or start_pos[1] < 0 or start_pos[1] > len(lines[start_pos[0]]):\n            return None\n        if end_pos[0] < 0 or end_pos[0] >= num_lines or end_pos[1] < 0 or end_pos[1] > len(lines[end_pos[0]]):\n            return None\n        start_line, start_idx = start_pos\n        end_line, end_idx = end_pos\n        if start_line == end_line and start_idx == end_idx:",
    "self.MainClipPath = main_clip_path",
    "'image': image[region_mask],\n            'centroid': np.array(region_mask.nonzero()).mean(axis=1),\n            'area': region_mask.sum(),\n            'bbox': region_mask.nonzero(),\n            'bbox_area': region_mask.sum(),\n            'bbox_centroid': np.array(region_mask.nonzero()).mean(axis=1),\n            'bbox_area_ratio': region_mask.sum() / (region_mask.shape[0] * region_mask.shape[1]),\n            'bbox_centroid_ratio': np.array(region_mask.nonzero()).mean(axis=1) / region_mask.shape,\n            'bbox_centroid_ratio_area': np.array(region_mask.nonzero()).mean(axis=1) / (region_",
    "y2 = np.max(curve[:, 1])\n        x_abs = x2 - x1",
    "self.X_bounds = bounds[0]\n            self.Y_bounds = bounds[1]\n            self.Rho_bounds = bounds[2]",
    "'color_histogram': histogram_intersection(region1_info['color_histogram'],",
    "repetitions = 1\n            angle = delta_angle\n        elif delta_angle is None:",
    "else:\n            repetitions = np.maximum(1, int(np.trunc(2 * np.pi / delta_angle)))\n            angle = None",
    "condition = ast.get_source_segment(code, node.test)\n            start_line = node.test.lineno\n            start_col = node.test.col_offset",
    "\n        if dataset_type == 'random_split':\n            for random_split_name in ['train', 'val', 'test']:\n                for block in code_blocks:\n                    examples_split = extract_method(block, max_value, max_context)\n                    if examples_split:",
    "scales = scale\n        else:\n            raise ValueError(\"scale must be a scalar or a vector of length 1, 2 or %d\" % repetitions)",
    "code_blocks: List[str],\n        max_values: List[int],\n        max_context_lines: List[int],",
    "else:\n            rho = (curve_cartesian[:, 1] - y_bounds[0]) / (y_bounds[1] - (y_bounds[0])) * (rho_bounds[1] - rho_bounds[0]) + rho_bounds[0]",
    "code_blocks,",
    "else:\n            scales = scale\n        for i in range(repetitions):\n            Transformer.rotate_curves(curves, i*angle)\n            Transformer.scale_curves(curves, scales[i])\n\n\nclass Transformer:\n    @staticmethod\n    def rotate_curves(curves: \"list\", angle):\n        for curve in curves:\n            curve.rotate(angle)\n\n    @staticmethod\n    def scale_curves(curves: \"list\", scale):\n        for curve in curves:\n            curve.scale(scale)\n\n    @staticmethod\n    def repeat_curves(curves: \"list\", number_of_segments=None, delta_angle=None, scale=1.0):\n        if number_of_segments is None and delta_angle is None:\n            repetitions = 1\n            angle = None\n        elif",
    "curve1 = CurveTransforms.tight_map_cartesian_to_polar(curve1, (radius1, radius1+width1), (theta1, theta1 + (theta2-theta1)/periods1))\n                curve1 = CurveTransforms.polar_to_cartesian(curve1)\n        if outer_curve is None:\n            curve2 = np.array([[0, 0]])\n        else:",
    "if local_outline_curves is not None:",
    "    ax.plot(self.Curves[i][:, 0], self.Curves[i][:, 1], color=\"k\", solid_capstyle='round',\n                         linewidth=self.PlotType[i], zorder=self.z_order)\n            elif self.PlotType[i] > 0:\n                ax.fill(self.Curves[i][:, 0], self.Curves[i][:, 1], color=\"w\", zorder=self.z_order)",
    "curve = np.vstack((curve1, curve2))\n        if left_side and right_side:",
    "if outer_curve is None:\n            curve2 = np.array([[0, 0]])\n        else:\n            (curve2, periods2, radius2, width2, coordinate_type2) = outer_curve\n            if coordinate_type2 == \"polar\":\n                curve2 = CurveTransforms.tight_remap_polar_to_polar(curve2, (radius2, radius2+width2), (theta1, theta1 + (theta2-theta1)/periods2))",
    "return self.extract_code_blocks(\n            code_blocks,",
    "delta_angle = 2 * np.pi / repetitions",
    "diamonds = []\n        for x in np.arange(x_bounds[0], x_bounds[1], x_delta):\n            for y in np.arange(y_bounds[0], y_bounds[1], y_delta):\n                diamonds.append(Curve([\n                    (x, y),\n                    (x + x_delta, y + y_delta),\n                    (x + x_delta, y + y_delta + y_delta),\n                    (x, y + y_delta + y_delta),\n                    (x, y + y_delta)\n                ]))",
    "repetitions = 1\n            angle = None\n        elif number_of_segments is None:",
    "\"\"\"\n        Creates a ring of pits.\n\n        :param image: The image to be sliced.\n        :param dpu: The distance between pits in microns.\n        :param segments: The number of segments in the ring.\n        :param pits_per_segment: The number of pits in each segment.\n        :param inner_radius: The inner radius of the ring in microns.\n        :param outer_radius: The outer radius of the ring in microns.\n        :param width: The width of the pits in microns.\n        :param depth: The depth of the pits in microns.\n        :param gap: The gap between the pits in microns.\n        :param sample_rotation: The rotation of the sample in radians.\n        :param global_rotation: The rotation",
    "regions = {}\n    for id in np.unique(mask):",
    "image_sample = ImageSample(image)\n        ImageSampleTransformer.rotational_repeat_additive(image_sample, segments, None, rotation_offset=sample_rotation, use_flip=True, flip_angle=(sample_rotation + np.pi / segments) / 2)\n        ImageSampleTransformer.rotational_repeat_additive(image_sample, segments, None, rotation_offset=sample_rotation + np.pi, use_flip=True, flip_angle=(sample_rotation + np.pi + np.pi / segments) / 2)\n        ImageSampleTransformer.rotational_repeat_additive(image_sample, segments, None, rotation_offset=sample_rotation + 2 * np.pi, use_flip=True, flip_angle=(sample_rotation + 2 * np"
]