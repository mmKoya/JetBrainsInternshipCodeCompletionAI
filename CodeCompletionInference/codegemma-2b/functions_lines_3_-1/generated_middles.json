[
    "control_nodes = []\n        for i in range(grid_size[0]):\n            for j in range(grid_size[1]):\n                control_nodes.append(np.array([i*grid_step[0], j*grid_step[1]]))",
    "outer_radius=0.05, aligned=True, teeth_width=0.05, inner_radius=0.0, outer_radius=0.05,\n                          aligned=True, teeth_width=0.05, inner_radius=0.0, outer_radius=0.05,\n                          aligned=True, teeth_width=0.05, inner_radius=0.0, outer_radius=0.05,\n                          aligned=True, teeth_width=0.05, inner_radius=0.0, outer_radius=0.05,\n                          aligned=True, teeth_width=0.05, inner_radius=0.0, outer_radius=0.05,\n                          aligned=True, teeth_width=0.05, inner_radius=0.0, outer_radius=0.05,\n",
    "targets = [node.target]\n            value = node.annotation\n        else:",
    "results['exact_match_score'] = self.exact_match_score(generated, expected)\n        results['bleu'] = self.bleu_score(generated, expected)\n        results['rouge'] = self.rouge_score(generated, expected)",
    "for assignment in assignments:\n            assignment_lines = lines[assignment[0]:assignment[1]]\n            if len(assignment_lines) < min_context_lines:\n                continue\n            if max_context_lines > 0 and len(assignment_lines) > max_context_lines:\n                continue\n            result = (\n                assignment_lines[0],\n                assignment_lines[-1],\n                \"\\n\".join(assignment_lines[1:-1]),\n            )\n            if len(result[2]) > max_characters:\n                result = (\n                    result[0],\n                    result[1],\n                    result[2][:max_characters] + \"...\",\n                )",
    "x_fine = np.linspace(curve[0, 0], curve[1, 0], samples)\n        y_fine = np.linspace(curve[0, 1], curve[1, 1], samples)",
    "for i in range(len(self.Curves)):\n            if self.PlotType[i] == \"line\":\n                ax.plot(self.Curves[i][:, 0], self.Curves[i][:, 1], color=\"k\", solid_capstyle='round',\n                         linewidth=1.0, zorder=self.z_order)",
    "\"\"\"\n        :param image:\n        :param dpu:\n        :param segments:\n        :param inner_radius:\n        :param outer_radius:\n        :param width:\n        :param sample_rotation:\n        :return:\n        \"\"\"\n        path = Path(image.path)\n        extent = Extent(path.parent, path.stem, path.suffix, path.name, path.parent.name, path.parent.stem,\n                        path.parent.suffix, path.parent.name, path.parent.parent.name, path.parent.parent.stem,\n                        path.parent.parent.suffix, path.parent.parent.name, path.parent.parent.parent.name,\n                        path.parent.parent.parent.stem, path.parent.parent.parent.suffix, path.parent.parent.parent.name,\n                        path.parent.parent.",
    "curves.extend(new_curves)",
    "self.X = None\n        self.Y = None\n        self.Rho = None\n        self.Theta = None",
    "ax.fill(self.Curves[i][:, 0], self.Curves[i][:, 1], color=\"k\", solid_capstyle='round',",
    "parts = [node.func.id]\n        else:\n            parts = []",
    "self.Extent = extent\n        self.MainClipPath = main_clip_path",
    "scales = np.array([scale]*repetitions)",
    "lines[function_call['start_line'] - 1],\n            function_call['start_idx'],\n            function_call['end_idx'],",
    "clip_ar = image_ar / (x_abs / y_abs)\n        if clip_ar > 1:\n            new_height = np.minimum(int(np.minimum(height, y_abs*dpu)), height-1)",
    "rho = (curve_cartesian[:, 1] - y_bounds[0]) / (y_bounds[1] - (y_bounds[0])) * (rho_bounds[1] - rho_bounds[0]) + rho_bounds[0]\n        if x_bounds[0] == x_bounds[1]:",
    "function_call['start_idx'],\n            function_call['end_idx'],\n        )",
    "results = {}\n        results['accuracy'] = self.accuracy_score(generated, expected)",
    "curve1 = CurveTransforms.tight_remap_polar_to_polar(curve1, (radius1, radius1+width1), (theta1, theta1 + (theta2-theta1)/periods1))",
    "if clip_ar > image_ar:\n            new_height = np.minimum(int(np.minimum(height, y_abs*dpu)), height-1)\n            new_width = int(new_height * clip_ar)",
    "for block in code_blocks:\n                    dataset_name = f'{dataset_type}_{max_value}_{max_context}'\n                    examples = []",
    "                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ",
    "if start_pos[0] < 0 or start_pos[1] < 0 or end_pos[0] < 0 or end_pos[1] < 0 or start_pos[0] >= num_lines or start_pos[1] >= num_lines or end_pos[0] >= num_lines or end_pos[1] >= num_lines:\n            return None\n        if start_pos[0] > end_pos[0] or start_pos[1] > end_pos[1]:\n            return None\n        if start_pos[0] == end_pos[0] and start_pos[1] == end_pos[1]:\n            return None\n        if start_pos[0] == end_pos[0] and start_pos[1] == end_pos[1] - 1:\n            return None\n        if start_",
    "self.MainClipPath = main_clip_path",
    "'image': image[region_mask],\n            'label': id",
    "y2 = np.max(curve[:, 1])\n        x_abs = x2 - x1",
    "self.X_bounds = bounds[0]\n            self.Y_bounds = bounds[1]\n            self.Rho_bounds = bounds[2]",
    "'color_histogram': np.concatenate((region1_info['color_histogram'],",
    "repetitions = 1\n            angle = delta_angle\n        elif delta_angle is None:",
    "else:\n            repetitions = np.maximum(1, repetitions)\n            angle = 2 * np.pi / repetitions",
    "condition = ast.get_source_segment(code, node.test)\n            start_line = node.test.lineno\n            start_col = node.test.col_offset",
    "random_split_name = f'{dataset_name}_random_split'\n                    examples_split = []\n                    for example in examples:\n                        examples_split.append(example)\n                        if len(examples_split) >= 1000:\n                            datasets.append((random_split_name, examples_split))\n                            examples_split = []",
    "scales = scale\n        else:\n            raise ValueError(\"scale must be a scalar, a 1D array of length repetitions, or a 2D array of shape (repetitions, 2)\")",
    "    code_blocks: List[str],\n        max_values: List[int],\n        max_context_lines: List[int],",
    "else:\n            rho = (curve_cartesian[:, 1] - y_bounds[0]) / (y_bounds[1] - (y_bounds[0])) * (rho_bounds[1] - rho_bounds[0]) + rho_bounds[0]",
    "code_blocks,\n            max_characters,\n            max_context_lines,",
    "elif scale.size == repetitions:",
    "curve1 = CurveTransforms.tight_map_cartesian_to_polar(curve1, (radius1, radius1+width1), (theta1, theta1 + (theta2-theta1)/periods1))\n        curve1 = CurveTransforms.polar_to_cartesian(curve1)\n        curve1 = np.flip(np.vstack([CurveTransforms.rotate_single(curve1, i*(theta2-theta1)/periods1, inplace=False) for i in range(0, periods1)]), 0)",
    "if local_outline_curves is not None:",
    "elif self.PlotType[i] > 0:",
    "if right_side:",
    "if outer_curve is None:\n            curve2 = np.array([[0, 0]])\n        else:\n            (curve2, periods2, radius2, width2, coordinate_type2) = outer_curve\n            if coordinate_type2 == \"polar\":\n                curve2 = CurveTransforms.tight_remap_polar_to_polar(curve2, (radius2 - width2, radius2), (theta1, theta1 + (theta2-theta1)/periods2))\n                curve2 = CurveTransforms.polar_to_cartesian(curve2)",
    "return CodeSegmentExtractor.extract_code_segments(\n            code_blocks,\n            max_characters,",
    "delta_angle = 2 * np.pi / repetitions",
    "diamonds = []\n        for x in np.linspace(x_bounds[0], x_bounds[1], subdivisions[0]):\n            for y in np.linspace(y_bounds[0], y_bounds[1], subdivisions[1]):\n                diamonds.append(Curve(x, y))",
    "raise ValueError(\"Either number_of_segments or delta_angle must be specified\")\n        if number_of_segments is None:",
    "\"\"\"\n        :param image:\n        :param dpu:\n        :param segments:\n        :param pits_per_segment:\n        :param inner_radius:\n        :param outer_radius:\n        :param width:\n        :param depth:\n        :param gap:\n        :param sample_rotation:\n        :param global_rotation:\n        :param half:\n        :param left_edge:\n        :param right_edge:\n        :return:\n        \"\"\"\n        image_sliced = image.slice(dpu)\n        extent = Extent(inner_radius, outer_radius, width, depth, gap, half, left_edge, right_edge)\n        path = Path(pits_per_segment, inner_radius, outer_radius, width, depth, gap, half, left_edge, right_edge)\n        outline_curves = OutlineCurves(pits_",
    "regions = {}\n    for id in range(1, mask.max() + 1):",
    "\"\"\"\n        Generates a sine wave ring image sample.\n\n        Parameters\n        ----------\n        image : ImageSample\n            The image sample to modify.\n        dpu : float\n            The distance per unit of the image.\n        segments : int\n            The number of segments to divide the image into.\n        periods_per_segment : int\n            The number of periods per segment.\n        period_offset : float\n            The offset of the period.\n        inner_radius : float\n            The inner radius of the ring.\n        outer_radius : float\n            The outer radius of the ring.\n        amplitude : float\n            The amplitude of the sine wave.\n        sample_rotation : float\n            The rotation of the sample.\n\n        Returns\n        -------\n        ImageSample\n            The modified image sample.\n        \"\"\"\n        # Calculate the period and offset\n        period = dpu * periods_per_segment\n"
]