[
    "(CurveGenerator.bezier(np.array([[0, 0], [0, 1], [1, 1], [1, 2]])), 1, inner_radius, width, \"cartesian\")",
    "CurveTransforms.translate_single(arc, start, 0, False)",
    "ImageSample(image_sliced, extent, path, outline_curves)",
    "[]",
    "source_code\n        self.variables = {}\n        self.functions = {}",
    "min(num_lines - 1, end_line + (max_context_lines if max_context_lines >= 0 else num_lines - end_line - 1))",
    "CodeBlockExtractor()",
    "CurveTransforms.tight_map_cartesian_to_polar(curve2, (radius2 - width2, radius2), (theta1, theta1 + (theta2-theta1)/periods2))",
    "bounds[1]",
    "parse(code)",
    "np.minimum(int(np.minimum(height, y_abs*dpu)), height-1)",
    "bounds[0]",
    "nltk.word_tokenize(expected)",
    "control_nodes\n        elif interpolation_type == \"catmull\":\n            curve = control_nodes",
    "min(num_lines, call['end_line'] + 1 + (max_context_lines if max_context_lines >= 0 else num_lines - call['end_line']))",
    "np.array(perm)\n  ",
    "image_to_path(image, outline_curves, dpu)",
    "[]",
    "np.histogram(region[:, 2], range=(0.0, 1.0), bins=n_bins)",
    "1",
    "CurveGenerator.draw_curve(image, curve, dpu, inner_radius, outer_radius, theta1, theta2)",
    "[]",
    "np.trunc(2 * np.pi / delta_angle)",
    "0",
    "None",
    "node.value.test.end_lineno",
    "self.model.predict([expected, generated])",
    "np.abs(x_bounds[0] - x_bounds[1]) / subdivisions[0]",
    "nltk.word_tokenize(generated)",
    "affine.transform(curve)",
    "i",
    "local_outline_curves",
    "curve.T",
    "np.zeros_like(curves[0])\n        for i in range(len(curves)):\n            curve += curves[i]",
    "[]",
    "self.chrf_score(generated, expected)\n        results['cer'] = self.cer_score(generated, expected)",
    "np.maximum(1, delta_angle)",
    "'\\n'.join(lines[start:start_line])",
    "[]",
    "1 if char == '(' else -1",
    "fill_curve(image, outline_curves, dpu)",
    "outer_curve",
    "spline(t_fine)",
    "np.array([[0.0, 0.0]])\n        elif isinstance(inner_curve, np.ndarray):\n            curve1 = inner_curve\n            if len(curve1.shape) == 1:\n                curve1 = np.vstack((curve1, curve1))\n            if curve1.shape[1]!= 2:\n                raise ValueError(\"Inner curve must be a 2D array of shape (n, 2)\")\n            if curve1.shape[0] == 0:\n                raise ValueError(\"Inner curve must have at least one point\")\n            if curve1[0, 0] == 0.0 and curve1[0, 1] == 0.0:\n                raise ValueError(\"Inner curve must not start at (0, 0)\")",
    "x",
    "1",
    "np.vstack((values, result)).T",
    "values",
    "current.value",
    "[]\n        self.X_data = []\n        self.Y_data = []\n        self.Rho_data = []\n        self.Theta_data = []\n        self.X_data_plot = []\n        self.Y_data_plot = []\n        self.Rho_data_plot = []\n        self.Theta_data_plot = []\n        self.X_data_plot_plot = []\n        self.Y_data_plot_plot = []\n        self.Rho_data_plot_plot = []\n        self.Theta_data_plot_plot = []"
]