[
    "ast.Assign",
    "d, region2_id",
    " curve2)",
    "Curves",
    "Theta_bounds[0], bounds[3][0]",
    " (radius2 - width2, radius2), (theta1, theta1 + (theta2-theta1)/periods2)",
    "[:, 0]",
    "heta)",
    "nt, path, outline_curves",
    "ze, interpolation",
    "], -old_y_bounds[0]",
    "urves)",
    " rotation_offset",
    "ters, min_context_lines, max_context_lines",
    "offset) * freq",
    "o['neighbors']",
    "riods2)",
    "width/2, width/2, 0, 0)",
    "_text, suffix)",
    " segments, radius, height, left_edge, right_edge)",
    "curves",
    "tart_col), (end_line, end_col))",
    "0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, ",
    "rves)",
    "0], -pivot[1]",
    "size[1] + 1",
    "_points",
    "t.AnnAssign",
    ", 0.5, 0.5), 0)))\n        else:\n            curve = np.vstack((curve, np.flip(CurveTransforms.scale_single(curve, 0.5, 0.5",
    "tions",
    "tesian[:, 0]",
    "sistent_paths",
    "urves)",
    "(curve, 0.5, 1, 1), 0",
    " extent, path, outline_curves",
    " theta2, n",
    "tesian[:, 1]",
    "PersistentTransforms",
    "_sample.PersistentTransforms",
    ", expected",
    "cartesian[:, 1]",
    "angle",
    " segments + 1",
    "_code",
    "iods1",
    "nc, ast.Name",
    "0, 1, 100)",
    "angle).translate(radius, 0).rotate(i * angle + global_rotation_offset",
    " expected",
    "rves)"
]