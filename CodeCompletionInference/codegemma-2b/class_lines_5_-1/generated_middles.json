[
    "raise ValueError(\"Number of segments and delta angle cannot be None at the same time\")\n        elif number_of_segments is None:\n            repetitions = np.maximum(1, delta_angle/2/np.pi)\n            angle = delta_angle/repetitions",
    "y_values = values\n            x_values = np.array([function(y) for y in y_values])\n            curve = np.vstack((x_values, y_values)).T\n        else:\n            print(\"Invalid input_coordinate, curve will default to 0,0\")\n            curve = np.array([[0.0, 0.0]])\n        if polar:\n            curve = CurveTransforms.polar_to_cartesian(curve)\n        result = np.array([])\n        for i in range(curve.shape[1]):\n            result = np.append(result, np.linspace(curve[0, i], curve[1, i], 100))\n        if result.shape[0] == 1:\n            result = np.array([result])",
    "return CurveTransforms.apply_affine_multi(curves, transform, inplace)\n    @staticmethod\n    def translate_single(curve: np.ndarray, x=0.0, y=0.0, inplace=True) -> np.ndarray:\n        transform = Affine2D().translate(x, y)\n        return CurveTransforms.apply_affine_single(curve, transform, inplace)",
    "\"func_name\": func_name,\n                \"args\": args,\n                \"start_line\": node.lineno,\n                \"start_col_offset\": node.col_offset,\n                \"end_line\": node.end_lineno,",
    "if left_side:",
    "return image, extent, path, outline_curves",
    "(segments, aligned) = CurveTransforms.segment_curve(curve)",
    "curve = np.vstack((curve, np.flip(CurveTransforms.scale_single(curve, (-1, 1), inplace=False), 0)))\n        return curve\n    @staticmethod\n    def grid(grid_size=(10, 10), grid_step=(1, 1), interpolation_type=\"bezier\"):\n        control_nodes = []\n        control_nodes.append([0, 0])\n        control_nodes.append([grid_size[0] * grid_step[0], 0])\n        control_nodes.append([grid_size[0] * grid_step[0], grid_size[1] * grid_step[1]])\n        control_nodes.append([0, grid_size[1] * grid_step[1]])",
    "func_name = current.id\n            else:\n                raise ValueError(\"Invalid attribute\")\n        args = []\n        for arg in node.args:\n            if isinstance(arg, ast.Str):\n                args.append(arg.s)\n            elif isinstance(arg, ast.Num):\n                args.append(arg.n)\n            elif isinstance(arg, ast.Name):\n                args.append(arg.id)\n            else:\n                raise ValueError(\"Invalid argument\")\n        self.function_calls.append({",
    "function = lambda x: np.dot(nodes, np.vstack((x, 1)).T)\n        input_coordinate = \"x_input\"",
    "curves[i][:, 0] = -curves[i][:, 0]\n    @staticmethod\n    def flip_vertical(curves):\n        for i in range(len(curves)):\n            curves[i][:, 1] = -curves[i][:, 1]",
    "self.function_calls.append({\n                \"func_name\": func_name,\n                \"args\": args,\n                \"lineno\": node.lineno,\n                \"col_offset\": node.col_offset,\n                \"end_col_offset\": node.end_col_offset\n            })\n        self.generic_visit(node)\n    def visit_Attribute(self, node):\n        func_name = None\n        if isinstance(node.value, ast.Name):\n            func_name = node.value.id\n        elif isinstance(node.value, ast.Attribute):\n            parts = []\n            current = node.value\n            while isinstance(current, ast.Attribute):\n                parts.insert(0, current.attr)\n                current = current.value\n            if isinstance(current, ast.Name):\n                parts.insert(0, current.id)\n            func",
    "for dataset_name, examples in extract_method(code_blocks, max_value, max_context):",
    "def evaluate_curve_bounds(self, curve):\n        x_bounds = (np.min(curve[:, 0]), np.max(curve[:, 0]))\n        y_bounds = (np.min(curve[:, 1]), np.max(curve[:, 1]))\n        rho = np.sqrt(x_bounds[1]**2 + y_bounds[1]**2)\n        theta = np.arctan2(y_bounds[1], x_bounds[1])",
    "def fit_polar(curve, extent):\n        rho_bounds = (np.min(curve[:, 0]), np.max(curve[:, 0]))\n        theta_bounds = (np.min(curve[:, 1]), np.max(curve[:, 1]))\n        return CurveTransforms.remap_polar_to_polar(curve, rho_bounds, theta_bounds, extent[0:2], extent[2:4])\n    @staticmethod\n    def fit_polar_to_c2c(curve, extent):\n        rho_bounds = (np.min(curve[:, 0]), np.max(curve[:, 0]))\n        theta_bounds = (np.min(curve[:, 1]), np.max(curve[:, 1]))\n        return CurveTransforms.remap_polar_to_c2c(curve, rho_bounds, theta_bounds, extent[0:2],",
    "if isinstance(figure, Figure):\n            new_figure = Figure()\n            new_figure.append_figure(self)\n            new_figure.append_figure(figure)\n            return new_figure\n        else:",
    "   local_rotation_offset=0.0,",
    "transform = Affine2D().translate(x, y)\n        return CurveTransforms.apply_affine_multi(curves, transform, inplace)\n    @staticmethod\n    def scale_single(curve: np.ndarray, scale=(1.0, 1.0), pivot=(0.0, 0.0), inplace=True) -> np.ndarray:\n        transform = Affine2D().translate(-pivot[0], -pivot[1]).scale(scale[0], scale[1]).translate(pivot[0], pivot[1])",
    "@staticmethod\n    def translate_multi(curves: List[np.ndarray], x=0.0, y=0.0, inplace=True) -> List[np.ndarray]:\n        transform = Affine2D().translate(x, y)\n        return CurveTransforms.apply_affine_multi(curves, transform, inplace)\n    @staticmethod",
    "interpolated_curve = np.zeros((2, samples))\n        if kind == \"cubic\":\n            interpolated_curve = np.interp(np.linspace(0, 1, samples), np.linspace(0, 1, curve.shape[1]), curve.T).T\n        elif kind == \"linear\":\n            interpolated_curve = np.interp(np.linspace(0, 1, samples), np.linspace(0, 1, curve.shape[1]), curve.T).T\n        else:\n            raise ValueError(\"Invalid interpolation kind\")\n        if inplace:",
    "def custom_rect_bounded(image, curve, dpu=1000.0):",
    "outline_curves = [curve1, curve2]",
    "return 12",
    "if self.PlotType[i] > 0:\n                ax.fill(self.Curves[i][:, 0], self.Curves[i][:, 1], color=\"k\", zorder=self.z_order)",
    "def translate_single(curve: np.ndarray, x=0.0, y=0.0, inplace=True) -> np.ndarray:\n        transform = Affine2D().translate(x, y)\n        return CurveTransforms.apply_affine_single(curve, transform, inplace)\n    @staticmethod\n    def translate_multi(curves: List[np.ndarray], x=0.0, y=0.0, inplace=True) -> List[np.ndarray]:",
    "np.maximum(self.X_bounds[1], bounds[0][1]))\n            self.Y_bounds = (np.minimum(self.Y_bounds[0], bounds[1][0]),\n                             np.maximum(self.Y_bounds[1], bounds[1][1]))\n            self.Rho_bounds = (np.minimum(self.Rho_bounds[0], bounds[2][0]),\n                               np.maximum(self.Rho_bounds[1], bounds[2][1]))",
    "x1, x2, y1, y2 = extent",
    "self.classes = []\n    def visit_FunctionDef(self, node):\n        function_source = ast.get_source_segment(self.code, node)\n        self.functions.append(function_source)\n        self.generic_visit(node)",
    "if reverse_rotation:\n            angle = -angle",
    "curve = copy.deepcopy(curves[0])\n        for i in range(1, len(curves)):\n            curve = np.vstack((curve, curves[i]))\n        curve.resize((2, curve.shape[1]), refcheck=False)\n        curves.clear()\n        curves.append(curve)\n    @staticmethod\n    def reverse_curve(curve):\n        curve.resize((2, curve.shape[1]), refcheck=False)\n        curve[:] = np.flip(curve, 0)",
    "image_sample.PersistentTransforms.extend(new_persistent_transforms)\n    @staticmethod\n    def circular_placement_persistent(image_sample: ImageSample, radius=0.5, repetitions: int = None, delta_angle: float = None, local_rotation_offset=0.0,\n                                      global_rotation_offset=0.0, use_flip=False, flip_angle=0.0, reverse_rotation=False, calculate_overlap=False):\n        persistent_transforms = TransformsGenerator.circular_placement(radius, repetitions, delta_angle, local_rotation_offset,\n                                                                       global_rotation_offset, use_flip, flip_angle, reverse_rotation)\n        persistent_paths = []\n        for i in range(len(image_sample.PersistentTransforms)):\n            persistent_paths.append(image_sample.PersistentClipPaths[i])\n        image_sample",
    "return image, extent, path, outline_curves",
    "def gear_ring(image, dpu=1000.0, segments=8, inner_radius=0.5, outer_radius=0.8, sample_rotation=0.0, global_rotation=0.0):",
    "def __add__(self, figure: \"Figure\"):\n        new_figure = Figure()\n        if isinstance(figure, Figure):\n            new_figure.append_figure(self)\n            new_figure.append_figure(figure)",
    "outline_curves = [curve1]",
    "def extract_function_examples(block: str, max_lines: int = 10, min_context_lines: int = 1, max_context_lines: int = -1) -> List[Tuple[str, str, str]]:\n        \"\"\"Extract function examples with specified context and line count limitations.\"\"\"\n        lines = block.splitlines()\n        num_lines = len(lines)\n        if num_lines <= max_lines:\n            return []\n        middle_line_count = max_lines - min_context_lines - 1\n        if num_lines - middle_line_count < min_context_lines:",
    "lines = block.splitlines()\n        examples = []\n        for start_pos, end_pos in assignments:\n            result = CodeSegmentExtractor.extract_section(lines, start_pos, end_pos, max_characters, min_context_lines, max_context_lines)\n            if result:",
    "transformed_curve = affine.transform(curve)\n            return transformed_curve\n    @staticmethod\n    def apply_affine_multi(curves: List[np.ndarray], affine: Affine2D, inplace=True) -> List[np.ndarray]:\n        if inplace:\n            for i in range(len(curves)):",
    "targets = node.targets\n            value = node.value",
    "split_idx = random.randint(min_left, len(middle) - min_right)\n            prefix = prefix + middle[:split_idx]\n            suffix = middle[split_idx:] + suffix",
    "rho = radius * np.ones(n)\n        curve = CurveTransforms.polar_to_cartesian(np.vstack((rho, theta)).T)\n        CurveTransforms.translate_single(curve, offset[0], offset[1], inplace=True)\n        return curve",
    "new_curves = copy.deepcopy(base_curves)\n            curves.extend(new_curves)\n    @staticmethod\n    def translation_repeat_figure(figure: \"Figure\", repetitions=(2, 2), step=(0.1, 0.1), scale=1.0):\n        Transformer.translation_repeat_curves(figure.Curves, repetitions, step, scale)\n        figure.evaluate_bounds()\n    @staticmethod\n    def reverse_figure(figure: \"Figure\"):\n        Transformer.reverse_curves(figure.Curves)\n        figure.evaluate_bounds()\n    @staticmethod\n    def reverse_figure_curves(curves: \"list\"):\n        for i in range(len(curves)):\n            Transformer.reverse_curve(curves[i])\n    @staticmethod\n    def reverse_figure_bounds(figure: \"Figure\"):\n        figure.evaluate_bounds()\n    @staticmethod\n",
    "self.Image = image\n    def update_clip_path(self, clip_path):\n        self.PersistentClipPaths.append(clip_path)\n    def update_transform(self, transform):\n        self.PersistentTransforms.append(transform)",
    "curve = np.vstack((x_values, y_values)).T\n        return curve\n    @staticmethod\n    def circular_arc(n=100, radius=0.5, theta1=0.0, theta2=np.pi, offset=(0.0, 0.0)):\n        theta = np.linspace(theta1, theta2, n)\n        rho = radius",
    "curve1 = np.array([[0, 0]])",
    "try:\n            chrf_score = chrf_score(generated, expected)\n            return chrf_score\n        except Exception as e:\n            print(f\"Error calculating CHRF score: {e}\")\n            return None",
    "value = node.annotation\n        else:\n            raise ValueError('Unsupported node type: {}'.format(type(node)))\n        start_line = node.lineno\n        end_line = node.end_lineno",
    "self.AdditionalCurves.append(curve)\n    def add_additional_curves(self, curves):\n        self.AdditionalCurves.extend(curves)\n    def add_persistent_clip_path(self, clip_path, transform):\n        self.PersistentClipPaths.append(clip_path)\n        self.PersistentTransforms.append(transform)\n    def add_persistent_clip_paths(self, clip_paths, transforms):\n        self.PersistentClipPaths.extend(clip_paths)\n        self.PersistentTransforms.extend(transforms)",
    "def interpolate_curve(curve, samples=100, inplace=True):\n        if len(curve.shape) == 1:\n            curve = curve.reshape((1, curve.shape[0]))\n        x = curve[0]\n        y = curve[1]\n        x_new = np.linspace(np.min(x), np.max(x), samples)\n        y_new = np.interp(x_new, x, y)\n        interpolated_curve = np.vstack((x_new, y_new)).T\n        if len(interpolated_curve.shape) == 1:\n            interpolated_curve = interpolated_curve.reshape((1, interpolated_curve.shape[0]))",
    "if i % 2 == 0 or not use_flip:\n                trans_data = Affine2D().rotate(rotation_offset).translate(0, delta_angle * i).rotate(delta_angle * i + rotation_offset)\n            else:\n                trans_data = Affine2D().rotate(-flip_angle).scale(1, -1).rotate(flip_angle + rotation_offset).translate(0, delta_angle * i).rotate(delta_angle * i + rotation_offset)\n            transforms.append(trans_data)"
]