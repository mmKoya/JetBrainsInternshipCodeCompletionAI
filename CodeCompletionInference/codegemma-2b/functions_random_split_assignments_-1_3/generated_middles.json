[
    "ments(block, max_characters, min_context_lines, max_context_lines)",
    "um(1, repetitions)\n            delta_angle = 2 * np.pi / repetitions",
    "x_bounds[0] - x_bounds[1]) / subdivisions[0]",
    "alue\n        elif isinstance(node, ast.Assign):\n            targets = node.targets\n            value = node.value\n        elif isinstance(node, ast.AugAssign):\n            targets = [node.target]\n            value = node.value\n        elif isinstance(node, ast.BinOp):\n            targets = [node.left, node.right]\n            value = node.op\n        elif isinstance(node, ast.BoolOp):\n            targets = [node.values]\n            value = node.op\n        elif isinstance(node, ast.Call):\n            targets = [node.func]\n            value = node.args\n        elif isinstance(node, ast.Compare):\n            targets = [node.left, node.comparators]\n            value = node.ops\n        elif isinstance(node, ast.Constant):\n            targets = []\n            value = node.value\n        elif isinstance",
    "segments) + 1",
    "-theta1+period_offset*period) % period",
    "), 1, inner_radius, edge_width, \"cartesian\")",
    "ource(node)",
    "le_path(curve, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1",
    "sforms.tight_remap_polar_to_cartesian(curve1, (radius1, radius1+width1), (theta1, theta1 + (theta2-theta1)/periods1))",
    "rve[:, 0]), np.max(curve[:, 0]))",
    "] - 1)\n            num_lines = len(lines)",
    ".transform(curve)",
    "gion_mask]",
    "ors']),\n        'id': new_id\n    }\n    similarities[(region1_id, new_id)] = similarities[(region2_id, new_id)] = new_region\n    del similarities[(region1_id, region2_id)]",
    "es - 1, middle_end + (max_context_lines if max_context_lines >= 0 else num_lines - 1 - middle_end))",
    "- 1, start_pos[1]\n        if start_line < min_context_lines or num_lines - start_line - 1 < min_context_lines:\n            return None",
    "es(examples, max_value, max_context)",
    "_pos, end_pos)",
    "all['start_idx'],\n            function_call['end_idx'],\n        )",
    ", theta)).T",
    "r_curve, outer_curve, segments, width, sample_rotation)",
    "unds[1]) / subdivisions[1]",
    "m(curve, self.polar_angle, self.polar_radius)",
    "on_call['arguments'])\n        end_idx = len(lines[function_call['end_line'] - 1]) - 1",
    "offset).translate(radius, 0).rotate(i * angle + global_rotation_offset)",
    "e(code)",
    "nd_line'] + 1:current_line + 1]",
    "array([width/2, 0, 0, height])))",
    "nity]",
    "ndom(num_segments, 3)",
    "().rotate(i * angle + rotation_offset).scale(1, -1)",
    "es[current_line][start_idx:])\n        function_call = ast.body[0].value\n        end_idx = function_call['end_idx']",
    "pleTransformer.rotate(image_sliced, sample_rotation)",
    "repetitions)",
    "ner_radius, outer_radius, width,\n                                                                           sample_rotation, global_rotation, left_edge, right_edge,\n                                                                           interpolation)",
    "n_calls(block)\n        if not function_calls:\n            return []",
    "line_curves",
    "ing_pattern, \"\", code)",
    "rator.generate_bezier(control_nodes, width, height)\n        curve = CurveTransforms.fit_c2c(curve, (0, 0, 0, height))",
    "i + aligned) % 2 * teeth_width for i in range(segments + 1)])",
    "ho), np.max(rho))",
    "ddition(inner_curve, outer_curve,\n                                                                                 segments, edge_width,\n                                                                                 edge_width,\n                                                                                 edge_width,\n                                                                                 edge_width,\n                                                                                 edge_width,\n                                                                                 edge_width,\n                                                                                 edge_width,\n                                                                                 edge_width,\n                                                                                 edge_width,\n                                                                                 edge_width,\n                                                                                 edge_width,\n                                                                                 edge_width,\n                                                                                 edge_width,\n                                                                                 edge_width,\n                                                                                 edge_width,\n                                                                                 edge_width,\n                                                                                 edge_width,\n                                                                                 edge_width,\n                                                                                 edge_width,\n                                                                                 edge_width,\n                                                                                 edge_width,\n                                                                                 edge_width,\n                                                                                 edge_width,\n                                                              ",
    "plit_idx + 1:]\n            suffix = suffix[:len(suffix) - 1]\n            split_idx = middle.find(r'\\n')\n            if split_idx == -1:\n                break\n            prefix += middle[:split_idx]\n            middle = middle[split_idx + 1:]\n            suffix = suffix[:len(suffix) - 1]\n            split_idx = middle.find(r'\\n')\n            if split_idx == -1:\n                break\n            prefix += middle[:split_idx]\n            middle = middle[split_idx + 1:]\n            suffix = suffix[:len(suffix) - 1]\n            split_idx = middle.find(r'\\n')\n            if split_idx == -1:\n                break\n            prefix += middle[:split_idx]\n            middle = middle[split_idx + 1:]\n",
    "_scores(generated, expected)",
    "(curve[:, 0])",
    "alue\n        elif isinstance(node, ast.Assign):\n            targets = node.targets\n            value = node.value\n        elif isinstance(node, ast.BinOp):\n            targets = [node.left, node.right]\n            value = node.op\n        elif isinstance(node, ast.BoolOp):\n            targets = [node.values]\n            value = node.op\n        elif isinstance(node, ast.Call):\n            targets = [node.func]\n            value = node.args\n        elif isinstance(node, ast.Compare):\n            targets = [node.left, node.comparators]\n            value = node.ops\n        elif isinstance(node, ast.Constant):\n            targets = []\n            value = node.value\n        elif isinstance(node, ast.Delete):\n            targets = node.targets\n            value = None\n        elif isinstance(node, ast.",
    "match.group(1).upper()}}}}}\"\n        if placeholder in strings:\n            return strings[placeholder]",
    "lip_path\n        self.LocalOutlineCurves = local_outline_curves",
    "image, dpu, segments, sides_per_segment, inner_radius, outer_radius, sample_rotation, left_edge, right_edge)"
]