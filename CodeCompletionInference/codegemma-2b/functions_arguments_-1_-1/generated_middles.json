[
    "image_sample, global_rotation, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0",
    "0, 1, 10",
    "image, dpu, grid_size, step_size, inner_curve, outer_curve, left_side, right_side, theta1, theta2",
    "100, width, gap, pits_per_segment",
    "(curve1, curve2",
    "num_lines - 1, middle_end + (max_context_lines if max_context_lines >= 0 else num_lines - middle_end)",
    "0, 256, size=(num_segments, 3)",
    "image_sample, global_rotation",
    "-1, 1",
    "1, number_of_segments)\n            angle = delta_angle\n        if angle is None:\n            angle = 2*np.pi/repetitions\n        if reverse_rotation:\n            angle = -angle\n        scale = np.array(scale)\n        if scale.size == 1:\n            scales = scale*np.ones(repetitions)\n        elif scale.size == 2:\n            scales = np.linspace(scale[0], scale[1], repetitions)\n        elif scale.size == repetitions:\n            scales = scale\n        else:\n            scales = np.ones(repetitions)\n        base_curves = copy.deepcopy(curves)\n        Transformer.scale_curves(curves, scales[0])\n        for i in range(1, repetitions):\n            new_curves = copy.deepcopy(base_curves)\n            Transformer.rotate_curves(new_curves",
    "y",
    "image, dpu, segments, inner_radius, outer_radius",
    "curve_cartesian[:, 1]",
    "angle",
    "region1_info['color_histogram'],\n                                            region1_info['size'],\n                                            region2_info['color_histogram'],\n                                            region2_info['size']",
    "image, dpu, segments, sides_per_segment, inner_radius, outer_radius, sample_rotation, left_edge, right_edge",
    "(rho, theta)",
    "i * angle + global_rotation_offset",
    "curve, line_width, fill=True",
    "radius, 0",
    "expected",
    "region2_info['neighbors']",
    "(prefix, middle, suffix)",
    "[inner_curve, outer_curve]",
    "image, dpu, segments, grid_size, inner_radius, outer_radius,\n                                                                              width, interpolation, left_edge, right_edge",
    "image, curve, dpu, segments",
    "100, width, gap, pits_per_segment",
    "image_sliced, extent, path, outline_curves",
    "tree",
    "max(region1_id, region2_id)",
    "perm2",
    "(outline_curves[0], outline_curves[1])",
    "e",
    "(random_split_name, examples_split)",
    "control_nodes, values, width",
    "(x_fine, y_fine)",
    "curve[:, 1]",
    "curve1, i*(theta2-theta1)/periods1, inplace=False",
    "np.vstack([CurveTransforms.rotate_single(curve2, i * (theta2 - theta1) / periods2, inplace=False) for i in range(0, periods2)])",
    "0, current.id",
    "n",
    "np.uint8",
    "num_segments",
    "block",
    "image_sliced, extent, path, outline_curves",
    "pivot[0], pivot[1]",
    "new_height * clip_ar",
    "len(curves)",
    "int(np.minimum(height, y_abs*dpu)), height-1",
    "self.evaluate_curve_bounds(curve)"
]