[
    "0\n        current_line = function_call['end_line_offset'] - 1\n        start_idx = function_call['end_col_offset'] - 1",
    "np.zeros((len(control_points), 2))\n        for i in range(len(control_points)):\n            nodes[i, 0] = control_points[i][0]\n            nodes[i, 1] = control_points[i][1]",
    "node.targets",
    "Affine2D.rotate(angle)",
    "Visitor()",
    "n_periods*period_offset",
    "Curve.from_path(path)",
    "{}",
    "ImageSampleTransformer.slice_image(image, dpu, segments, width, sample_rotation)",
    "1",
    "np.pi/repetitions",
    "np.min(curve[:, 1])",
    "CurveTransforms.tight_remap_polar_to_cartesian(curve2, (radius2 - width2, radius2), (theta1, theta1 + (theta2-theta1)/periods2))",
    "[]\n        for i in range(subdivisions[0]):\n            for j in range(subdivisions[1]):\n                diamond = CurveGenerator.polyline([0, x_delta/2, x_delta, x_delta/2, 0], [y_delta/2, y_delta, y_delta/2, 0, y_delta/2])\n                diamonds.append(diamond)",
    "len(lines)\n        if start_pos[0] < 0 or start_pos[0] >= num_lines or start_pos[1] < 0 or start_pos[1] >= len(lines[start_line]):\n            raise ValueError(\"Invalid start position\")\n        if end_pos[0] < 0 or end_pos[0] >= num_lines or end_pos[1] < 0 or end_pos[1] >= len(lines[end_line]):\n            raise ValueError(\"Invalid end position\")\n        if max_context_lines < 0 or max_context_lines > num_lines:\n            raise ValueError(\"Invalid max_context_lines\")\n        if max_characters < 0 or max_characters > len(lines[start_line]):\n            raise ValueError(\"Invalid max_characters\")\n        if min_context_lines < 0 or min_",
    "True",
    "ImageSlice.slice_image(image, dpu, segments, teeth_per_segment, aligned, teeth_width,\n                                                                        inner_radius, outer_radius)",
    "np.array([inner_radius + ((i + aligned) % 2) * teeth_width for i in range(segments + 1)])",
    "self.chrf_score(generated, expected)\n        results['cer'] = self.cer_score(generated, expected)\n        results['cer_with_space'] = self.cer_with_space_score(generated, expected)\n        results['cer_with_space_and_space'] = self.cer_with_space_and_space_score(generated, expected)\n        results['cer_with_space_and_space_and_space'] = self.cer_with_space_and_space_and_space_score(generated, expected)",
    "delta_angle * repetitions",
    "node.end_lineno",
    "[node.func.value.id]\n            parts.append(node.func.attr)",
    "match.group(1)\n        code = match.group(2)",
    "[curve1, curve2]",
    "self.get_source(node)",
    "[curve]",
    "[\n            Transform(\n                rotation=Vector3(0.0, 0.0, 0.0),\n                translation=Vector3(0.0, 0.0, 0.0),\n                scale=Vector3(1.0, 1.0, 1.0),\n            )\n        ]",
    "similarities[(region2_id, region1_id)] = 0\n    for neighbour in region1_info['neighbors']:\n        if neighbour < region1_id:\n            del similarities[(neighbour, region1_id)]",
    "np.zeros_like(segments_mask)\n    mask[region_mask == 1] = 1",
    "angle % (2 * np.pi)",
    "CurveTransforms.slice_curve(outer_curve, inner_curve, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1",
    "[]\n        for line in lines:\n            if line.startswith(\"if \"):\n                start_pos = lines.index(line)\n                end_pos = start_pos + 1\n                while end_pos < len(lines) and not lines[end_pos].startswith(\"elif \"):\n                    end_pos += 1\n                if end_pos < len(lines) and lines[end_pos].startswith(\"elif \"):\n                    end_pos += 1\n                if end_pos < len(lines) and lines[end_pos].startswith(\"else\"):\n                    end_pos += 1\n                if end_pos < len(lines) and lines[end_pos].startswith(\"endif\"):\n                    end_pos += 1\n                if end_pos < len(lines) and lines[end_pos].startswith(\"end\"):\n                    end_pos += 1\n                if end_",
    "figure",
    "ImageSampleTransformer.slice_image(image, dpu)",
    "radius * np.cos(theta)",
    "CurveTransforms.tight_map_cartesian_to_polar(curve1, (radius1, radius1+width1), (theta1, theta1 + (theta2-theta1)/periods1))\n            curve1 = CurveTransforms.polar_to_cartesian(curve1)\n            curve1 = np.vstack([CurveTransforms.rotate_single(curve1, i * (theta2 - theta1) / periods1, inplace=False) for i in range(0, periods1)])\n        else:",
    "CurveTransforms.polar_to_cartesian(curve1)",
    "np.array([np.array([np.cos(theta), np.sin(theta)]) for theta in values])",
    "[1.0, 0.0, 0.0]",
    "polar_curve[:, 0] * np.cos(polar_curve[:, 1])",
    "{value: i for i, value in enumerate(perm2)}",
    "1\n            angle = delta_angle\n        elif delta_angle is None:\n            repetitions = number_of_segments",
    "np.concatenate(outline_curves, axis=1)",
    "[curve1, curve2]",
    "np.array([[np.cos(angle), -np.sin(angle), pivot[0]],\n                            [np.sin(angle), np.cos(angle), pivot[1]],\n                            [0.0, 0.0, 1.0]])",
    "np.array([[0.0, 0.0]])",
    "[]\n    for line in lines:\n        if line.strip():\n            stripped_lines.append(line)",
    "segments.shape[0]",
    "interpolated_curve\n        else:\n            curve = np.empty((2, samples), dtype=np.float64)\n            curve[:] = interpolated_curve",
    "np.array(nodes)"
]