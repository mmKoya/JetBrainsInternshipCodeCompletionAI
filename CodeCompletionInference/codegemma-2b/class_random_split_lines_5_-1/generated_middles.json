[
    "ints=np.array([[0, 0], [1, 0], [1, 1], [0, 1]])):",
    "self.LocalOutlineCurves:",
    "nt = -1) -> Tuple[str, str, str] | None:\n        \"\"\"Extract a section of code with a given start and end position.\"\"\"\n        num_lines = len(lines)\n        if start_pos[0] < 0 or start_pos[1] < 0 or end_pos[0] < 0 or end_pos[1] < 0 or start_pos[0] >= num_lines or start_pos[1] >= num_lines or end_pos[0] >= num_lines or end_pos[1] >= num_lines:",
    "ne_thickness=0.5, debug_colors=False):\n        if debug_colors:",
    "[i] == \"line\":\n                ax.plot(self.Curves[i][:, 0], self.Curves[i][:, 1], color=\"k\", solid_capstyle='round',\n                         linewidth=self.PlotType[i], zorder=self.z_order)",
    "to_polar(curve2, (radius2, radius2+width2), (theta1, theta1 + (theta2-theta1)/periods2))",
    "n(middle) - min_left - min_right))\n                if split_idx < min_left or split_idx > len(middle) - min_right:\n                    continue\n                new_middle = middle[:split_idx] + middle[split_idx + min_right:]\n                if len(new_middle) < min_left + min_right:\n                    continue\n                break",
    "np.vstack((curves[0], curves[1]))\n        for i in range(2, len(curves)):\n            curve = np.vstack((curve, curves[i]))\n        return curve\n    @staticmethod\n    def polar_to_cartesian(rho, theta):\n        x = rho * np.cos(theta)\n        y = rho * np.sin(theta)\n        return np.vstack((x, y)).T\n    @staticmethod\n    def cartesian_to_polar(x, y):\n        rho = np.sqrt(x ** 2 + y ** 2)\n        theta = np.arctan2(y, x)\n        return np.vstack((rho, theta))\n    @staticmethod\n    def polar_to_cartesian(polar_curve):\n        x = polar_curve[:, 0] * np.cos(polar_curve[:, 1])",
    "ode.func\n            while isinstance(current, ast.Attribute):\n                parts.insert(0, current.attr)",
    "       ImageSampleTransformer.rotational_repeat_additive(image_sample, 2 * segments, None, rotation_offset=-sample_rotation, use_flip=True,",
    "_(self):\n        self.Curves = []\n        self.PlotType = []\n        self.Images = []",
    "set=(0.0, 0.0)):\n        curve_nodes = []\n        for i in range(n):\n            curve_nodes.append([i * radius + offset[0], np.random.randint(0, 2 * radius + 1) + offset[1]])\n        curve_nodes = np.array(curve_nodes)\n        curve = CurveGenerator.bezier(curve_nodes, np.linspace(0, 1, 100))",
    "ed, expected)\n        results['meteor'] = self.meteor_score(generated, expected)\n        results['bert_score'] = self.bert_score(generated, expected)\n        if check_syntax:",
    "     code_blocks,\n            num_lines,\n            max_context_lines,\n            'lines',",
    "range(repetitions):\n            if i % 2 == 0 or not use_flip:\n                trans_data = Affine2D().rotate(i * angle + rotation_offset)\n            else:",
    "ds[1]-old_y_bounds[0]))\n        transform = transform.translate(old_x_bounds[0], old_y_bounds[0])\n        curve = CurveTransforms.apply_affine_single(curve, transform, inplace=False)\n        extent = curve.T.reshape(2, 2)",
    "self, bounds):\n        if self.X_bounds is None:\n            self.X_bounds = bounds[0]\n            self.Y_bounds = bounds[1]",
    "sides+1, 1)))\n        return image, extent, path, outline_curves",
    "all in function_calls:",
    " scale_curves(curves: \"list\", scale=1.0):\n        for i in range(len(curves)):\n            curves[i] = np.vstack((curves[i][0]*scale, curves[i][1]*scale))\n        figure.evaluate_bounds()",
    "rray(curves)\n        for i in range(len(transform)):\n            transform[i] = rotate(transform[i], angle, axes=(0, 1))\n        curves.clear()\n        curves.extend(transform)",
    " str,\n        extract_method: Callable[[str, int, int], List[Tuple[str, str, str]]],\n    ) -> List[Tuple[str, List[Tuple[str, str, str]]]]:\n        datasets = []",
    "ines >= 0 else num_lines))\n        prefix = '\\n'.join(lines[start:start_line]) + '\\n' + lines[start_line][start_idx:]\n        suffix = '\\n' + '\\n'.join(lines[end_line + 1:end]) + lines[end_line][end_idx:]\n        return (prefix, middle_text, suffix)",
    "nt = None, delta_angle: float = None, rotation_offset=0.0, use_flip=False,\n                           flip_angle=0.0, reverse_rotation=False):\n        if repetitions is None and delta_angle is None:\n            repetitions = 1\n            angle = None\n        elif repetitions is None:",
    "aluate_bounds())\n    def append_figure(self, figure: \"Figure\"):\n        self.Curves.extend(figure.Curves)",
    "        curve = np.vstack((gap1, gap2))",
    "\n        curve[0, :] = -curve[0, :]\n        curve[1, :] = -curve[1, :]\n    @staticmethod\n    def reverse_figure(figure: \"Figure\"):\n        Transformer.reverse_curve(figure.Curves)\n        figure.evaluate_bounds()\n    @staticmethod\n    def reverse_curves(curves: \"list\"):",
    "r_to_polar(curve_polar, old_rho_bounds, old_theta_bounds, new_rho_bounds, new_theta_bounds):\n        x = old_rho_bounds[0] + (old_rho_bounds[1] - old_rho_bounds[0]) * np.cos(old_theta_bounds[0] + (old_theta_bounds[1] - old_theta_bounds[0]) * curve_polar[:, 0])\n        y = old_rho_bounds[0] + (old_rho_bounds[1] - old_rho_bounds[0]) * np.sin(old_theta_bounds[0] + (old_theta_bounds[1] - old_theta_bounds[0]) * curve_polar[:, 0])\n        return np.vstack((x, y)).T",
    "ve[:, 1])\n        y = polar_curve[:, 0] * np.sin(polar_curve[:, 1])\n        return np.vstack((x, y)).T",
    "*np.ones(repetitions)\n        for i in range(repetitions):\n            new_curves = copy.deepcopy(curves)",
    "n range(0, segments)])",
    " str) -> Tuple[str, str]:\n        \"\"\"Split the indentation from the code text.\"\"\"\n        indentation = line[:line.find('\\n')]\n        code_text = line[line.find('\\n') + 1:]",
    "ageSlicer.custom_ring_arc(image, dpu)",
    "       for i in range(length):\n            generated_text = generated[i]\n            expected_text = expected[i]\n            results = self.evaluate(generated_text, expected_text, check_syntax)\n            for key, value in results.items():\n                total[key] += value",
    "ds[0])\n        curve = CurveTransforms.apply_affine_single(curve, transform, inplace=False)\n        extent = curve.shape[1]\n        x_bounds = (np.min(curve[:, 0]), np.max(curve[:, 0]))",
    "_line + 1:end_line] + [lines[end_line][end_idx:]]\n            )\n        )\n        if not middle_text:\n            return None\n        if max_characters > 0 and len(middle_text) > max_characters:\n            middle_text = middle_text[:max_characters] + '...'",
    ", outline_curves = ImageSlicer.sample_from_curve(image, curve, dpu)",
    "      \"\"\"Extract assignment sections with character limit and surrounding context.\"\"\"\n        assignments = find_assignments(block)\n        lines = block.splitlines()\n        examples = []",
    "sforms.polar_to_cartesian(nodes)\n        return np.vstack((nodes, nodes[0]))\n    @staticmethod",
    "gle + rotation_offset)\n            else:\n                trans_data = Affine2D().rotate(-flip_angle).scale(1, -1).rotate(flip_angle + rotation_offset)\n            transforms.append(trans_data)",
    "ine_curves = [curve1]",
    "0.0)",
    " rotation_repeat_curves(curves: \"list\", number_of_segments=None, delta_angle=None, scale=1.0, reverse_rotation=False):\n        if number_of_segments is not None and delta_angle is not None:\n            raise ValueError(\"Cannot specify both number_of_segments and delta_angle\")\n        if number_of_segments is None and delta_angle is None:\n            raise ValueError(\"Must specify either number_of_segments or delta_angle\")\n        if number_of_segments is not None and delta_angle is not None and number_of_segments < 1:\n            raise ValueError(\"Number of segments must be at least 1\")\n        if delta_angle is not None and delta_angle < 0:\n            raise ValueError(\"Delta angle must be positive\")\n        if delta_angle is not None and delta_angle > 2*np.pi",
    "min_context_lines:\n                continue\n            prefix, middle, suffix = CodeSegmentExtractor.extract_section(lines, call['start_pos'], call['end_pos'],\n                                                                          max_characters=max_arguments,\n                                                                          min_context_lines=min_context_lines,\n                                                                          max_context_lines=max_context_lines)",
    "        repetitions = np.trunc(2 * np.pi / delta_angle)\n            angle = None\n        elif delta_angle is None:",
    "a1=0.0, theta2=np.pi / 2, amplitude=0.5, period=1.0, period_offset=0.0, offset=(0.0, 0.0)):",
    "titions = np.maximum(1, repetitions)",
    "rve[:, 1], color=outline_color, linewidth=outline_thickness, zorder=z_order + 0.001)\n            if debug_colors:\n                ImageSample.current_outline = (ImageSample.current_outline+1) % 20\n                outline_color = ImageSample.outline_colors[ImageSample.current_outline]",
    "h, y_abs*dpu)), width-1)",
    "\n        curves = copy.deepcopy(figure.Curves)\n        Transformer.rotation_repeat_curves(curves, number_of_segments, delta_angle, scale)"
]