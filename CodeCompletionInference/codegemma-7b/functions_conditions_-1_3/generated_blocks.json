[
    "def collect_assignment_info(self, node):\n        if isinstance(node, ast.Assign):\n            targets = node.targets\n            value = node.value\n        elif isinstance(node, ast.AugAssign):",
    "def apply_affine_multi(curves: List[np.ndarray], affine: Affine2D, inplace=True) -> List[np.ndarray]:\n        if inplace:\n            for i in range(len(curves)):\n                curves[i][:] = affine.transform(curves[i])\n            return curves\n        else:\n            return [affine.transform(curve) for curve in curves]\n\ndef apply_affine_multi_inv(curves:\n            for i in range(len(curves)):\n                curves[i][:] = affine.transform(curves[i])\n            return curves",
    "        triangle2 = np.array([[0.8*width, 0], [0.9*width, height], [width, 0]])\n        curve_nodes = np.array([[0.2*width, 0], [0.4*width, height], [0.6*width, height], [0.8*width, 0]])\n        curve = CurveGenerator.bezier(curve_nodes, np.linspace(0, 1 - 0.5 * half, 100))\n        if self.is_right:\n            return CurveTransforms.merge_curves([triangle1, curve])\n        return CurveTransforms.merge_curves([triangle1, curve, triangle2])",
    "        elif repetitions is None:\n            repetitions = int(np.trunc(2 * np.pi / delta_angle))\n            angle = None\n        elif repetitions < 1:\n            repetitions = np.maximum(1, repetitions)\n            angle = None\n        else:",
    "            outline_curves = [np.vstack((curve1, curve2, np.array([[curve1[0, 0], curve1[0, 1]]])))]\n        elif right_side:\n            outline_curves = [np.vstack((curve1, curve2))]\n        elif left_side:\n            outline_curves = [np.vstack((curve2, curve1))]\n        else:\n            outline_curves = [curve1, curve2]",
    "        if reverse_rotation:\n            angle = -angle\n        scale = np.array(scale)\n        if scale.size == 1:\n            scales = scale*np.ones(repetitions)\n        elif scale.size == 2:\n            scales = np.linspace(scale[0], scale[1], repetitions)",
    "            del similarities[(region1_id, neighbour)]\n    similarities[(region1_id, region2_id)] = 0\n    for neighbour in region2_info['neighbors']:\n        if (neighbour, region2_id) in similarities:\n            del similarities[(neighbour, region2_id)]\n        else:\n            del similarities[(region2_id, neighbour)]",
    "    region1_info = regions[region1_id]\n    region2_info = regions[region2_id]\n    for neighbour in region1_info['neighbors']:\n        if neighbour == region2_id:\n            del similarities[(neighbour, region1_id)]\n        else:\n            del similarities[(region1_id, neighbour)]",
    "            angle = delta_angle\n        if angle is None:\n            angle = 2 * np.pi / repetitions\n        if repetitions is None:\n            repetitions = 1\n        if repetitions < 1:\n            raise ValueError(\"repetitions must be >= 1\")\n        if angle < 0:\n            raise ValueError(\"angle must be >= 0\")\n        if angle > 2 * np.:\n            angle = -angle\n        transforms = []\n        for i in range(repetitions):",
    "            angle = delta_angle\n        if angle is None:\n            angle = 2*np.pi/repetitions\n        if repetitions is None:\n            repetitions = 1\n        if repetitions < 1:\n            raise ValueError(\"repetitions must be >= 1\")\n        if repetitions == 1:\n            return self.rotate(angle, center, scale, shear, resample, order,\n                               :\n            angle = -angle\n        scale = np.array(scale)\n        if scale.size == 1:",
    "        else:\n            print(\"Invalid input_coordinate, curve will default to 0,0\")\n            curve = np.array([[0.0, 0.0]])\n        if input_coordinate == \"polar\":\n            curve = CurveTransforms.polar_to_cartesian(curve)\n        return curve",
    "                examples = []\n                for block in code_blocks:\n                    examples.extend(extract_method(block, max_value, max_context))\n                if len(examples) > 0:\n                    datasets.append((dataset_name, examples))\n                    random_split_name = f'random_split_{dataset_type}_{max_value}_{max_context}'\n                    examples_split = TextUtils.random_split_middle_examples(examples, min_left=5, min_right=5)",
    "        figure = Figure()\n        for curve in diamonds:\n            figure.add_curve(curve, line_width)\n        if not show_curves:\n            for curve in diamonds:\n                figure.add_curve(curve, 0)\n        figure.evaluate_bounds()",
    "def apply_affine_single(curve: np.ndarray, affine: Affine2D, inplace=True) -> np.ndarray: \n        if inplace:\n            curve[:] = affine.transform(curve)\n            return curve\n        else:",
    "def rotation_repeat_curves(curves: \"list\", number_of_segments=None, delta_angle=None, scale=1.0, reverse_rotation=False):\n        if number_of_segments is None and delta_angle is None:\n            repetitions = 1\n            angle = None\n        elif number_of_segments is None:",
    "            angle = delta_angle\n        if angle is None:\n            angle = 2 * np.pi / repetitions\n        if repetitions is None:\n            repetitions = 1\n        if repetitions < 1:\n            raise ValueError(\"repetitions must be >= 1\")\n        if angle < 0:\n            raise ValueError(\"angle must be >= 0\")\n        if angle > 2 * np.:\n            angle = -angle\n        transforms = []\n        for i in range(repetitions):",
    "            continue\n        cycle_length = 0\n        j = i\n        while not visited[j]:\n            visited[j] = True\n            j = perm1_mapped[j]\n            cycle_length += 1",
    "        elif repetitions is None:\n            repetitions = np.trunc(2 * np.pi / delta_angle)\n            angle = None\n        elif angle is None:\n            repetitions = np.maximum(1, repetitions)\n            angle = None\n        else:",
    "        scale = np.array(scale)\n        if scale.size == 1:\n            scales = scale*np.ones(repetitions)\n        elif scale.size == 2:\n            scales = np.linspace(scale[0], scale[1], repetitions)\n        elif scale.size == repetitions:\n            scales = scale",
    "        elif isinstance(node, ast.AugAssign):\n            targets = [node.target]\n            value = node.value\n        elif isinstance(node, ast.Assign):\n            targets = [node.target]\n            value = node.value\n        else:",
    "        examples = []\n        for start_pos, end_pos in assignments:\n            result = CodeSegmentExtractor.extract_section(lines, start_pos, end_pos, max_characters, min_context_lines, max_context_lines)\n            if result is not None:\n                examples.append(result)\n        return examples",
    "            curve1 = np.array([[0, 0]])\n        else:\n            (curve1, periods1, radius1, width1, coordinate_type1) = inner_curve\n            if coordinate_type1 == 'polar':\n                curve1 = CurveTransforms.tight_remap_polar_to_polar(curve1, (radius1, radius1+width1), (theta1, theta1 + (theta2-theta1)/periods1))\n                curve1 = CurveTransforms.polar_to_cartesian(curve1)\n            else:",
    "        z_order += 0.001\n        for curve in self.AdditionalCurves:\n            ax.plot(curve[:, 0], curve[:, 1], color=\"k\", solid_capstyle='round', zorder=z_order, transform=ax.transData, linewidth=outline_thickness)\n        if self.AdditiveTransforms:\n            self.plot_persistent(ax, Affine2D(), z_order, outline_thickness, debug_colors)\n        else:\n            for transform in self.AdditiveTransforms:",
    "        additive_transforms = TransformsGenerator.circular_placement(radius, repetitions, delta_angle, local_rotation_offset,\n                                                                     global_rotation_offset, use_flip, flip_angle, reverse_rotation)\n        image_sample.AdditiveTransforms = additive_transforms\n        if image_sample.PersistentClipPaths is not None:\n            (new_persistent_paths, new_persistent_transforms, outline_curves) = paths_self_overlap(image_sample.PersistentClipPaths, image_sample.PersistentTransforms,\n                                                                                                   additive_transforms[0], additive_transforms[1])\n            image_sample.PersistentTransforms = new_persistent_transforms",
    "        num_lines = len(lines)\n        start_line, start_idx = start_pos[0] - 1, start_pos[1]\n        end_line, end_idx = end_pos[0] - 1, end_pos[1]\n        if start_line == end_line:\n            return lines[start_line][start_idx:end_idx]\n        elif start_line == end_line - 1:\n            return lines[start_line][start_idx:] + lines[end_line][:end_idx]:\n            return None\n        middle_text = (\n            lines[start_line][start_idx:end_idx] if start_line == end_line",
    "        for call in function_calls:\n            if len(call['arguments']) > max_arguments > 0:\n                continue\n            if not call['function_name']:\n                continue\n            prefix, middle, suffix = TextUtils.extract_function_call_details(lines, call)\n            if not middle:",
    "        elif isinstance(node.func, ast.Attribute):\n            parts = []\n            current = node.func\n            while isinstance(current, ast.Attribute):\n                parts.insert(0, current.attr)\n                current = current.value\n            if isinstance(current, ast.Name):",
    "def add_curve(self, curve, plot_type, bounds=None, evaluate_bounds=False):\n        self.Curves.append(curve)\n        self.PlotType.append(plot_type)\n        if bounds is not None:\n            self.update_curve_bounds(bounds)\n        elif evaluate_bounds:\n            self.update_curve_bounds(self.evaluate_curve_bounds(curve))",
    "        func_name = None\n        if isinstance(node.func, ast.Name):\n            func_name = node.func.id\n        elif isinstance(node.func, ast.Attribute):\n            parts = []\n            current = node.func\n            while isinstance(current, ast.Attribute):",
    "def math_function(function, values, input_coordinate=\"x_input\", polar=False):\n        if polar:\n            x_values = values\n            y_values = np.array([function(x) for x in x_values])\n            curve = np.vstack((x_values, y_values)).T",
    "        counts = defaultdict(int)\n        for gen, exp in zip(generated, expected):\n            for key, value in self.evaluate(gen, exp, check_syntax).items():\n                if key in total:\n                    total[key] += value\n                    counts[key] += 1\n        averaged = {key: (total[key] / counts[key]) if counts[key] > 0 else None for key in total}",
    "                    datasets.append((dataset_name, examples))\n                    random_split_name = f'random_split_{dataset_type}_{max_value}_{max_context}'\n                    examples_split = TextUtils.random_split_middle_examples(examples, min_left=5, min_right=5)\n                    if not TextUtils.is_empty(examples_split):\n                        datasets.append((random_split_name, examples_split))\n        return datasets",
    "        else:\n            repetitions = np.maximum(1, repetitions)\n            angle = delta_angle\n        if repetitions > 1:\n            angle = 2 * np.pi / repetitions\n        if reverse_rotation:\n            angle = -angle",
    "            char = lines[current_line][start_idx]\n            parentheses_balance += 1 if char == ')' else -1 if char == '(' else 0\n            start_idx -= 1\n            if parentheses_balance < 0:\n                current_line -= 1\n                start_idx = len(lines[current_line]) - 1\n        prefix = '\\n'.join(lines[function_call['start_line'] - 1:current_line] + [lines[current_line][:start_idx + 2]])",
    "            end_line = node.test.end_lineno\n            end_col = node.test.end_col_offset\n            conditions.append(((start_line, start_col), (end_line, end_col)))\n        elif isinstance(node, ast.If):\n            condition = ast.get_source_segment(code, node.test)\n            start_line = node.test.lineno\n            start_col = node.test.col_offset\n            end_line = node.test.end_lineno:\n            condition = ast.get_source_segment(code, node.value.test)\n            start_line = node.value.test.lineno\n            start_col = node.value.test.col_offset",
    "        new_examples = []\n        for example in examples:\n            prefix, middle, suffix = example\n            if len(middle) < min_right:\n                continue\n            while True:\n                split_idx = random.randint(min_left, min_left + (len(middle) - min_right - min_left) // 2 + 1)",
    "def edge_type1(width=1.0, height=0.2, flip=False, half=False):\n        if flip:\n            height = -height\n        triangle1 = np.array([[0, 0], [0.1*width, height], [0.2*width, 0]])\n        triangle2 = np.array([[0.8*width, 0], [0.9*width, height], [width, 0]])",
    "        else:\n            rho = (curve_cartesian[:, 1] - y_bounds[0]) / (y_bounds[1] - (y_bounds[0])) * (\n                        rho_bounds[1] - rho_bounds[0]) + rho_bounds[0]\n        if rho < rho_bounds[0]:\n            theta = np.ones(curve_cartesian[:, 0].shape) * theta_bounds[0]\n        else:\n            theta = (curve_cartesian[:, 0] - x_bounds[0]) / (x_bounds[1] - (x_bounds[0])) * (theta_bounds[1] - theta_bounds[0]) + theta_bounds[0]",
    "    similarities = {}\n    for region_id, region in regions.items():\n        for neighbour_id in region['neighbors']:\n            if neighbour_id in regions:\n                similarities[(region_id, neighbour_id)] = histogram_intersection(regions[region_id]['color_histogram'], regions[neighbour_id]['color_histogram'])\n    return similarities",
    "def bezier(control_points, values=np.linspace(0.0, 1.0, 100), polar=False):\n        nodes = control_points\n        if polar:\n            nodes = CurveTransforms.polar_to_cartesian(control_points)\n        nodes = np.asfortranarray(nodes)\n        bezier_curve = bezier.Curve(nodes.T, degree=nodes.shape[0] - 1)",
    "        results['rouge'] = self.rouge_score(generated, expected)\n        results['meteor'] = self.meteor_score(generated, expected)\n        results['bert'] = self.bert_score(generated, expected)\n        if self.syntax_valid:\n            results['syntax_valid'] = self.syntax_validity(generated)\n        return results",
    "        t_fine = np.linspace(0, 1, samples)\n        x_fine, y_fine = spline(t_fine)\n        interpolated_curve = np.vstack((x_fine, y_fine)).T\n        if curve is None:\n            curve.resize((2, samples), refcheck=False)\n            curve[:] = interpolated_curve\n            return curve",
    "def leaf_center(image, dpu=1000.0, segments=8, radius=0.4, height=0.2, sample_rotation=0.0, global_rotation=0.0, left_edge=True, right_edge=False, leaf_type=\"sharp\"):\n        if leaf_type == \"sharp\":\n            leaf = CurveGenerator.bezier(np.array([[-1, 0], [-1, 1], [0, 1], [0, 2]]))\n        else:\n            leaf = CurveGenerator.bezier(np.array([[-1, 0], [-1, 1], [0, 2]]))",
    "            if call['start_line'] - 1 < min_context_lines or num_lines - call['end_line'] < min_context_lines:\n                continue\n            prefix, middle, suffix = TextUtils.extract_function_call_details(lines, call)\n            if not middle:\n                continue\n            start = max(0, call['start_line'] - 1 - (max_context_lines if max_context_lines >= 0 else call['start_line'] - 1))\n            end = min(num_lines, call['end_line'] + (max_context_lines if max_context_lines >= 0 else num_lines))",
    "def __add__(self, figure: \"Figure\"):\n        if isinstance(figure, Figure):\n            new_figure = Figure()\n            new_figure += self\n            new_figure += figure",
    "        x_abs = x2 - x1\n        y_abs = y2 - y1\n        clip_ar = x_abs / y_abs\n        if clip_ar > 1:\n            new_height = np.minimum(int(np.minimum(height, y_abs*dpu)), height-1)\n            new_width = int(new_height * clip_ar)\n        else:",
    "def rotational_repeat(repetitions: int = None, delta_angle: float = None, rotation_offset=0.0, use_flip=True, flip_angle=0.0, reverse_rotation=False):\n        if repetitions is None and delta_angle is None:\n            repetitions = 1\n            angle = None\n        elif repetitions is None:",
    "def visit_Call(self, node):\n        func_name = None\n        if isinstance(node.func, ast.Name):\n            func_name = node.func.id\n        elif isinstance(node.func, ast.Attribute):\n            parts = []",
    "            function_call['end_col_offset'] - 1,\n        )\n        parentheses_balance = 1\n        while parentheses_balance > 0:\n            current_line -= 1\n            start_idx = len(lines[current_line]) - 1\n            while start_idx > 0 and lines[current_line][start_idx]!= ')':\n            char = lines[current_line][start_idx]\n            parentheses_balance += 1 if char == ')' else -1 if char == '(' else 0\n            start_idx -= 1",
    "            elif self.PlotType[i] > 0:\n                ax.plot(self.Curves[i][:, 0], self.Curves[i][:, 1], color=\"k\", solid_capstyle='round',\n                         linewidth=self.PlotType[i], zorder=self.z_order)\n            elif self.PlotType[i] < 0:\n                ax.fill(self.Curves[i][:, 0], self.Curves[i][:, 1], color=\"w\", zorder=self.z_order)\n                ax.plot(self.Curves[i][:, 0], self.Curves[i][:, 1], color=\"k\", solid_capstyle='round',\n                         linewidth=self.PlotType[i], zorder=self.z_order)"
]