[
    "angle = None\n        elif number_of_segments is None:\n            repetitions = np.maximum(1, delta_angle)\n            angle = None",
    "y_values = values\n            x_values = np.array([function(y) for y in y_values])",
    "return CurveTransforms.apply_affine_multi(curves, transform, inplace)\n    @staticmethod\n    def translate_single(curve: np.ndarray, x=0.0, y=0.0, inplace=True) -> np.ndarray:\n        transform = Affine2D().translate(x, y)\n        return CurveTransforms.apply_affine_single(curve, transform, inplace)",
    "\"name\": func_name,\n                \"args\": args,\n                \"start_line\": node.lineno,\n                \"start_col_offset\": node.col_offset,\n                \"end_line\": node.end_lineno,",
    "elif left_side or right_side:\n            outline_curves = [np.vstack((curve1, curve2))]\n        else:",
    "curve = np.vstack((inner_curve, outer_curve))\n        outline_curves = [inner_curve, outer_curve]\n        (image, extent, path) = ImageSlicer.sample_from_curve(image, curve, dpu)\n        return image, extent, path, outline_curves",
    "(image, extent, path) = ImageSlicer.sample_from_curve(image, curve, dpu)\n        return image, extent, path, outline_curves\n    @staticmethod\n    def teeth(image, dpu=1000.0, teeth_width=0.05, teeth_height=0.1, teeth_count=10, theta1=0.0, theta2=np.pi/6, aligned=False):\n        segments = np.minimum(teeth_count, int(np.floor((theta2 - theta1) / (np.pi / 2))))",
    "curve = curve[:50]\n        return CurveTransforms.merge_curves([triangle1, curve, triangle2])\n    @staticmethod\n    def random_curve(interpolation_type=\"bezier\", grid_size=(10, 10), grid_step=(0.1, 0.1)):\n        control_nodes = []",
    "func_name = current.id + \".\" + \".\".join(parts)\n            args = [arg.id for arg in node.args]\n            self.function_calls.append({",
    "function = CurveTransforms.bezier_function(nodes)\n        input_coordinate = \"x_input\"",
    "curves[i][0, :] *= -1\n    @staticmethod\n    def flip_vertical(curves):\n        for i in range(len(curves)):\n            curves[i][1, :] *= -1",
    "self.function_calls.append({\n                \"func_name\": func_name,\n                \"args\": args,\n                \"lineno\": node.lineno,",
    "for dataset_name, examples in extract_method(code_blocks, max_value, max_context):",
    "def evaluate_curve_bounds(self, curve):\n        x, y, rho, theta = curve.get_bounds()\n        x_bounds = (np.min(x), np.max(x))\n        y_bounds = (np.min(y), np.max(y))",
    "def fit_p2p(curve, extent):\n        rho_bounds = (np.min(curve[:, 0]), np.max(curve[:, 0]))\n        theta_bounds = (np.min(curve[:, 1]), np.max(curve[:, 1]))\n        return CurveTransforms.remap_polar_to_polar(curve, rho_bounds, theta_bounds, extent[0:2], extent[2:4])",
    "if isinstance(figure, Figure):\n            new_figure = Figure()\n            new_figure.append_figure(self)\n            new_figure.append_figure(figure)\n        else:",
    "radius: float = None, local_rotation_offset=0.0,",
    "transform = Affine2D().translate(x, y)",
    "@staticmethod\n    def translate_multi(curves: List[np.ndarray], x=0.0, y=0.0, inplace=True) -> List[np.ndarray]:\n        transform = Affine2D().translate(x, y)\n        return CurveTransforms.apply_affine_multi(curves, transform, inplace)\n    @staticmethod",
    "interpolated_curve = np.array(interpolate.interp1d(np.arange(curve.shape[1]), curve, kind=kind, axis=1)(np.linspace(0, curve.shape[1]-1, samples)))\n        if inplace:",
    "def serrated_ring_arc_with_outline(image, dpu=1000.0, segments=3, aligned=True, teeth_width=0.05, inner_radius=0.0,\n                          outer_radius=1.0, theta1=0.0, theta2=np.pi / 6):",
    "curve2 = np.flip(np.vstack((outer_rho, theta)).T, 0)\n        outline_curves = [curve1, curve2]\n        curve = np.vstack((curve1, curve2))",
    "image_sample = ImageSample(image_sliced, extent, path, outline_curves)\n        ImageSampleTransformer.rotational_repeat_additive(image_sample, 2 * segments, None,\n                                                          rotation_offset=-sample_rotation+global_rotation, use_flip=True,\n                                                          flip_angle=(2 * sample_rotation + np.pi / segments) / 2)\n        return image_sample",
    "if self.PlotType[i] > 0:",
    "def translate_multi(curves: List[np.ndarray], x=0.0, y=0.0, inplace=True) -> List[np.ndarray]:",
    "np.maximum(self.X_bounds[1], bounds[0][1]))\n            self.Y_bounds = (np.minimum(self.Y_bounds[0], bounds[1][0]),\n                             np.maximum(self.Y_bounds[1], bounds[1][1]))\n            self.Rho_bounds = (np.minimum(self.Rho_bounds[0], bounds[2][0]),\n                               np.maximum(self.Rho_bounds[1], bounds[2][1]))",
    "image_ar = width / height\n        x1 = curve[:, 0].min()\n        x2 = curve[:, 0].max()\n        y1 = curve[:, 1].min()\n        y2 = curve[:, 1].max()",
    "self.classes = []\n    def visit_FunctionDef(self, node):\n        function_source = ast.get_source_segment(self.code, node)\n        self.functions.append(function_source)\n        self.generic_visit(node)",
    "if angle is None:\n            angle = 2*np.pi/repetitions\n        if reverse_rotation:\n            angle = -angle",
    "curve = np.concatenate(curves, axis=1)\n        curve.resize((2, curve.shape[1]), refcheck=False)",
    "image_sample.PersistentTransforms = new_persistent_transforms\n        additive_transforms = TransformsGenerator.circular_placement(0.5, 1, 0.0, 0.0, 0.0, False, 0.0, False)",
    "curve2 = np.flip(CurveGenerator.circular_arc(100, outer_radius, theta1, theta2), 0)\n        outline_curves = [curve1, curve2]\n        curve = np.vstack((curve1, curve2))\n        (image, extent, path) = ImageSlicer.sample_from_curve(image, curve, dpu)\n        return image, extent, path, outline_curves",
    "def test_ring_type1(image_sample, segments=8, sample_rotation=0.0) -> ImageSample:",
    "def __add__(self, figure: \"Figure\"):\n        if isinstance(figure, Figure):\n            new_figure = Figure()\n            new_figure.append_figure(self)\n            new_figure.append_figure(figure)",
    "outline_curves = [np.vstack((curve1, curve2, np.array([[curve1[0, 0], curve1[0, 1]]])))]\n        else:\n            outline_curves = [curve1, curve2]\n        curve = np.vstack((curve1, curve2))\n        (image, extent, path) = ImageSlicer.sample_from_curve(image, curve, dpu)",
    "def extract_middle_text(block: str, middle_line_count: int = 1, min_context_lines: int = 1, max_context_lines: int = -1) -> List[Tuple[str, str, str]]:\n        \"\"\"Extract middle text with specified line count and surrounding context.\"\"\"\n        lines = block.splitlines()\n        num_lines = len(lines)\n        if num_lines < 2 * min_context_lines + middle_line_count:",
    "lines = block.splitlines()\n        examples = []\n        for start_pos, end_pos in assignments:\n            result = CodeSegmentExtractor.extract_section(lines, start_pos, end_pos, max_characters, min_context_lines, max_context_lines)\n            if result:",
    "return affine.transform(curve)\n    @staticmethod\n    def apply_affine_multi(curves: List[np.ndarray], affine: Affine2D, inplace=True) -> List[np.ndarray]:\n        if inplace:\n            for i in range(len(curves)):",
    "targets = [node.target]\n            value = node.value\n        elif isinstance(node, ast.AnnAssign):\n            targets = [node.target]\n            value = node.value",
    "split_idx = random.randint(min_left, len(middle) - min_right)\n            prefix = prefix + middle[:split_idx]",
    "rho = radius * np.ones(n)\n        curve = CurveTransforms.polar_to_cartesian(np.vstack((rho, theta)).T)\n        CurveTransforms.translate_single(curve, offset[0], offset[1], inplace=True)\n        return curve",
    "new_curves = copy.deepcopy(base_curves)\n            curves.extend(new_curves)\n        curve = np.zeros((2, 0))\n        for i in range(len(curves)):\n            curve = np.hstack((curve, curves[i]))",
    "self.Image = image\n    def update_extent(self, extent):\n        self.Extent = extent\n    def update_main_clip_path(self, clip_path):\n        self.MainClipPath = clip_path\n        self.PersistentClipPaths = [clip_path]\n        self.PersistentTransforms = [Affine2D()]",
    "theta = np.linspace(0, 2 * np.pi, len(x_values))\n        rho = np.sqrt(x_values**2 + y_values**2)",
    "return sliced_image, extent, path\n    @staticmethod\n    def circular_arc(image, dpu=1000.0, inner_radius=0.0, outer_radius=1.0, theta1=0.0, theta2=np.pi/6):\n        curve1 = CurveGenerator.circular_arc(100, inner_radius, theta1, theta2)",
    "try:\n            return chrf_score(generated, expected)\n        except Exception as e:\n            print(f\"Error calculating CHRF score: {e}\")\n            return None",
    "value = node.value\n        start_line = node.lineno\n        end_line = node.end_lineno",
    "self.AdditionalCurves.append(curve)\n    def add_additional_curves(self, curves):\n        self.AdditionalCurves.extend(curves)\n    def add_persistent_clip_path(self, clip_path):\n        self.PersistentClipPaths.append(clip_path)\n        self.PersistentTransforms.append(Affine2D())\n    def add_persistent_transform(self, transform):\n        self.PersistentTransforms.append(transform)",
    "def interpolate_curve(curve, samples, inplace=True):",
    "if i % 2 == 0 or not use_flip:\n                trans_data = Affine2D().rotate(i * angle + rotation_offset)\n            else:\n                trans_data = Affine2D().rotate(-flip_angle).scale(1, -1).rotate(flip_angle + i * angle + rotation_offset)\n            transforms.append(trans_data)"
]