[
    "import numpy as np\n        import random\n        import CurveGenerator\n        import CurveTransforms\n        control_nodes = []\n        for i in range(grid_size[0]):\n            for j in range(grid_size[1]):\n                control_nodes.append((random.uniform(i*grid_step[0], (i+1)*grid_step[0]), random.uniform(j*grid_step[1], (j+1)*grid_step[1])))",
    "  outer_radius=0.5):",
    "targets = [node.target]\n            value = node.value",
    "results['bleu'] = self.bleu_score(generated, expected)",
    "for assignment in assignments:\n                start_line = max(0, assignment[0] - min_context_lines)\n                end_line = min(len(lines), assignment[1] + max_context_lines)\n                context = '\\n'.join(lines[start_line:end_line])\n                if len(context) > max_characters:\n                        continue\n                result = (assignment[0], assignment[1], context)",
    "x = curve[0]\n        y = curve[1]\n        x_fine = np.linspace(x.min(), x.max(), samples)\n        y_fine = np.interp(x_fine, x, y, period=x.max() - x.min())",
    "for i in range(len(self.Curves)):\n            if self.PlotType[i] == \"line\":\n                ax.plot(self.Curves[i][:, 0], self.Curves[i][:, 1], color=\"k\", solid_capstyle='round',\n                         linewidth=1.0, zorder=self.z_order)",
    "image_sliced = ImageSlice.slice_image(image, dpu, segments, inner_radius, outer_radius, width)\n        path = Path.create_ring_path(dpu, segments, inner_radius, outer_radius, width, sample_rotation)\n        extent = path.get_extent()\n        outline_curves = path.get_outline_curves(dpu, segments, inner_radius, outer_radius, width,",
    "curves.extend(new_curves)",
    "self.X = None\n        self.Y = None\n        self.Rho = None\n        self.Theta = None",
    "ax.fill(self.Curves[i][:, 0], self.Curves[i][:, 1], color=\"k\", zorder=self.z_order)\n            elif self.PlotType[i] > 0:\n                ax.fill(self.Curves[i][:, 0], self.Curves[i][:, 1], color=\"w\", zorder=self.z_order)\n                ax.plot(self.Curves[i][:, 0], self.Curves[i][:, 1], color=\"k\", solid_capstyle='round',",
    "parts = [node.func.id]",
    "self.Extent = extent\n        self.MainClipPath = main_clip_path",
    "scales = np.array([scale[0]*np.ones(repetitions), scale[1]*np.ones(repetitions)])",
    "function_call['end_line'] - 1,\n            function_call['end_column'] - 1,\n            function_call['end_column']",
    "if x_abs / y_abs > image_ar:\n            new_height = np.minimum(int(np.minimum(height, y_abs*dpu)), height-1)\n            new_width = int(new_height * image_ar)\n        elif x_abs / y_abs < image_ar:\n            new_width = np.minimum(int(np.minimum(width, x_abs*dpu)), width-1)\n            new_height = int(new_width / image_ar)\n        else:\n            new_width = np.minimum(int(np.minimum(width, x_abs*dpu)), width-1)\n            new_height = int(new_width / image_ar)\n        clip_ar = new_width / new",
    "rho = (curve_cartesian[:, 1] - y_bounds[0]) / (y_bounds[1] - (y_bounds[0])) * (rho_bounds[1] - rho_bounds[0]) + rho_bounds[0]\n        if x_bounds[0] == x_bounds[1]:",
    "function_call['end_column'] - 1,\n            function_call['end_column']\n        )",
    "results = {}\n        results['accuracy'] = self.accuracy(generated, expected)",
    "curve1 = CurveTransforms.tight_remap_polar_to_polar(curve1, (radius1, radius1+width1), (theta1, theta1 + (theta2-theta1)/periods1))\n            else:",
    "if image_ar > clip_ar:\n            new_height = np.minimum(int(np.minimum(height, y_abs*dpu)), height-1)\n            new_width = int(new_height * clip_ar)",
    "examples = []\n                    dataset_name = f'{dataset_type}_{max_value}_{max_context}'\n                    for block in code_blocks:",
    "segments, half, left_edge, right_edge)\n        image_sample = ImageSample(image_sliced, extent, path, outline_curves,\n                                                          sample_rotation=sample_rotation, global_rotation=global_rotation,",
    "if start_line == end_line and start_idx >= end_idx:",
    "self.MainClipPath = main_clip_path",
    "'image': image[region_mask],\n           'mean': image[region_mask].mean(),\n           'std': image[region_mask].std()",
    "y2 = np.max(curve[:, 1])\n        extent = (x1, x2, y1, y2)\n        x_abs = x2 - x1",
    "self.X_bounds = bounds[0]\n            self.Y_bounds = bounds[1]\n            self.Rho_bounds = bounds[2]",
    "'color_histogram': histogram_intersection(region1_info['color_histogram'],",
    "number_of_segments = int(2*np.pi/delta_angle)",
    "else:\n            repetitions = np.maximum(1, repetitions)\n            angle = np.maximum(0, delta_angle)",
    "condition = ast.get_source_segment(code, node.test)\n            start_line = node.test.lineno\n            start_col = node.test.col_offset",
    "for random_split_name, examples_split in random_split(examples):",
    "scales = scale\n        else:\n            raise ValueError(\"scale must be a scalar, a 2-element array, or an array of length repetitions\")",
    "code_blocks: List[str],\n        max_values: List[int],\n        max_context_lines: List[int],",
    "else:\n            rho = (curve_cartesian[:, 1] - y_bounds[0]) / (y_bounds[1] - (y_bounds[0])) * (rho_bounds[1] - rho_bounds[0]) + rho_bounds[0]",
    "code_blocks,\n            max_characters,\n            max_context_lines,",
    "elif scale.size == repetitions:",
    "curve1 = CurveTransforms.tight_map_cartesian_to_polar(curve1, (radius1, radius1+width1), (theta1, theta1 + (theta2-theta1)/periods1))\n            curve1 = CurveTransforms.polar_to_cartesian(curve1)\n            curve1 = np.flip(np.vstack([CurveTransforms.rotate_single(curve1, i*(theta2-theta1)/periods1, inplace=False) for i in range(0, periods1)]), 0)",
    "if local_outline_curves is not None:",
    "elif self.PlotType[i] > 0:",
    "if right_side:",
    "if outer_curve is None:\n            curve2 = np.array([[0, 0]])\n        else:\n            (curve2, periods2, radius2, width2, coordinate_type2) = outer_curve\n        if coordinate_type2 == \"polar\":\n            curve2 = CurveTransforms.tight_remap_polar_to_polar(curve2, (radius2 - width2, radius2), (theta1, theta1 + (theta2-theta1)/periods2))",
    "return CodeSegmentExtractor.extract_code_segments(\n            code_blocks,\n            max_characters,",
    "angle = None",
    "diamonds = []\n        for i in range(subdivisions[0]):\n            for j in range(subdivisions[1]):\n                x = x_bounds[0] + i * x_delta\n                y = y_bounds[0] + j * y_delta\n                if i % 2 == 0:\n                    diamonds.append(Diamond(x, y, x_delta, y_delta))\n                else:\n                    diamonds.append(Diamond(x, y, x_delta, y_delta, True))",
    "delta_angle = 2*np.pi/len(curves)",
    "image_sliced = ImageSlice(image, dpu, segments, pits_per_segment, inner_radius, outer_radius, width, depth, gap,",
    "for id in np.unique(mask):",
    "image_sample = ImageSample(image, dpu=dpu)\n        ImageSampleTransformer.radial_repeat_additive(image_sample, segments, periods_per_segment, period_offset, inner_radius, outer_radius, amplitude)"
]