[
    "0\n        start_idx = function_call['end_col_offset']\n        current_line = function_call['end_line_offset'] - 1",
    "np.array(control_points)",
    "[node.target]",
    "AffineTransform(angle=angle)",
    "AssignmentVisitor()",
    "n_periods*(theta2-theta1)",
    "np.array([rho*np.cos(theta), rho*np.sin(theta)]).T\n        CurveTransforms.rotate_single(curve, angle, center, inplace=True)",
    "{}",
    "image_slice(image, dpu, segments, inner_radius, outer_radius, width, sample_rotation)",
    "1",
    "np.random.uniform(0, 2*np.pi, repetitions)",
    "np.min(curve[:, 1])",
    "CurveTransforms.tight_map_polar_to_cartesian(curve2, (radius2 - width2, radius2), (theta1, theta1 + (theta2-theta1)/periods2))",
    "[base_diamond]",
    "len(lines)",
    "True",
    "_serrated_ring(image, dpu, segments, teeth_per_segment, aligned, teeth_width, inner_radius,\n                                                                     outer_radius)",
    "np.array([inner_radius - ((i + aligned) % 2) * teeth_width for i in range(segments + 1)])",
    "self.chrf_score(generated, expected)",
    "np.linspace(0, 2 * np.pi, repetitions)",
    "node.end_lineno\n        if start_line == end_line:\n            start_col = node.col_offset\n            end_col = node.end_col_offset\n        else:\n            start_col = 0",
    "[]",
    "match.group(0)",
    "np.vstack((curve1, curve2))",
    "self.get_source(node)\n        if class_source in self.classes:\n            raise SyntaxError(\"Duplicate class definition: %s\" % class_source)",
    "ImageSlicer.outline_curves(image, curve, dpu)",
    "[]\n        if mirror_angle == 0.0:\n            transform.append(transforms.RandomHorizontalFlip(p=1.0))\n        elif mirror_angle == 90.0:\n            transform.append(transforms.RandomVerticalFlip(p=1.0))\n        elif mirror_angle == 180.0:\n            transform.append(transforms.Random",
    "0\n    for neighbour in region1_info['neighbors']:\n        if neighbour < region1_id:",
    "region_mask.astype(np.uint8)",
    "np.random.uniform(0, 2 * np.pi)\n        if angle is None:\n            angle = 2 * np.pi / repetitions\n        if reverse_rotation:\n            angle = -angle\n        return angle\n\n    def _get_rotation_matrix(self, angle):\n        \"\"\"\n        Returns a rotation matrix for the given angle.\n        \"\"\"\n        return",
    "self.generate_image_sample(outer_curve, inner_curve,\n                                                                                segments, sample_rotation,",
    "[]\n        start_pos = None\n        for i, line in enumerate(block.splitlines()):\n            if \"if\" in line or \"elif\" in line or \"else\" in line:\n                if start_pos is not None:\n                    conditions.append((start_pos, i))\n                start_pos = i\n        if start_pos is not None:\n            conditions.",
    "figure",
    "ImageSlicer.slice_image(image, dpu, leaf_width, leaf_height)",
    "np.ones(n) * radius",
    "CurveTransforms.cartesian_to_polar(curve1)",
    "CurveTransforms.polar_to_cartesian(curve1)",
    "np.array([np.array([np.cos(theta), np.sin(theta)]) for theta in control_points])",
    "[1.0, 0.0, 0.0]",
    "polar_curve[:, 0] * np.cos(polar_curve[:, 1])",
    "{}\n    for i in range(n):\n        index_map[perm2[i]] = i",
    "None",
    "CurveGenerator.combine_curves(outline_curves)",
    "[curve1, curve2]\n        curve1 = np.vstack((inner_rho, np.flip(theta))).T",
    "np.array([[np.cos(angle), -np.sin(angle), 0],\n                            [np.sin(angle), np.cos(angle), 0],\n                            [0, 0, 1]])",
    "np.array([[np.cos(theta), np.sin(theta)] for theta in np.linspace(0, 2*np.pi, 100)])",
    "[]\n    for line in lines:\n        if line.strip():\n            stripped_lines.append(line)",
    "len(segments)",
    "interpolated_curve",
    "np.array(nodes)\n        values = np.linspace(0, 1, num=num_points)"
]