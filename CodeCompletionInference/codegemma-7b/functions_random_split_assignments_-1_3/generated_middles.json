[
    "ments(block)",
    "um(1, repetitions)\n            angle = delta_angle\n        if angle is None:\n            angle = 2 * np.pi / repetitions\n        if angle is None:\n            angle = 2 * np.pi / repetitions\n        if angle is None:\n            angle = 2 * np.pi / repetitions\n        if angle is None:\n            angle = 2 * np.pi / repetitions\n        if angle is None:\n            angle = 2 * np.pi / repetitions\n",
    "x_bounds[0] - x_bounds[1]) / subdivisions[0]",
    "alue\n        elif isinstance(node, ast.Assign):\n            targets = node.targets\n            value = node.value\n        elif isinstance(node, ast.AugAssign):\n            targets = [node.target]",
    "segments) + 1",
    "2-theta1)/n_periods",
    "), 1, inner_radius, edge_width, \"cartesian\")",
    "ource(node)",
    "le_image(curve, outline_curves,\n                                                      image_size,\n                                                      image_size,\n                                                      image_size,\n                                                      image_size,\n                                                      image_size,\n                                                      image_size,\n                                                      image_size,\n                                                      image_size,\n                                                      image_size,\n                                                      image_size,\n                                                      image_size,\n                                                      image_size,\n                                                      image_size,\n                                                      image_size,\n",
    "sforms.tight_map_polar_to_cartesian(curve1, (radius1, radius1+width1), (theta1, theta1 + (theta2-theta1)/periods1))",
    "rve[:, 0]), np.max(curve[:, 0]))",
    "] - (max_context_lines if max_context_lines >= 0 else 0))",
    ".transform(curve)",
    "gion_mask]",
    "ors']),\n        'id': new_id,\n        'centroid': region1_info['centroid']\n    }\n    regions[new_id] = new_region\n    for neighbour in region1_info['neighbors']:\n        if neighbour == region2_id:\n            continue\n        if neighbour in region2_info['neighbors']:\n            similarities[(new_id, neighbour)] = (similarities[(region1_id, neighbour)] + similarities[(region2_id, neighbour)]) /",
    "es, middle_end + (max_context_lines if max_context_lines >= 0 else num_lines - middle_end))",
    "- 1, start_pos[1]",
    "es(examples, max_value, max_context)",
    "_pos, end_pos)",
    "all['start_column'] - 1,\n            function_call['end_column'] - 1,\n        )\n        prefix = lines[current_line][start_idx:end_idx]",
    ", theta)).T",
    "r_curve, outer_curve, segments,\n                                                                                   sample_rotation)",
    "unds[1]) / subdivisions[1]",
    "m.cartesian_to_polar(curve)",
    "on_call['arguments'])\n        end_idx = len(lines[function_call['end_line'] - 1])",
    "offset).translate(radius, 0).rotate(i * angle + global_rotation_offset)",
    "e(code)",
    "nd_line'] + 1]",
    "flipud(curve)))",
    "neTransform()]\n        self.LocalOutlineCurves = []\n        self.LocalOutlineCurves = []\n        self.LocalOutlineCurves = []\n        self.LocalOutlineCurves = []\n        self.LocalOutlineCurves = []\n        self.LocalOutlineCurves = []\n        self.LocalOutlineCurves = []\n        self.LocalOutlineCurves = []\n        self.LocalOutlineCurves = []\n        self.LocalOutlineCurves = []\n        self.LocalOutlineCurves = []\n        self.LocalOutlineCurves",
    "ndint(0, 256, (num_segments, 3))",
    "().rotate(i * angle + rotation_offset).scale(-1, 1)",
    "es[:current_line])\n        if current_line == 0:\n            prefix = ''\n        else:\n            prefix += lines[current_line - 1]\n        prefix += lines[current_line][:start_idx]",
    "ple.from_image(image_sliced)\n        ImageSampleTransformer.rotate_persistent(image_sample, sample_rotation)",
    "repetitions)",
    "ner_radius, outer_radius, width, segments, interpolation)",
    "n_calls(block)\n        if not function_calls:\n            return []",
    "line_curves",
    "ing_pattern, replace_string, code)",
    "rator.bezier_curve(control_nodes, values)\n        curve = CurveTransforms.fit_c2c(curve, (0, 0, 0, 0))",
    "(i + aligned) % 2) * teeth_width for i in range(segments + 1)])",
    "ho), np.max(rho))",
    "dd(image, inner_curve, outer_curve,\n                                                                                  segments, sample_rotation,\n                                                                                  global_rotation=0.0, half=False,\n                                                                                  left_edge=left_edge,\n                                                                                  right_edge=right_edge)\n        image_sample = ImageSample(image_sliced, extent, path, outline_curves)\n        ImageSampleTransformer.rotational_repeat_additive(image_sample, 2 * segments, None,\n                               ",
    "plit_idx + 1:]\n            suffix = middle[-1]\n            middle = middle[:-1]\n            for split_idx in range(len(middle) - 1, -1, -1):",
    "_scores(generated, expected)",
    "(curve[:, 0])",
    "alue\n        elif isinstance(node, ast.Assign):\n            targets = node.targets",
    "match.group(1).upper()}:{match.group(2)}}}}\"",
    "lip_path\n        self.LocalOutlineCurves = local_outline_curves",
    "image, dpu, segments, sides_per_segment, inner_radius, outer_radius, sample_rotation, global_rotation, left_edge, right_edge)"
]