[
    "def extract_assignment_sections(block: str, max_characters: int = 100, min_context_lines: int = 1, max_context_lines: int = -1) -> List[Tuple[str, str, str]]:\n        \"\"\"Extract assignment sections with character limit and surrounding context.\"\"\"\n        assignments = find_assignments(block)\n        lines = block.splitlines()\n        examples = []\n        for start_pos, end_pos in assignments:",
    "            repetitions = np.maximum(1, repetitions)\n            angle = None\n        else:\n            repetitions = np.maximum(1, repetitions)\n            angle = delta_angle\n        if angle is None:\n            angle = 2 * np.pi / repetitions\n        if angle is None:\n            angle = 2 * np.pi / repetitions\n        if angle is None:\n            angle = 2 * np.pi / repetitions\n        if angle is None:\n            angle = 2 * np.pi / repetitions\n        if angle is None:\n            angle = 2 * np.pi / repetitions\n\n            angle = delta_angle\n        if angle is None:\n            angle = 2 * np.pi / repetitions",
    "def diamond_figure(x_bounds=(0.0, 1.0), y_bounds=(0.0, 1.0), subdivisions=(3, 3), line_width=1.0, fill=False):\n        x_delta = np.abs(x_bounds[0] - x_bounds[1]) / subdivisions[0]\n        y_delta = np.abs(y_bounds[0] - y_bounds[1]) / subdivisions[1]\n        base_diamond = CurveGenerator.polyline([0, x_delta/2, x_delta, x_delta/2, 0], [y_delta/2, y_delta, y_delta/2, 0, y_delta/2])\n        diamonds = [base_diamond]",
    "            value = node.value\n        elif isinstance(node, ast.AnnAssign):\n            targets = [node.target]\n            value = node.value\n        elif isinstance(node, ast.Assign):\n            targets = node.targets\n            value = node.value\n        elif isinstance(node, ast.AugAssign):\n            targets = [node.target]\n        else:\n            return\n        start_line = node.lineno",
    "def colorize_segments(segments):\n    num_segments = np.max(segments) + 1\n    colors = np.random.randint(0, 255, size=(num_segments, 3), dtype=np.uint8)\n    color_image = np.zeros((segments.shape[0], segments.shape[1], 3), dtype=np.uint8)\n    for i in range(num_segments):",
    "def sine_wave_circular_arc(n=100, radius=0.5, theta1=0.0, theta2=np.pi/2, amplitude=0.1, n_periods=2, period_offset=0.25, offset=(0.0, 0.0)):\n        theta = np.linspace(theta1, theta2, n)\n        period = (theta2-theta1)/n_periods\n        freq = 2*np.pi/period\n        rho = radius + amplitude*np.sin((theta-theta1+period_offset*period)*freq)\n        curve = CurveTransforms.polar_to_cartesian(np.vstack((rho, theta)).T)",
    "def ring_type1(image, dpu=1000.0, segments=8, inner_radius=0.5, outer_radius=0.8, edge_width=0.05, sample_rotation=0.0,\n                   global_rotation=0.0, half=False, left_edge=False, right_edge=False) -> ImageSample:\n        inner_curve = (CurveGenerator.edge_type1(half=half), 1, inner_radius, edge_width, \"cartesian\")\n        outer_curve = (CurveGenerator.edge_type1(half=half), 1, outer_radius, edge_width, \"cartesian\")\n        (image_sliced, extent, path, outline_curves) = ImageSlicer.custom_ring_arc(image, dpu, inner_curve, outer_curve, sample_rotation,\n                                                                                   sample_rotation + np.pi / segments, left_edge, right_edge)",
    "def visit_FunctionDef(self, node):\n        function_source = ast.get_source(node)\n        self.functions.append(function_source)\n        self.generic_visit(node)",
    "        curve2 = CurveTransforms.polar_to_cartesian(curve2)\n        outline_curves = [curve1, curve2]\n        curve = np.vstack((curve1, curve2))\n        (image, extent, path) = ImageSlicer.sample_image(curve, outline_curves,\n                                                      image_size,\n                                                      image_size,\n                                                      image_size,\n                                                      image_size,\n                                                      image_size,\n                                                      image_size,\n                                                      image_size,\n                                                      image_size,\n                                                      image_size,\n                                                      image_size,\n                                                      image_size,\n                                                      image_size,\n                                                      image_size,\n                                                      image_size,\n\n        return image, extent, path, outline_curves",
    "            (curve1, periods1, radius1, width1, coordinate_type1) = inner_curve\n            if coordinate_type1 == \"polar\":\n                curve1 = CurveTransforms.tight_remap_polar_to_polar(curve1, (radius1, radius1+width1), (theta1, theta1 + (theta2-theta1)/periods1))\n                curve1 = CurveTransforms.tight_map_polar_to_cartesian(curve1, (radius1, radius1+width1), (theta1, theta1 + (theta2-theta1)/periods1))\n            else:\n                curve1 = np.vstack((-curve1[:, 0], curve1[:, 1])).T\n                curve1 = CurveTransforms.tight_map_cartesian_to_polar(curve1, (radius1, radius1+width1), (theta1, theta1 + (theta2-theta1)/periods1))",
    "def fit_c2c(curve, extent):\n        x_bounds = (np.min(curve[:, 0]), np.max(curve[:, 0]))\n        y_bounds = (np.min(curve[:, 1]), np.max(curve[:, 1]))\n        return CurveTransforms.remap_c2c(curve, x_bounds, y_bounds, extent[0:2], extent[2:4])",
    "            prefix, middle, suffix = TextUtils.extract_function_call_details(lines, call)\n            if not middle:\n                continue\n            start = max(0, call['start_line'] - (max_context_lines if max_context_lines >= 0 else 0))\n            end = min(num_lines, call['end_line'] + (max_context_lines if max_context_lines >= 0 else num_lines))\n            prefix = '\\n'.join(lines[start:call['start_line'] - 1] + [prefix])\n            suffix = '\\n'.join([suffix] + lines[call['end_line']:end])",
    "def apply_affine_single(curve: np.ndarray, affine: Affine2D, inplace=True) -> np.ndarray: \n        if inplace:\n            curve[:] = affine.transform(curve)\n            return curve\n        else:\n            return affine.transform(curve)",
    "def create_color_histogram(image, region_mask, n_bins=25):\n    region = image[region_mask]\n    size = region.shape[0]\n    hist_r, _ = np.histogram(region[:, 0], range=(0.0, 1.0), bins=n_bins)\n    hist_b, _ = np.histogram(region[:, 1], range=(0.0, 1.0), bins=n_bins)",
    "            del similarities[(region2_id, neighbour)]\n    new_mask = np.logical_or(region1_info['mask'], region2_info['mask'])\n    mask[new_mask] = new_id\n    new_region = {\n        'mask': new_mask,\n        'neighbors': region1_info['neighbors'].union(region2_info['neighbors']),\n        'id': new_id,\n        'centroid': region1_info['centroid']\n    }\n    regions[new_id] = new_region\n    for neighbour in region1_info['neighbors']:\n        if neighbour == region2_id:\n            continue\n        if neighbour in region2_info['neighbors']:\n            similarities[(new_id, neighbour)] = (similarities[(region1_id, neighbour)] + similarities[(region2_id, neighbour)]) /\n    new_region['neighbors'].discard(new_id)\n    new_region['neighbors'].discard(max(region1_id, region2_id))\n    for neighbour in new_region['neighbors']:",
    "        for middle_start in range(min_context_lines, num_lines - min_context_lines - middle_line_count):\n            middle_end = middle_start + middle_line_count\n            start_prefix = max(0, middle_start - (max_context_lines if max_context_lines >= 0 else middle_start))\n            end_suffix = min(num_lines, middle_end + (max_context_lines if max_context_lines >= 0 else num_lines - middle_end))\n            indentation, middle_text = TextUtils.split_indentation('\\n'.join(lines[middle_start:middle_end]))\n            prefix = '\\n'.join(lines[start_prefix:middle_start]) + '\\n' + indentation\n            suffix = '\\n' + '\\n'.join(lines[middle_end:end_suffix])",
    "def extract_section(lines: List[str], start_pos: (int, int), end_pos: (int, int), max_characters: int = -1,\n                        min_context_lines: int = 1, max_context_lines: int = -1) -> Tuple[str, str, str]:\n        num_lines = len(lines)\n        start_line, start_idx = start_pos[0] - 1, start_pos[1]\n        end_line, end_idx = end_pos[0] - 1, end_pos[1]\n        if start_line < min_context_lines or num_lines - end_line - 1 < min_context_lines:\n            return None",
    "                if examples:\n                    datasets.append((dataset_name, examples))\n                    random_split_name = f'random_split_{dataset_type}_{max_value}_{max_context}'\n                    examples_split = TextUtils.random_split_middle_examples(examples, max_value, max_context)\n                    if examples_split:\n                        datasets.append((random_split_name, examples_split))\n        return datasets",
    "        lines = block.splitlines()\n        examples = []\n        for start_pos, end_pos in conditions:\n            result = CodeSegmentExtractor.extract_section(lines, start_pos, end_pos)\n            if result:\n                examples.append(result)\n        return examples",
    "def extract_function_call_details(lines: List[str], function_call: dict) -> Tuple[str, str, str]:\n        \"\"\"Extract the components of a function call: prefix, arguments, and suffix.\"\"\"\n        current_line, start_idx, end_idx = (\n            function_call['end_line'] - 1,\n            function_call['start_column'] - 1,\n            function_call['end_column'] - 1,\n        )\n        prefix = lines[current_line][start_idx:end_idx]\n        parentheses_balance = 1\n        while parentheses_balance:\n            char = lines[current_line][start_idx]",
    "        inner_rho = np.array([inner_radius + (i % 2) * teeth_width for i in range(segments + 1)])\n        outer_rho = np.array([outer_radius - ((i + aligned) % 2) * teeth_width for i in range(segments + 1)])\n        curve1 = np.vstack((inner_rho, theta)).T\n        curve2 = np.vstack((outer_rho, theta)).T\n        curve1 = CurveTransforms.polar_to_cartesian(curve1)\n        curve2 = CurveTransforms.polar_to_cartesian(curve2)\n        outline_curves = [curve1, curve2]",
    "def test_ring(image, dpu=1000.0, segments=8, inner_radius=0.5, outer_radius=0.8, width=0.05, sample_rotation=0.0) -> ImageSample:\n        inner_curve = (CurveGenerator.bezier(np.array([[0, 0], [0, 1], [1, 1], [1, 2]])), 1, inner_radius, width, \"cartesian\")\n        outer_curve = (CurveGenerator.bezier(np.array([[0, 0], [0, 1], [1, 1], [1, 2]])), 1, outer_radius, width, \"cartesian\")\n        (image_sliced, extent, path, outline_curves) = ImageSlicer.custom_ring_arc(image, dpu, inner_curve, outer_curve, segments,\n                                                                                   sample_rotation)\n        image_sample = ImageSample(image_sliced, extent, path, outline_curves)\n        ImageSampleTransformer.rotational_repeat_additive(image_sample, 2 * segments, None,\n                                                          rotation_offset=-sample_rotation, use_flip=True,",
    "def diamond_figure(x_bounds=(0.0, 1.0), y_bounds=(0.0, 1.0), subdivisions=(3, 3), line_width=1.0, fill=False):\n        x_delta = np.abs(x_bounds[0] - x_bounds[1]) / subdivisions[0]\n        y_delta = np.abs(y_bounds[0] - y_bounds[1]) / subdivisions[1]\n        base_diamond = CurveGenerator.polyline([0, x_delta/2, x_delta, x_delta/2, 0], [y_delta/2, y_delta, y_delta/2, 0, y_delta/2])\n        diamonds = [base_diamond]\n        print(diamonds)",
    "            print(\"Invalid input_coordinate, curve will default to 0,0\")\n            curve = np.array([[0.0, 0.0]])\n        if polar:\n            curve = CurveTransform.cartesian_to_polar(curve)\n        return curve",
    "                current_line -= 1\n                start_idx = len(lines[current_line]) - 1\n        prefix = '\\n'.join(lines[function_call['start_line'] - 1:current_line] + [lines[current_line][:start_idx + 2]])\n        arguments = ', '.join(function_call['arguments'])\n        end_idx = len(lines[function_call['end_line'] - 1])\n        suffix = lines[function_call['end_line'] - 1][end_idx:]\n        return prefix, arguments, suffix",
    "        transforms = []\n        for i in range(repetitions):\n            if i % 2 == 0 or not use_flip:\n                trans_data = Affine2D().rotate(local_rotation_offset).translate(radius, 0).rotate(i * angle + global_rotation_offset)\n            else:\n                trans_data = Affine2D().rotate(-flip_angle).scale(1, -1).rotate(flip_angle + local_rotation_offset).translate(radius, 0).rotate(i * angle + global_rotation_offset)\n            transforms.append(trans_data)",
    "def find_conditions(code):\n    tree = ast.parse(code)\n    conditions = []\n    for node in ast.walk(tree):\n        if isinstance(node, (ast.If, ast.While)):",
    "                start_idx = len(lines[current_line]) - 1\n        prefix = '\\n'.join(lines[function_call['start_line'] - 1:current_line] + [lines[current_line][:start_idx + 2]])\n        arguments = ', '.join(function_call['arguments'])\n        suffix = lines[function_call['end_line'] + 1]\n        return prefix, arguments, suffix",
    "        curve = CurveGenerator.bezier(control_nodes, values)\n        curve = CurveTransforms.fit_c2c(curve, (-width/2, 0, 0, height))\n        if not half:\n            curve = np.vstack((curve, np.flipud(curve)))\n        return curve",
    "        self.Extent = extent\n        self.MainClipPath = main_clip_path\n        self.PersistentClipPaths = [main_clip_path]\n        self.PersistentTransforms = [AffineTransform()]\n        self.LocalOutlineCurves = []\n        self.LocalOutlineCurves = []\n        self.LocalOutlineCurves = []\n        self.LocalOutlineCurves = []\n        self.LocalOutlineCurves = []\n        self.LocalOutlineCurves = []\n        self.LocalOutlineCurves = []\n        self.LocalOutlineCurves = []\n        self.LocalOutlineCurves = []\n        self.LocalOutlineCurves = []\n        self.LocalOutlineCurves = []\n        self.LocalOutlineCurves\n        self.AdditiveTransforms = []\n        if local_outline_curves:\n            self.LocalOutlineCurves = local_outline_curves",
    "def colorize_segments(segments):\n    num_segments = np.max(segments) + 1\n    colors = np.random.randint(0, 256, (num_segments, 3))\n    color_image = np.zeros((segments.shape[0], segments.shape[1], 3), dtype=np.uint8)\n    for i in range(num_segments):\n        color_image[segments == i] = colors[i]",
    "            if i % 2 == 0 or not use_flip:\n                trans_data = Affine2D().rotate(i * angle + rotation_offset)\n            else:\n                trans_data = Affine2D().rotate(i * angle + rotation_offset).scale(-1, 1)\n            transforms.append(trans_data)\n        return transforms",
    "            if start_idx < 0:\n                current_line -= 1\n                start_idx = len(lines[current_line]) - 1\n        prefix = '\\n'.join(lines[:current_line])\n        if current_line == 0:\n            prefix = ''\n        else:\n            prefix += lines[current_line - 1]\n        prefix += lines[current_line][:start_idx]\n        arguments = ', '.join(function_call['arguments'])\n        suffix = lines[function_call['end_line'] - 1][end_idx:]\n        return prefix, arguments, suffix",
    "def leaf_placement(image, dpu=1000.0, segments=8 , inner_radius=0.5, outer_radius=0.8, width=0.2, sample_rotation=0.0, global_rotation=0.0):\n        (image_sliced, extent, path, outline_curves) = ImageSlicer.leaf(image, dpu, width, outer_radius-inner_radius, True)\n        image_sample = ImageSample.from_image(image_sliced)\n        ImageSampleTransformer.rotate_persistent(image_sample, sample_rotation)\n        ImageSampleTransformer.mirror_persistent(image_sample, np.pi/2)\n        ImageSampleTransformer.circular_placement_additive(image_sample, inner_radius, segments, None, -np.pi/2, global_rotation)\n        return image_sample",
    "            repetitions = np.trunc(2 * np.pi / delta_angle)\n            angle = None\n        elif delta_angle is None:\n            repetitions = np.maximum(1, repetitions)\n            angle = None\n        else:\n            repetitions = np.maximum(1, repetitions)",
    "def random_edge_ring(image, dpu=1000.0, segments=8, grid_size=(5, 3), inner_radius=0.5, outer_radius=0.8, width=0.1,\n                         sample_rotation=0.0, global_rotation=0.0, left_edge=False, right_edge=False, interpolation=\"spline\"):\n        (image_sliced, extent, path, outline_curves) = ImageSlicer.random_ring_arc(image, dpu, grid_size, (1, 1), inner_radius, outer_radius, width, segments, interpolation)\n        image_sample = ImageSample(image_sliced, extent, path, outline_curves)\n        ImageSampleTransformer.rotational_repeat_additive(image_sample, 2 * segments, None,\n                                                          rotation_offset=-sample_rotation+global_rotation, use_flip=True,",
    "def extract_function_arguments(block: str, max_arguments: int = 5, min_context_lines: int = 1, max_context_lines: int = -1) -> List[Tuple[str, str, str]]:\n        \"\"\"Extract function arguments with specified context and argument count limitations.\"\"\"\n        function_calls = find_function_calls(block)\n        if not function_calls:\n            return []\n        lines = block.splitlines()\n        num_lines = len(lines)\n        examples = []",
    "        self.PersistentTransforms = [Affine2D()]\n        self.AdditiveTransforms = []\n        if local_outline_curves:\n            self.LocalOutlineCurves = local_outline_curves\n        else:\n            self.LocalOutlineCurves = []\n        self.AdditionalCurves = []",
    "        placeholder = f\"{{{{STR_{len(strings)}}}}}\"\n        strings[placeholder] = match.group(0)\n        return placeholder\n    code_without_strings = re.sub(string_pattern, replace_string, code)\n    code_without_comments = re.sub(comment_pattern, \"\", code_without_strings)\n    for placeholder, original in strings.items():\n        code_without_comments = code_without_comments.replace(placeholder, original)",
    "def leaf(values=np.linspace(0, 1, 100), width=0.1, height=0.2, half=False):\n        control_nodes = np.array([[0, 0], [0, 1], [-1, 1], [-1, 2], [0, 2], [0, 3]])\n        curve = CurveGenerator.bezier_curve(control_nodes, values)\n        curve = CurveTransforms.fit_c2c(curve, (0, 0, 0, 0))\n        curve = CurveTransforms.fit_c2c(curve, (-width/2, 0, 0, height))\n        if not half:\n            curve = np.vstack((curve, np.flip(CurveTransforms.scale_single(curve, (-1, 1), inplace=False), 0)))",
    "                          outer_radius=1.0, theta1=0.0, theta2=np.pi / 6):\n        segments = np.maximum(1, segments)\n        theta = np.linspace(theta1, theta2, segments + 1)\n        inner_rho = np.array([inner_radius + ((i + aligned) % 2) * teeth_width for i in range(segments + 1)])\n        outer_rho = np.array([outer_radius - ((i + aligned) % 2) * teeth_width for i in range(segments + 1)])\n        curve1 = np.vstack((inner_rho, theta)).T\n        curve2 = np.vstack((outer_rho, np.flip(theta))).T",
    "        x_bounds = (np.min(curve[0, :]), np.max(curve[0, :]))\n        y_bounds = (np.min(curve[1, :]), np.max(curve[1, :]))\n        (rho, theta) = CurveTransforms.cartesian_to_polar(curve[0, :], curve[1, :])\n        rho_bounds = (np.min(rho), np.max(rho))\n        theta_bounds = (np.min(theta), np.max(theta))\n        return x_bounds, y_bounds, rho_bounds, theta_bounds",
    "                   global_rotation=0.0, half=False, left_edge=False, right_edge=False) -> ImageSample:\n        inner_curve = (CurveGenerator.edge_type1(half=half), 1, inner_radius, edge_width, \"cartesian\")\n        outer_curve = (CurveGenerator.edge_type1(half=half), 1, outer_radius, edge_width, \"cartesian\")\n        (image_sliced, extent, path, outline_curves) = ImageSlicer.custom_ring_add(image, inner_curve, outer_curve,\n                                                                                  segments, sample_rotation,\n                                                                                  global_rotation=0.0, half=False,\n                                                                                  left_edge=left_edge,\n                                                                                  right_edge=right_edge)\n        image_sample = ImageSample(image_sliced, extent, path, outline_curves)\n        ImageSampleTransformer.rotational_repeat_additive(image_sample, 2 * segments, None,\n                               \n        image_sample = ImageSample(image_sliced, extent, path, outline_curves)\n        ImageSampleTransformer.rotational_repeat_additive(image_sample, 2 * segments, None,\n                                                          rotation_offset=-sample_rotation+global_rotation, use_flip=True,",
    "                if middle[split_idx - 1:split_idx + 1] != r'\\n':\n                    break\n            prefix += middle[:split_idx]\n            middle = middle[split_idx + 1:]\n            suffix = middle[-1]\n            middle = middle[:-1]\n            for split_idx in range(len(middle) - 1, -1, -1):\n            new_examples.append((prefix, middle, suffix))\n        return new_examples",
    "def rouge_score(self, generated, expected):\n        scores = self.rouge.get_scores(generated, expected)\n        return scores['rouge-l']['f']",
    "        height = image.shape[0]\n        width = image.shape[1]\n        image_ar = width / height\n        x1 = np.min(curve[:, 0])\n        x2 = np.max(curve[:, 0])\n        y1 = np.min(curve[:, 1])\n        y2 = np.max(curve[:, 1])",
    "            value = node.value\n        elif isinstance(node, ast.AugAssign):\n            targets = [node.target]\n            value = node.value\n        elif isinstance(node, ast.Assign):\n            targets = node.targets\n        elif isinstance(node, ast.AnnAssign):\n            targets = [node.target]\n            value = node.value",
    "def string_replacer(match):\n        placeholder = f\"{{{{STR_{match.group(1).upper()}:{match.group(2)}}}}\"\n        strings[placeholder] = match.group(0)\n        return placeholder",
    "def __init__(self, image, extent, main_clip_path, local_outline_curves: List[np.ndarray] = None):\n        self.Image = image\n        self.Extent = extent\n        self.MainClipPath = main_clip_path\n        self.LocalOutlineCurves = local_outline_curves\n        self.PersistentClipPaths = [main_clip_path]\n        self.PersistentTransforms = [Affine2D()]\n        self.AdditiveTransforms = []",
    "def regular_polygon_ring(image, dpu=1000.0, segments=8, sides_per_segment=1, inner_radius=0.5, outer_radius=0.8, sample_rotation=0.0, global_rotation=0.0, left_edge=False, right_edge=False):\n        (image_sliced, extent, path, outline_curves) = ImageSlicer.regular_polygon_ring_arc(image, dpu, segments, sides_per_segment, inner_radius, outer_radius, sample_rotation, global_rotation, left_edge, right_edge)\n        image_sample = ImageSample(image_sliced, extent, path, outline_curves)\n        ImageSampleTransformer.rotational_repeat_additive(image_sample, 2 * segments, None,\n                                                          rotation_offset=-sample_rotation + global_rotation,"
]