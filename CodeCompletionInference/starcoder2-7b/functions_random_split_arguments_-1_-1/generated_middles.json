[
    "ast.Assign",
    "d, region2_id",
    " curve2))",
    "Curves",
    "Theta_bounds[0], bounds[3][0]",
    " (radius2, radius2+width2), (theta1, theta1 + (theta2-theta1)/periods2)",
    "[:, 0]",
    "heta)",
    "nt, path, outline_curves",
    "ze, interpolation",
    "], -old_y_bounds[0]",
    "urves)",
    " rotation_offset",
    "ters, min_context_lines, max_context_lines",
    "offset)*freq",
    "o['neighbors']),\n        'color_histogram': merge_histograms(region1_info['color_histogram'],\n                                            region1_info['size'],\n                                            region2_info['color_histogram'],\n                                            region2_info['size']),\n      'size': region1_info['size'] +",
    "riods2",
    "1, 1), False",
    "_text, suffix))\n        examples = [(prefix, middle_text, suffix) for prefix, middle_text, suffix in examples if middle_text]\n        random.shuffle(examples",
    " segments, radius, height, sample_rotation, global_rotation, left_edge, right_edge)",
    "curves",
    "tart_col), (end_line, end_col))",
    "radius, repetitions, 0, 0, True, False, False",
    "rves)",
    "0], -pivot[1]",
    "size[1]",
    "_points",
    "t.AnnAssign",
    ", (1, 1, 1, -1)",
    "tions)\n        curves = copy.deepcopy(curves",
    "tesian[:, 0]",
    "sistent_paths",
    "urves)",
    "(curve, 1, -1",
    " extent, path, outline_curves",
    " theta2, n)\n        period = (theta2 - theta1)/n_periods\n        freq = 2*np.pi/period\n        rho = radius + amplitude*np.sin((theta-theta1+period_offset*period)*freq)\n        curve = CurveTransforms.polar_to",
    "tesian[:, 1]",
    "PersistentTransforms",
    "_sample.PersistentTransforms",
    ", expected",
    "cartesian[:, 1]",
    "angle)\n        image_sample.PersistentClipPaths.append(image_sample.ClipPath)\n        image_sample.PersistentTransforms.append(transform",
    " segments + 1",
    "_code",
    "iods1)",
    "nc, ast.Name",
    "0, 1, 100))\n        if half:\n            return CurveTransforms.merge_curves([curve])\n        return CurveTransforms.merge_curves([triangle1, curve, triangle2])\n\n    @staticmethod\n    def edge_type2(width=1.0, height=",
    "angle",
    " expected",
    "rves)"
]