[
    "def pit_ring(image, dpu=1000.0, segments=8, pits_per_segment=1, inner_radius=0.5, outer_radius=0.8, width=0.8, depth=0.4, gap=0.2, sample_rotation=0.0,\n                   global_rotation=0.0, half=False, left_edge=False, right_edge=False) -> ImageSample:\n        outer_curve = (CurveGenerator.pit(100, width, gap, pits_per_segment), 1, outer_radius, depth, \"cartesian\")\n        inner_curve = (CurveTransforms.scale_single(CurveGenerator.pit(100, width, gap, pits_per_segment), (1, -1)), 1, inner_radius, depth, \"cartesian\")\n        (image_sliced, extent, path, outline_curves) = ImageSlicer.custom_ring_arc(image, dpu, inner_curve, outer_curve, sample_rotation,\n                                                                                   sample_rotation + np.pi / segments, left_edge, right_edge)\n        image_sample = ImageSample(image_sliced, extent, path, outline_curves)\n        ImageSampleTransforms.rotate_image_sample(image_sample, global_rotation, half, left_edge, right_edge,\n                                                          flip_angle=(2 * sample_rotation + np.pi / segments) / 2)\n        return image_sample",
    "def sample_from_curve(image, curve, dpu=1000.0):\n        height = image.shape[0]\n        width = image.shape[1]\n        image_ar = width / height\n        x1 = np.min(curve[:, 0])\n        x2 = np.max(curve[:, 0])\n        y1 = np.min(curve[:, 1])\n        y2 = np.max(curve[:, 1])\n        extent = (x1, x2, y1, y2)\n        x_abs = x2 - x1\n        y_abs = y2 - y1\n        clip_ar = x_abs / y_abs\n        if clip_ar < image_ar:\n            new_height = np.minimum(int(np.minimum(height, y_abs*dpu)), height-1)\n            new_width = int(new_height * clip_ar)\n        else:\n            new_width = np.minimum(int(np.minimum(width, x_abs*dpu)), width-1)\n            new_height = int(new_width / clip_ar)\n        origin = (np.random.randint(0, width - new_width), np.random.randint(0, height - new_height))\n        sliced_image = image[origin[1]:origin[1] + new_height, origin[0]:origin[0] + new_width]\n        path = Path(curve)\n        return sliced_image, extent, path",
    "def collect_assignment_info(self, node):\n        if isinstance(node, ast.Assign):\n            targets = node.targets\n            value = node.value\n        elif isinstance(node, ast.AugAssign):\n            targets = [node.target]\n            value = node.value\n        elif isinstance(node, ast.AnnAssign):\n            targets = [node.target]\n            value = node.value\n        else:\n            return\n        start_line = node.lineno\n        end_line = node.end_lineno\n        end_col = node.end_col_offset\n        start_col = value.col_offset if hasattr(value, 'col_offset') else 0\n        for target in targets:\n            assignment_info = {\n                'start_line': start_line,\n                'start_col': start_col,\n                'end_line': end_line,\n                'end_col': end_col,\n            }\n            self.assignments.append(assignment_info)",
    "def visit_Call(self, node):\n        func_name = None\n        if isinstance(node.func, ast.Name):\n            func_name = node.func.id\n        elif isinstance(node.func, ast.Attribute):\n            parts = []\n            current = node.func\n            while isinstance(current, ast.Attribute):\n                parts.insert(0, current.attr)\n                current = current.value\n            if isinstance(current, ast.Name):\n                parts.insert(0, current.id)\n            func_name = \".\".join(parts)\n        args = [ast.get_source_segment(self.source_code, arg) for arg in node.args]\n        if func_name:\n            self.function_calls.append({\n                \"name\": func_name,\n                \"args\": args,\n                \"start_line\": node.lineno,\n                \"end_line\": node.end_lineno,\n                \"col_offset\": node.col_offset,\n                \"end_col_offset\": node.end_col_offset\n            })\n        else:\n            self.function_calls.append({\n                \"name\": \"unknown\",\n                \"args\": args,\n                \"start_line\": node.lineno,\n                \"end_line\": node.end_lineno,\n                \"col_offset\": node.col_offset,\n                \"end_col_offset\": node.end_col_offset\n            })\n        self.generic_visit(node)",
    "def create_histogram(n, num_swaps, samples=1000):\n    initial_perm = np.random.permutation(n)\n    swap_counts = []\n    for _ in range(samples):\n        perm1 = np.random.permutation(n)\n        perm2 = np.random.permutation(n)\n        swap_count = min_swaps_to_transform(perm1, perm2)\n        swap_counts.append(swap_count)\n    plt.hist(swap_counts, bins=range(max(swap_counts) + 2), edgecolor='black')\n    plt.xlabel(\"Minimal number of swaps to return to original permutation\")\n    plt.ylabel(\"Frequency\")\n    plt.title(f\"Histogram of minimal swaps for {num_swaps} random swaps on a {n}-element permutation\")\n    plt.show()",
    "def extract_datasets(\n        code_blocks: List[str],\n        max_values: List[int],\n        max_context_lines: List[int],\n        dataset_type: str,\n        extract_method: Callable[[str, Any, Any], List[Tuple[str, str, str]]]\n    ) -> List[Tuple[str, List[Tuple[str, str, str]]]]:\n        datasets = []\n        for max_value in max_values:\n            for max_context in max_context_lines:\n                dataset_name = f'{dataset_type}_{max_value}_{max_context}'\n                examples = []\n                for block in code_blocks:\n                    examples.extend(extract_method(block, max_value, max_context))\n                if examples:\n                    datasets.append((dataset_name, examples))\n        return datasets\n\n    def extract_random_splits(\n        self,\n        code_blocks: List[str],\n        max_values: List[int],\n        max_context_lines: List[int],\n        dataset_type: str,\n        extract_method: Callable[[str, Any, Any], List[Tuple[str, str, str]]]\n    ) -> List[Tuple[str, List[Tuple[str, str, str]]]]:\n        datasets = []\n        for max_value in max_values:\n            for max_context in max\n                    if examples_split:\n                        datasets.append((random_split_name, examples_split))\n        return datasets",
    "def extract_function_call_details(lines: List[str], function_call: dict) -> Tuple[str, str, str]:\n        \"\"\"Extract the components of a function call: prefix, arguments, and suffix.\"\"\"\n        current_line, start_idx, end_idx = (\n            function_call['end_line'] - 1,\n            function_call['end_col_offset'] - 2,\n            function_call['end_col_offset'] - 1,\n        )\n        parentheses_balance = 1\n        while parentheses_balance:\n            char = lines[current_line][start_idx]\n            parentheses_balance += 1 if char == ')' else -1 if char == '(' else 0\n            start_idx -= 1\n            if start_idx < 0:\n                current_line -= 1\n                start_idx = len(lines[current_line]) - 1\n        current_line += 1\n        start_idx += 1\n        prefix = '\\n'.join(lines[function_call['start_line'] - 1:current_line] + [lines[current_line][:start_idx + 2]])\n        arguments = ', '.join(function_call['arguments'])\n        suffix = lines[function_call['end_line'] - 1][end_idx:]\n        return prefix, arguments, suffix",
    "def collect_assignment_info(self, node):\n        if isinstance(node, ast.Assign):\n            targets = node.targets\n            value = node.value\n        elif isinstance(node, ast.AugAssign):\n            targets = [node.target]\n            value = node.value\n        elif isinstance(node, ast.AnnAssign):\n            targets = [node.target]\n            value = node.value\n        else:\n            return\n        start_line = node.lineno\n        end_line = node.end_lineno\n        end_col = node.end_col_offset\n        start_col = value.col_offset if hasattr(value, 'col_offset') else 0\n        for target in targets:\n            assignment_info = {\n                'start_line': start_line,\n                'start_col': start_col,\n                'end_line': end_line,\n                'end_col': end_col,\n            }\n            self.assignments.append(assignment_info)",
    "def pit(n=100, width=0.8, gap=0.2, repetitions=1):\n        start = -(width+gap)/2\n        arc_start = -width/2\n        end = -start\n        arc_end = -arc_start\n        gap1 = np.linspace(start, arc_start, 10)\n        gap2 = np.linspace(arc_end, end, 10)\n        gap1 = np.vstack((gap1, np.zeros(10))).T\n        gap2 = np.vstack((gap2, np.zeros(10))).T\n        arc = CurveGenerator.circular_arc(n, width/2, 0, np.pi)\n        CurveTransforms.scale_single(arc, (-1, -1))\n        curve = CurveTransforms.merge_curves([gap1, arc, gap2])\n        curves = []\n        for i in range(repetitions):\n            curves.append(CurveTransforms.translate_single(curve, i*(width+gap), 0, False))\n        return CurveTransforms.merge_curves(curves)",
    "def test_ring(image, dpu=1000.0, segments=8, inner_radius=0.5, outer_radius=0.8, width=0.05, sample_rotation=0.0) -> ImageSample:\n        inner_curve = (CurveGenerator.bezier(np.array([[0, 0], [0, 1], [1, 1], [1, 2]])), 1, inner_radius, width, \"cartesian\")\n        outer_curve = (CurveGenerator.bezier(np.array([[0, 0], [0, 1], [1, 1], [1, 2]])), 1, outer_radius, width, \"cartesian\")\n        (image_sliced, extent, path, outline_curves) = ImageSlicer.custom_ring_arc(image, dpu, segments, inner_curve, outer_curve, sample_rotation)\n        image_sample = ImageSample(image_sliced, extent, path, outline_curves)\n        ImageSampleTransformer.rotational_repeat_additive(image_sample, 2 * segments, None,\n                                                          rotation_offset=-sample_rotation, use_flip=True,\n                                                          flip_angle=(2 * sample_rotation + np.pi / segments) / 2)\n        return image_sample",
    "def collect_assignment_info(self, node):\n        if isinstance(node, ast.Assign):\n            targets = node.targets\n            value = node.value\n        elif isinstance(node, ast.AugAssign):\n            targets = [node.target]\n            value = node.value\n        elif isinstance(node, ast.AnnAssign):\n            targets = [node.target]\n            value = node.value\n        else:\n            return\n        start_line = node.lineno\n        end_line = node.end_lineno\n        end_col = node.end_col_offset\n        start_col = value.col_offset if hasattr(value, 'col_offset') else 0\n        for target in targets:\n            assignment_info = {\n                'start_line': start_line,\n                'start_col': start_col,\n                'end_line': end_line,\n                'end_col': end_col,\n            }\n            self.assignments.append(assignment_info)",
    "def strip_comments(code):\n    string_pattern = r\"(\\\"\\\"\\\".*?\\\"\\\"\\\"|'''.*?'''|\\\".*?\\\"|'.*?'|r\\\".*?\\\"|r'.*?')\"\n    comment_pattern = r\"#.*(?=\\n|$)\"\n    strings = {} \n    def string_replacer(match):\n        placeholder = f\"{{{{STRING{len(strings)}}}}}\"\n        strings[placeholder] = match.group(0)\n        return placeholder\n    code_without_strings = re.sub(string_pattern, string_replacer, code, flags=re.DOTALL)\n    code_without_comments = re.sub(comment_pattern, \"\", code_without_strings)\n    for placeholder, original in strings.items():\n        code_without_comments = code_without_comments.replace(placeholder, original)\n    return code_without_comments",
    "def bezier(control_points, values=np.linspace(0.0, 1.0, 100), polar=False):\n        nodes = control_points\n        if polar:\n            nodes = CurveTransform.to_cartesian(control_points)\n        bezier_curve = bezier.Curve(nodes.T, degree=nodes.shape[0] - 1)\n        return bezier_curve.evaluate_multi(values).T",
    "def evaluate_multi(self, generated: List[str], expected: List[str], check_syntax=False):\n        length = len(generated)\n        if length != len(expected):\n            return None\n        total = defaultdict(float)\n        counts = defaultdict(int)\n        for gen, exp in zip(generated, expected):\n            for key, value in self.evaluate(gen, exp, check_syntax).items():\n                if value is not None:\n                    total[key] += value\n                    counts[key] += 1\n        averaged = {key: (total[key] / counts[key]) if counts[key] > 0 else None for key in total}\n        return averaged",
    "def merge_regions(mask, regions, similarities, region1_id, region2_id):\n    new_id = min(region1_id, region2_id)\n    region1_info = regions[region1_id]\n    region2_info = regions[region2_id]\n    for neighbour in region1_info['neighbors']:\n        if neighbour < region1_id:\n            del similarities[(neighbour, region1_id)]\n        else:\n            del similarities[(region1_id, neighbour)]\n    similarities[(region1_id, region2_id)] = 0\n    for neighbour in region2_info['neighbors']:\n        if neighbour < region2_id:\n            del similarities[(neighbour, region2_id)]\n        else:\n            del similarities[(region2_id, neighbour)]\n    new_mask = np.logical_or(region1_info['mask'], region2_info['mask'])\n    mask[new_mask] = new_id\n    new_region = {\n        'mask': new_mask,\n        'neighbors': region1_info['neighbors'].union(region2_info['neighbors']),\n        'color_histogram': merge_histograms(region1_info['color_histogram'],\n                                            region1_info['size'],\n                                            region2_info['color_histogram'],\n                                            region2_info['size']),\n        'size': region1_info['size'] + region2_info['size'],\n    }\n    new_region['neighbors'].discard(new_id)\n    new_region['neighbors'].discard(max(region1_id, region2_id))\n    for neighbour in new_region['neighbors']:\n        similarity = histogram_intersection(regions[neighbour]['color_histogram'], regions[new_id]['color_histogram'])\n        if neighbour < new_id:\n            similarities[(neighbour, new_id)] = similarity\n        else:\n            similarities[(new_id, neighbour)] = similarity\n    del regions[region1_id]\n    del regions[region2_id]\n    regions[new_id] = new_region\n    for neighbor in regions[new_id]['neighbors']:\n        regions[neighbor]['neighbors'].discard(max(region1_id, region2_id))\n        regions[neighbor]['neighbors'].add(new_id)",
    "def random_split_middle_examples(examples: List[Tuple[str, str, str]], min_left: int = 5, min_right: int = 5) -> List[Tuple[str, str, str]]:\n        \"\"\"Randomly split the middle section of examples with specific constraints.\"\"\"\n        new_examples = []\n        for example in examples:\n            prefix, middle, suffix = example\n            if len(middle) < min_left + min_right:\n                continue\n            while True:\n                split_idx = random.randint(min_left, min_left + (len(middle) - min_right - min_left) // 2 + 1)\n                if middle[split_idx - 1:split_idx + 1] != r'\\n':\n                    break\n            prefix = prefix[:split_idx]\n            suffix = suffix[split_idx:]\n            middle = middle[split_idx:]\n            new_examples.append((prefix, middle, suffix))\n        return new_examples",
    "def square_map_cartesian_to_polar(curve_cartesian, x_bounds, y_bounds, rho_bounds, theta_bounds):\n        if y_bounds[0] == y_bounds[1]:\n            rho = np.ones(curve_cartesian[:, 1].shape) * rho_bounds[0]\n        else:\n            rho = (curve_cartesian[:, 1] - y_bounds[0]) / (y_bounds[1] - (y_bounds[0])) * (\n                        rho_bounds[1] - rho_bounds[0]) + rho_bounds[0]\n        if x_bounds[0] == x_bounds[1]:\n            theta = np.ones(curve_cartesian[:, 0].shape) * theta_bounds[0]\n        else:\n            theta = (curve_cartesian[:, 0] - x_bounds[0]) / (x_bounds[1] - (x_bounds[0])) * (theta_bounds[1] - theta_bounds[0]) + theta_bounds[0]\n        return np.vstack((rho, theta)).T",
    "def merge_regions(mask, regions, similarities, region1_id, region2_id):\n    new_id = min(region1_id, region2_id)\n    region1_info = regions[region1_id]\n    region2_info = regions[region2_id]\n    del similarities[(region1_id, region2_id)]\n    for neighbour in region1_info['neighbors']:\n        if neighbour < region1_id:\n            del similarities[(neighbour, region1_id)]\n        else:\n            del similarities[(region1_id, neighbour)]\n    similarities[(region1_id, region2_id)] = 0\n    for neighbour in region2_info['neighbors']:\n        if neighbour < region2_id:\n            del similarities[(neighbour, region2_id)]\n        else:\n            del similarities[(region2_id, neighbour)]\n    new_mask = np.logical_or(region1_info['mask'], region2_info['mask'])\n    mask[new_mask] = new_id\n    new_region = {\n        'mask': new_mask,\n        'neighbors': region1_info['neighbors'].union(region2_info['neighbors']),\n        'color_histogram': merge_histograms(region1_info['color_histogram'],\n                                            region1_info['size'],\n                                            region2_info['color_histogram'],\n                                            region2_info['size']),\n        'size': region1_info['size'] + region2_info['size'],\n    }\n    new_region['neighbors'].discard(new_id)\n    new_region['neighbors'].discard(max(region1_id, region2_id))\n    for neighbour in new_region['neighbors']:\n        similarity = histogram_intersection(regions[neighbour]['color_histogram'], regions[new_id]['color_histogram'])\n        if neighbour < new_id:\n            similarities[(neighbour, new_id)] = similarity\n        else:\n            similarities[(new_id, neighbour)] = similarity\n    del regions[region1_id]\n    del regions[region2_id]\n    regions[new_id] = new_region\n    for neighbor in regions[new_id]['neighbors']:\n        regions[neighbor]['neighbors'].discard(max(region1_id, region2_id))\n        regions[neighbor]['neighbors'].add(new_id)",
    "def rotation_repeat_curves(curves: \"list\", number_of_segments=None, delta_angle=None, scale=1.0, reverse_rotation=False):\n        if number_of_segments is None and delta_angle is None:\n            repetitions = 1\n            angle = None\n        elif number_of_segments is None:\n            repetitions = np.trunc(2*np.pi/delta_angle)\n            angle = None\n        elif delta_angle is None:\n            repetitions = np.maximum(1, number_of_segments)\n            angle = None\n        else:\n            repetitions = np.maximum(1, number_of_segments)\n            angle = delta_angle\n        if angle is None:\n            angle = 2*np.pi/repetitions\n        if reverse_rotation:\n            angle = -angle\n        scale = np.array(scale)\n        if scale.size == 1:\n            scales = np.ones(repetitions)\n        elif scale.size == repetitions:\n            scales = scale\n        else:\n            scales = np.ones(repetitions)\n        base_curves = copy.deepcopy(curves)\n        Transformer.scale_curves(curves, scales[0])\n        for i in range(1, repetitions):\n            new_curves = copy.deepcopy(base_curves)\n            Transformer.rotate_curves(new_curves, i*angle)\n            Transformer.scale_curves(new_curves, scales[i])\n            curves.extend(new_curves)",
    "def strip_comments(code):\n    string_pattern = r\"(\\\"\\\"\\\".*?\\\"\\\"\\\"|'''.*?'''|\\\".*?\\\"|'.*?'|r\\\".*?\\\"|r'.*?')\"\n    comment_pattern = r\"#.*(?=\\n|$)\"\n    strings = {} \n    def string_replacer(match):\n        placeholder = \"STRING_PLACEHOLDER_%s\" % len(strings)\n        strings[placeholder] = match.group(0)\n        return placeholder\n    code = re.sub(string_pattern, string_replacer, code, flags=re.DOTALL)\n    code = re.sub(comment_pattern, \"\", code)\n    for placeholder, original in strings.items():\n        code = code.replace(placeholder, original)\n    return code\n\ndef strip_comments_and_strings(code):\n    string_pattern = r\"(\\\"\\\"\\\".*?\\\"\\\"\\\"|'''.*\n    code_without_strings = re.sub(string_pattern, string_replacer, code, flags=re.DOTALL)\n    code_without_comments = re.sub(comment_pattern, \"\", code_without_strings)\n    for placeholder, original in strings.items():\n        code_without_comments = code_without_comments.replace(placeholder, original)\n    return code_without_comments",
    "def collect_assignment_info(self, node):\n        if isinstance(node, ast.Assign):\n            targets = node.targets\n            value = node.value\n        elif isinstance(node, ast.AugAssign):\n            targets = [node.target]\n            value = node.value\n        elif isinstance(node, ast.AnnAssign):\n            targets = [node.target]\n            value = node.value\n        else:\n            return\n        if not isinstance(value, ast.Call):\n            return\n        start_line = node.lineno\n        end_line = node.end_lineno\n        end_col = node.end_col_offset\n        start_col = value.col_offset if hasattr(value, 'col_offset') else 0\n        for target in targets:\n            assignment_info = {\n                'start_line': start_line,\n                'start_col': start_col,\n                'end_line': end_line,\n                'end_col': end_col,\n            }\n            self.assignments.append(assignment_info)",
    "def extract_datasets(\n        code_blocks: List[str],\n        max_values: List[int],\n        max_context_lines: List[int],\n        dataset_type: str,\n        extract_method: Callable[[str, Any, Any], List[Tuple[str, str, str]]]\n    ) -> List[Tuple[str, List[Tuple[str, str, str]]]]:\n        datasets = []\n        for max_value in max_values:\n            for max_context in max_context_lines:\n                dataset_name = f'{dataset_type}_{max_value}_{max_context}'\n                examples = []\n                for code_block in code_blocks:\n                    examples.extend(extract_method(code_block, max_value, max_context))\n                if examples:\n                    datasets.append((dataset_name, examples))\n                    random_split_name = f'random_split_{dataset_type}_{max_value}_{max_context}'\n                    examples_split = TextUtils.random_split_middle_examples(examples, min_left=5, min_right=5)\n                    if examples_split:\n                        datasets.append((random_split_name, examples_split))\n        return datasets",
    "def extract_assignments_datasets(code_blocks: List[str], max_characters: List[int], max_context_lines: List[int]) -> List[Tuple[str, List[Tuple[str, str, str]]]]:\n        return DatasetBuilder.extract_datasets(\n            code_blocks,\n            max_characters,\n            max_context_lines,\n            lambda block, max_c, max_pf: CodeSegmentExtractor.extract_assignment_sections(block, max_characters=max_c, max_context_lines=max_pf),\n        )",
    "def ring_type1(image, dpu=1000.0, segments=8, inner_radius=0.5, outer_radius=0.8, edge_width=0.05, sample_rotation=0.0,\n                   global_rotation=0.0, half=False, left_edge=False, right_edge=False) -> ImageSample:\n        inner_curve = (CurveGenerator.edge_type1(half=half), 1, inner_radius, edge_width, \"cartesian\")\n        outer_curve = (CurveGenerator.edge_type1(half=half), 1, outer_radius, edge_width, \"cartesian\")\n        (image_sliced, extent, path, outline_curves) = ImageSlicer.custom_ring_arc(image, dpu, inner_curve, outer_curve, sample_rotation,\n                                                                                   sample_rotation + np.pi / segments, left_edge, right_edge)\n        image_sample = ImageSample(image_sliced, extent, path, outline_curves)\n        ImageSample.rotate_image(image_sample, global_rotation, flip_angle=sample_rotation)\n        return image_sample\n\n    @staticmethod\n    def ring_type2(image, dpu=1000.0, segments=8, inner_radius=0.5, outer_radius=0.8, edge_width=0.05, sample_rotation=0.0,\n                   global_rotation=0.0, half=False, left_edge=False, right_edge=False) -> ImageSample:\n        inner_curve = (CurveGenerator.\n                                                          flip_angle=(2 * sample_rotation + np.pi / segments) / 2)\n        return image_sample",
    "def extract_lines(block: str, middle_line_count: int = 1, min_context_lines: int = 1, max_context_lines: int = -1) -> List[Tuple[str, str, str]]:\n        \"\"\"Generate examples by extracting specified middle lines with configurable context lines.\"\"\"\n        lines = block.splitlines()\n        num_lines = len(lines)\n        if num_lines < 2 * min_context_lines + middle_line_count:\n            return []\n        examples = []\n        for middle_start in range(min_context_lines, num_lines - min_context_lines - middle_line_count):\n            middle_end = middle_start + middle_line_count\n            start_prefix = max(0, middle_start - (max_context_lines if max_context_lines >= 0 else middle_start))\n            end_suffix = min(num_lines, middle_end + (max_context_lines if max_context_lines >= 0 else num_lines - middle_end))\n            prefix = '\\n'.join(lines[start_prefix:middle_start])\n            middle_text = '\\n'.join(lines[middle_start:middle_end])\n            suffix = '\\n' + '\\n'.join(lines[middle_end:end_suffix])\n            examples.append((prefix, middle_text, suffix))\n        return examples",
    "def ring_type1(image, dpu=1000.0, segments=8, inner_radius=0.5, outer_radius=0.8, edge_width=0.05, sample_rotation=0.0,\n                   global_rotation=0.0, half=False, left_edge=False, right_edge=False) -> ImageSample:\n        inner_curve = (CurveGenerator.edge_type1(half=half), 1, inner_radius, edge_width, \"cartesian\")\n        outer_curve = (CurveGenerator.edge_type1(half=half), 1, outer_radius, edge_width, \"cartesian\")\n        (image_sliced, extent, path, outline_curves) = ImageSlicer.custom_ring_arc(image, dpu, inner_curve, outer_curve, sample_rotation,\n                                                                                   sample_rotation + np.pi / segments, left_edge, right_edge)\n        image_sample = ImageSample(image_sliced, extent, path, outline_curves, segments, dpu,\n                                                          rotation_offset=-sample_rotation+global_rotation, use_flip=True,\n                                                          flip_angle=(2 * sample_rotation + np.pi / segments) / 2)\n        return image_sample",
    "def diamond_figure(x_bounds=(0.0, 1.0), y_bounds=(0.0, 1.0), subdivisions=(3, 3), line_width=1.0, fill=False):\n        x_delta = np.abs(x_bounds[0] - x_bounds[1]) / subdivisions[0]\n        y_delta = np.abs(y_bounds[0] - y_bounds[1]) / subdivisions[1]\n        base_diamond = CurveGenerator.polyline([0, x_delta/2, x_delta, x_delta/2, 0], [y_delta/2, y_delta, y_delta/2, 0, y_delta/2])\n        diamonds = [base_diamond.copy() for _ in range(subdivisions[0] * subdivisions[1])]\n        Transformer.scale_curves(diamonds, x_delta, y_delta)\n        Transformer.translate_curves(diamonds, x_bounds[0], y_bounds[0])\n        figure = Figure()\n        for curve in diamonds:\n            figure.add_curve(curve, line_width)\n        if fill and line_width:\n            for curve in diamonds:\n                figure.add_curve(curve, 0)\n        figure.evaluate_bounds()\n        return figure",
    "def find_conditions(code):\n    tree = ast.parse(code)\n    conditions = []\n    for node in ast.walk(tree):\n        if isinstance(node, ast.If):\n            condition = ast.get_source_segment(code, node.test)\n            start_line = node.test.lineno\n            start_col = node.test.col_offset\n            end_line = node.test.end_lineno\n            end_col = node.test.end_col_offset\n            conditions.append(((start_line, start_col), (end_line, end_col)))\n        elif isinstance(node, ast.Assert):\n            condition = ast.get_source_segment(code, node.test)\n            start_line = node.test.lineno\n            start_col = node.test.col_offset\n            end_line = node.test.end_lineno\n            end_col = node.test.end_col_offset\n            conditions.append(((start_line, start_col), (end_line, end_col)))\n        elif isinstance(node, ast.Expr) and isinstance(node.value, ast.IfExp):\n            condition = ast.get_source_segment(code, node.value.test)\n            start_line = node.value.test.lineno\n            start_col = node.value.test.col_offset\n            end_line = node.value.test.end_lineno\n            end_col = node.value.test.end_col_offset\n            conditions.append(((start_line, start_col), (end_line, end_col)))\n    return conditions",
    "def extract_lines(block: str, middle_line_count: int = 1, min_context_lines: int = 1, max_context_lines: int = -1) -> List[Tuple[str, str, str]]:\n        \"\"\"Generate examples by extracting specified middle lines with configurable context lines.\"\"\"\n        lines = block.splitlines()\n        num_lines = len(lines)\n        if num_lines < 2 * min_context_lines + middle_line_count:\n            return []\n        examples = []\n        for middle_start in range(min_context_lines, num_lines - min_context_lines - middle_line_count):\n            middle_end = middle_start + middle_line_count\n            start_prefix = max(0, middle_start - min_context_lines)\n            end_suffix = min(num_lines, middle_end + max_context_lines)\n            indentation, middle_text = TextUtils.split_indentation('\\n'.join(lines[middle_start:middle_end]))\n            prefix = '\\n'.join(lines[start_prefix:middle_start]) + '\\n' + indentation\n            suffix = '\\n' + '\\n'.join(lines[middle_end:end_suffix])\n            examples.append((prefix, middle_text, suffix))\n        return examples",
    "def math_function(function, values, input_coordinate=\"x_input\", polar=False):\n        if input_coordinate == \"x_input\":\n            x_values = values\n            y_values = np.array([function(x) for x in x_values])\n            curve = np.vstack((x_values, y_values)).T\n        elif input_coordinate == \"y_input\":\n            y_values = values\n            x_values = np.array([function(y) for y in y_values])\n            curve = np.vstack((x_values, y_values)).T\n        elif input_coordinate == \"parametric\":\n            curve = np.array([function(x) for x in values])\n        else:\n            print(\"Invalid input_coordinate, curve will default to 0,0\")\n            curve = np.array([[0.0, 0.0]])\n        if polar:\n            curve = CurveTransforms.polar_to_cartesian(curve)\n        return curve",
    "def create_histogram(n, num_swaps, samples=1000):\n    initial_perm = np.random.permutation(n)\n    swap_counts = []\n    for _ in range(samples):\n        perm1 = np.random.permutation(n)\n        perm2 = np.random.permutation(n)\n        swap_count = min_swaps_to_transform(perm1, perm2)\n        swap_counts.append(swap_count)\n    plt.hist(swap_counts, bins=range(max(swap_counts)+1))\n    plt.title(f\"Histogram of minimal swaps for {num_swaps} random swaps on a {n}-element permutation\")\n    plt.show()",
    "def visit_Call(self, node):\n        func_name = None\n        if isinstance(node.func, ast.Name):\n            func_name = node.func.id\n        elif isinstance(node.func, ast.Attribute):\n            parts = []\n            current = node.func\n            while isinstance(current, ast.Attribute):\n                parts.insert(0, current.attr)\n                current = current.value\n            if isinstance(current, ast.Name):\n                parts.insert(0, current.id)\n            func_name = \".\".join(parts)\n        args = [ast.get_source_line(arg) for arg in node.args]\n        if func_name:\n            self.function_calls.append({\n                \"function\": func_name,\n                \"arguments\": args,\n                \"start_line\": node.lineno,\n                \"end_line\": node.end_lineno,\n                \"col_offset\": node.col_offset,\n                \"end_col_offset\": node.end_col_offset\n            })\n        self.generic_visit(node)",
    "def rotational_repeat(repetitions: int = None, delta_angle: float = None, rotation_offset=0.0, use_flip=True, flip_angle=0.0, reverse_rotation=False):\n        if repetitions is None and delta_angle is None:\n            repetitions = 1\n            angle = None\n        elif repetitions is None:\n            repetitions = int(np.trunc(2 * np.pi / delta_angle))\n            angle = None\n        elif delta_angle is None:\n            repetitions = np.maximum(1, repetitions)\n            angle = None\n        else:\n            repetitions = np.maximum(1, repetitions)\n            angle = delta_angle\n        if angle is None:\n            angle = 2 * np.pi / repetitions\n        if reverse_rotation:\n            angle = -angle\n        transforms = []\n        for i in range(repetitions):\n            if i % 2 == 0 or not use_flip:\n                trans_data = Affine2D().rotate(i * angle + rotation_offset)\n            else:\n                trans_data = Affine2D().rotate(-flip_angle).scale(1, -1).rotate(i * angle + flip_angle + rotation_offset)\n            transforms.append(trans_data)\n        return transforms",
    "def extract_function_call_details(lines: List[str], function_call: dict) -> Tuple[str, str, str]:\n        \"\"\"Extract the components of a function call: prefix, arguments, and suffix.\"\"\"\n        current_line, start_idx, end_idx = (\n            function_call['end_line'] - 1,\n            function_call['end_col_offset'] - 2,\n            function_call['end_col_offset'] - 1,\n        )\n        parentheses_balance = 1\n        while parentheses_balance:\n            char = lines[current_line][start_idx]\n            parentheses_balance += 1 if char == ')' else -1 if char == '(' else 0\n            start_idx -= 1\n            if start_idx < 0:\n                current_line -= 1\n                start_idx = len(lines[current_line]) - 1\n        prefix = lines[function_call['end_line'] - 1][start_idx + 1:function_call['end_col_offset'] - 1]\n        arguments = ', '.join(function_call['arguments'])\n        suffix = lines[function_call['end_line'] - 1][end_idx:]\n        return prefix, arguments, suffix",
    "def filled_center_leaf(image, dpu=1000.0, width=0.1, height=0.2,  half=True):\n        curve = CurveGenerator.leaf(np.linspace(0.5, 1, 50), width, height, half)\n        (image, extent, path) = ImageSlicer.sample_from_curve(image, curve, dpu)\n        return image, extent, path, outline_curves",
    "def extract_datasets(\n        code_blocks: List[str],\n        max_values: List[int],\n        max_context_lines: List[int],\n        dataset_type: str,\n        extract_method: Callable[[str, Any, Any], List[Tuple[str, str, str]]]\n    ) -> List[Tuple[str, List[Tuple[str, str, str]]]:\n    \"\"\"\n    Extracts datasets from code blocks.\n\n    :param code_blocks: List of code blocks.\n    :param max_values: List of maximum values to extract.\n    :param max_context_lines: List of maximum context lines to extract.\n    :param dataset_type: Type of dataset to extract.\n    :param extract_method: Method to extract examples.\n    :return: List of datasets.\n    \"\"\"\n    datasets = []\n    for max_value in max_values:\n            for max_context in max_context_lines:\n                dataset_name = f'{dataset_type}_{max_value}_{max_context}'\n                examples = []\n                for block in code_blocks:\n                    examples.extend(extract_method(block, max_value, max_context))\n                if examples:\n                    datasets.append((dataset_name, examples))\n                    random_split_name = f'random_split_{dataset_type}_{max_value}_{max_context}'\n                    examples_split = TextUtils.random_split_middle_examples(examples, min_left=5, min_right=5)\n                    if examples_split:\n                        datasets.append((random_split_name, examples_split))\n        return datasets",
    "def math_function(function, values, input_coordinate=\"x_input\", polar=False):\n        if input_coordinate == \"x_input\":\n            x_values = values\n            y_values = np.array([function(x) for x in x_values])\n            curve = np.vstack((x_values, y_values)).T\n        elif input_coordinate == \"y_input\":\n            y_values = values\n            x_values = np.array([function(y) for y in y_values])\n            curve = np.vstack((x_values, y_values)).T\n        elif input_coordinate == \"value\":\n            result = [function(value) for value in values]\n            curve = np.array(result)\n        else:\n            print(\"Invalid input_coordinate, curve will default to 0,0\")\n            curve = np.array([[0.0, 0.0]])\n        if polar:\n            curve = CurveTransforms.polar_to_cartesian(curve)\n        return curve",
    "def visit_Call(self, node):\n        func_name = None\n        if isinstance(node.func, ast.Name):\n            func_name = node.func.id\n        elif isinstance(node.func, ast.Attribute):\n            parts = []\n            current = node.func\n            while isinstance(current, ast.Attribute):\n                parts.insert(0, current.attr)\n                current = current.value\n            if isinstance(current, ast.Name):\n                parts.insert(0, current.id)\n            func_name = \".\".join(parts)\n        args = [ast.get_source_segment(self.source_code, arg) for arg in node.args]\n        if func_name:\n            self.function_calls.append({\n                \"function\": func_name,\n                \"arguments\": args,\n                \"start_line\": node.lineno,\n                \"end_line\": node.end_lineno,\n                \"col_offset\": node.col_offset,\n                \"end_col_offset\": node.end_col_offset\n            })\n        self.generic_visit(node)",
    "def evaluate(self, generated, expected, check_syntax=False):\n        results = {}\n        results['exact_match'] = self.exact_match(generated, expected)\n        results['bleu'] = self.bleu_score(generated, expected)\n        results['rouge'] = self.rouge_score(generated, expected)\n        results['meteor'] = self.meteor_score(generated, expected)\n        results['bert'] = self.bert_score(generated, expected)\n        if check_syntax:\n            results['syntax_valid'] = self.syntax_validity(generated)\n        return results\n\n    def evaluate_batch(self, generated, expected, check_syntax=False):\n        results = {}\n        results['exact_match'] = self.\n        results['rouge'] = self.rouge_score(generated, expected)\n        results['meteor'] = self.meteor_score(generated, expected)\n        results['bert'] = self.bert_score(generated, expected)\n        if check_syntax:\n            results['syntax_valid'] = self.syntax_validity(generated)\n        return results",
    "def serrated_ring_arc(image, dpu=1000.0, segments=3, aligned=True, teeth_width=0.05, inner_radius=0.0,\n                          outer_radius=1.0, theta1=0.0, theta2=np.pi / 6):\n        segments = np.maximum(1, segments)\n        theta = np.linspace(theta1, theta2, segments)\n        inner_rho = np.ones(segments) * inner_radius\n        outer_rho = np.ones(segments) * outer_radius\n        if aligned:\n            inner_rho = inner_rho + teeth_width / 2.0\n            outer_rho = outer_rho - teeth_width / 2.0\n        curve1 = np.vstack((inner_rho, theta)).T\n        curve2 = np.vstack((outer_rho, np.flip(theta))).T\n        curve1 = CurveTransforms.polar_to_cartesian(curve1)\n        curve2 = CurveTransforms.polar_to_cartesian(curve2)\n        outline_curves = [curve1, curve2]\n        curve = np.vstack((curve1, curve2))\n        (image, extent, path) = ImageSlicer.sample_from_curve(image, curve, dpu)\n        return image, extent, path, outline_curves",
    "def collect_assignment_info(self, node):\n        if isinstance(node, ast.Assign):\n            targets = node.targets\n            value = node.value\n        elif isinstance(node, ast.AugAssign):\n            targets = [node.target]\n            value = node.value\n        elif isinstance(node, ast.AnnAssign):\n            targets = [node.target]\n            value = node.value\n        else:\n            return\n        start_line = node.lineno\n        end_line = node.end_lineno\n        end_col = node.end_col_offset\n        start_col = value.col_offset if hasattr(value, 'col_offset') else 0\n        for target in targets:\n            assignment_info = {\n                'name': target.id,\n              'start_line': start_line,\n              'start_col': start_col,\n                'end_line': end_line,\n                'end_col': end_col,\n            }\n            self.assignments.append(assignment_info)",
    "def __init__(self, image, extent, main_clip_path, local_outline_curves: List[np.ndarray] = None):\n        self.Image = image\n        self.Extent = extent\n        self.MainClipPath = main_clip_path\n        self.PersistentClipPaths = [main_clip_path]\n        self.PersistentTransforms = [Affine2D()]\n        self.AdditiveTransforms = [Affine2D()]\n        self.LocalOutlineCurves = local_outline_curves\n        self.AdditionalCurves = []\n\n    def __repr__(self):\n        return f\"ImageClip(Image={self.Image}, Extent={self.Extent}, MainClipPath={self.MainClipPath}, LocalOutlineCurves={self.LocalOutlineCurves}, AdditionalCurves={self.AdditionalCurves})\"\n\n    def __str__(self):\n        return f\"ImageClip(Image={self.Image}, Extent={self.Extent}, MainClipPath={self.MainClipPath},\n        else:\n            self.LocalOutlineCurves = []\n        self.AdditionalCurves = []",
    "def extract_function_call_details(lines: List[str], function_call: dict) -> Tuple[str, str, str]:\n        \"\"\"Extract the components of a function call: prefix, arguments, and suffix.\"\"\"\n        current_line, start_idx, end_idx = (\n            function_call['end_line'] - 1,\n            function_call['end_col_offset'] - 2,\n            function_call['end_col_offset'] - 1,\n        )\n        parentheses_balance = 1\n        while parentheses_balance > 0:\n            char = lines[current_line][start_idx]\n            parentheses_balance += 1 if char == ')' else -1 if char == '(' else 0\n            start_idx -= 1\n            if start_idx < 0:\n                current_line -= 1\n                start_idx = len(lines[current_line]) - 1\n        prefix = '\\n'.join(lines[function_call['start_line'] - 1:current_line] + [lines[current_line][:start_idx + 2]])\n        arguments = ', '.join(function_call['arguments'])\n        suffix = lines[function_call['end_line'] - 1][end_idx:]\n        return prefix, arguments, suffix",
    "def circular_placement(radius=0.5, repetitions: int = None, delta_angle: float = None, local_rotation_offset=0.0,\n                           global_rotation_offset=0.0, use_flip=False, flip_angle=0.0, reverse_rotation=False):\n        if repetitions is None and delta_angle is None:\n            repetitions = 1\n            angle = None\n        elif repetitions is None:\n            repetitions = np.trunc(2 * np.pi / delta_angle)\n            angle = None\n        elif delta_angle is None:\n            repetitions = np.maximum(1, repetitions)\n            angle = None\n        else:\n            repetitions = np.maximum(1, repetitions)\n            angle = delta_angle\n        if angle is None:\n            angle = 2 * np.pi / repetitions\n        if reverse_rotation:\n            angle = -angle\n        transforms = []\n        for i in range(repetitions):\n            if i % 2 == 0 or not use_flip:\n                trans_data = Affine2D().rotate(local_rotation_offset).translate(radius, 0).rotate(i * angle + global_rotation_offset)\n            else:\n                trans_data = Affine2D().rotate(-flip_angle).scale(1, -1).rotate(flip_angle + local_rotation_offset).translate(radius, 0).rotate(i * angle + global_rotation_offset)\n            transforms.append(trans_data)\n        return transforms",
    "def leaf(values=np.linspace(0, 1, 100), width=0.1, height=0.2, half=False):\n        control_nodes = np.array([[0, 0], [0, 1], [1, 1], [1, 0]])\n        curve = CurveTransforms.scale_single(control_nodes, (width, height), inplace=False)\n        curve = np.vstack((curve, np.flip(CurveTransforms.scale_single(curve, (-1, 1), inplace=False), 0)))\n        return curve\n\n    @staticmethod\n    def leaf_half(values=np.linspace(0, 1, 100), width=0.1, height=0.2, half=False):\n        control_nodes = np\n        if not half:\n            curve = np.vstack((curve, np.flip(CurveTransforms.scale_single(curve, (-1, 1), inplace=False), 0)))\n        return curve",
    "def plot(self, ax, image_outline_width=1.0):\n        for image in self.Images:\n            image.plot(ax, self.z_order, image_outline_width)\n            Figure.z_order += 1\n        for i in range(len(self.Curves)):\n            if self.PlotType[i] == \"outline\":\n                ax.fill(self.Curves[i][:, 0], self.Curves[i][:, 1], color=\"w\", zorder=self.z_order)\n            elif self.PlotType[i] == \"fill\":\n                ax.fill(self.Curves[i][:, 0], self.Curves[i][:, 1], color=\"k\", zorder=self.z_order)\n            elif self.PlotType[i] > 0:\n                ax.plot(self.Curves[i][:, 0], self.Curves[i][:, 1], color=\"k\", solid_capstyle='round',\n                         linewidth=self.PlotType[i], zorder=self.z_order)\n            elif self.PlotType[i] < 0:\n                ax.fill(self.Curves[i][:, 0], self.Curves[i][:, 1], color=\"w\", zorder=self.z_order)\n                ax.plot(self.Curves[i][:, 0], self.Curves[i][:, 1], color=\"k\", solid_capstyle='round',\n                         linewidth=self.PlotType[i], zorder=self.z_order)\n        Figure.z_order += 1",
    "def merge_regions(mask, regions, similarities, region1_id, region2_id):\n    new_id = min(region1_id, region2_id)\n    region1_info = regions[region1_id]\n    region2_info = regions[region2_id]\n    for neighbour in region1_info['neighbors']:\n        if neighbour < region1_id:\n            del similarities[(neighbour, region1_id)]\n        else:\n            del similarities[(region1_id, neighbour)]\n    similarities[(region1_id, region2_id)] = 0\n    for neighbour in region2_info['neighbors']:\n        if neighbour < region2_id:\n            del similarities[(neighbour, region2_id)]\n        else:\n            del similarities[(region2_id, neighbour)]\n    new_mask = np.logical_or(region1_info['mask'], region2_info['mask'])\n    mask[new_mask] = new_id\n    new_region = {\n        'mask': new_mask,\n        'neighbors': region1_info['neighbors'].union(region2_info['neighbors']),\n        'color_histogram': merge_histograms(region1_info['color_histogram'],\n                                            region1_info['size'],\n                                            region2_info['color_histogram'],\n                                            region2_info['size']),\n        'size': region1_info['size'] + region2_info['size'],\n    }\n    new_region['neighbors'].discard(new_id)\n    new_region['neighbors'].discard(max(region1_id, region2_id))\n    for neighbour in new_region['neighbors']:\n        similarity = histogram_intersection(region1_info['color_histogram'],\n                                            region1_info['size'],\n                                            regions[neighbour]['color_histogram'],\n                                            regions[neighbour]['size'])\n        if neighbour < new_id:\n            similarities[(neighbour, new_id)] = similarity\n        else:\n            similarities[(new_id, neighbour)] = similarity\n    del regions[region1_id]\n    del regions[region2_id]\n    regions[new_id] = new_region\n    for neighbor in regions[new_id]['neighbors']:\n        regions[neighbor]['neighbors'].discard(max(region1_id, region2_id))\n        regions[neighbor]['neighbors'].add(new_id)",
    "def min_swaps_to_transform(perm1, perm2):\n    n = len(perm1)\n    index_map = {value: i for i, value in enumerate(perm2)}  \n    perm1_mapped = [index_map[value] for value in perm1]  \n    visited = [False] * n\n    swaps = 0\n    for i in range(n):\n        if visited[i] or perm1_mapped[i] == i:\n            continue\n        cycle_length = 0\n        j = i\n        while not visited[j]:\n            visited[j] = True\n            j = perm1_mapped[j]\n            cycle_length += 1\n        if cycle_length > 0:\n            swaps += cycle_length - 1  \n    return swaps",
    "def pit_ring(image, dpu=1000.0, segments=8, pits_per_segment=1, inner_radius=0.5, outer_radius=0.8, width=0.8, depth=0.4, gap=0.2, sample_rotation=0.0,\n                   global_rotation=0.0, half=False, left_edge=False, right_edge=False) -> ImageSample:\n        outer_curve = (CurveGenerator.pit(100, width, gap, pits_per_segment), 1, outer_radius, depth, \"cartesian\")\n        inner_curve = (CurveTransforms.scale_single(CurveGenerator.pit(100, width, gap, pits_per_segment), 1, inner_radius, depth, \"cartesian\")\n        if half:\n            if left_edge:\n                outer_curve = (CurveTransforms.translate_single(outer_curve, 0, 0, -depth), 1, outer_radius, depth, \"cartesian\")\n                inner_curve = (CurveTransforms.translate_single(inner_curve, 0, 0, -depth), 1, inner_radius, depth, \"cartesian\")\n            else:\n                outer_curve = (CurveTransforms.\n        image_sample = ImageSample(image_sliced, extent, path, outline_curves)\n        ImageSampleTransformer.rotational_repeat_additive(image_sample, 2 * segments, None,\n                                                          rotation_offset=-sample_rotation+global_rotation, use_flip=True,\n                                                          flip_angle=(2 * sample_rotation + np.pi / segments) / 2)\n        return image_sample",
    "def split_indentation(line: str) -> Tuple[str, str]:\n        \"\"\"Separate leading whitespace from code text.\n\n        Args:\n            line: Line of code.\n\n        Returns:\n            Tuple of indentation and code text.\n        \"\"\"\n        indentation = line[:line.find(line.lstrip())]\n        indentation_length = len(indentation)\n        code_text = line[indentation_length:]\n        return indentation, code_text"
]