[
    "sforms.rotate_image_sample(image_sample, global_rotation, half, left_edge, right_edge,",
    "age_ar = width / height\n        x1 = np.min(curve[:, 0])",
    "e(node, ast.AugAssign):\n            targets = [node.target]",
    "    \"name\": func_name,\n                \"args\": args,\n                \"start_line\": node.lineno,\n                \"end_line\": node.end_lineno,\n                \"col_offset\": node.col_offset,\n                \"end_col_offset\": node.end_col_offset\n            })\n        else:\n            self.function_calls.append({\n                \"name\": \"unknown\",\n                \"args\": args,",
    "amples):\n        perm1 = np.random.permutation(n)",
    "ts.append((dataset_name, examples))\n        return datasets\n\n    def extract_random_splits(\n        self,\n        code_blocks: List[str],\n        max_values: List[int],\n        max_context_lines: List[int],\n        dataset_type: str,\n        extract_method: Callable[[str, Any, Any], List[Tuple[str, str, str]]]\n    ) -> List[Tuple[str, List[Tuple[str, str, str]]]]:\n        datasets = []\n        for max_value in max_values:\n            for max_context in max",
    "_line -= 1\n                start_idx = len(lines[current_line]) - 1\n        current_line += 1\n        start_idx += 1",
    "ign):\n            targets = [node.target]\n            value = node.value",
    "_curves([gap1, arc, gap2])\n        curves = []\n        for i in range(repetitions):",
    "image, dpu, segments, inner_curve, outer_curve, sample_rotation)\n        image_sample = ImageSample(image_sliced, extent, path, outline_curves)",
    "   else:\n            return",
    "ING{len(strings)}}}}}\"\n        strings[placeholder] = match.group(0)",
    "sform.to_cartesian(control_points)",
    "[key] += value\n                    counts[key] += 1",
    "r < new_id:\n            similarities[(neighbour, new_id)] = similarity\n        else:",
    "              break\n            prefix = prefix[:split_idx]\n            suffix = suffix[split_idx:]",
    "rho = np.ones(curve_cartesian[:, 1].shape) * rho_bounds[0]\n        else:",
    " region2_id)\n    region1_info = regions[region1_id]\n    region2_info = regions[region2_id]\n    del similarities[(region1_id, region2_id)]",
    " = np.ones(repetitions)",
    "holder = \"STRING_PLACEHOLDER_%s\" % len(strings)\n        strings[placeholder] = match.group(0)\n        return placeholder\n    code = re.sub(string_pattern, string_replacer, code, flags=re.DOTALL)\n    code = re.sub(comment_pattern, \"\", code)\n    for placeholder, original in strings.items():\n        code = code.replace(placeholder, original)\n    return code\n\ndef strip_comments_and_strings(code):\n    string_pattern = r\"(\\\"\\\"\\\".*?\\\"\\\"\\\"|'''.*",
    "  value = node.value\n        else:\n            return\n        if not isinstance(value, ast.Call):",
    "\n                for code_block in code_blocks:\n                    examples.extend(extract_method(code_block, max_value, max_context))",
    "xt_lines,",
    "Sample.rotate_image(image_sample, global_rotation, flip_angle=sample_rotation)\n        return image_sample\n\n    @staticmethod\n    def ring_type2(image, dpu=1000.0, segments=8, inner_radius=0.5, outer_radius=0.8, edge_width=0.05, sample_rotation=0.0,\n                   global_rotation=0.0, half=False, left_edge=False, right_edge=False) -> ImageSample:\n        inner_curve = (CurveGenerator.",
    "0 else num_lines - middle_end))\n            prefix = '\\n'.join(lines[start_prefix:middle_start])\n            middle_text = '\\n'.join(lines[middle_start:middle_end])",
    "e)\n        image_sample = ImageSample(image_sliced, extent, path, outline_curves, segments, dpu,",
    ".copy() for _ in range(subdivisions[0] * subdivisions[1])]\n        Transformer.scale_curves(diamonds, x_delta, y_delta)",
    "instance(node, ast.If):\n            condition = ast.get_source_segment(code, node.test)",
    "fix = max(0, middle_start - min_context_lines)\n            end_suffix = min(num_lines, middle_end + max_context_lines)",
    "tric\":\n            curve = np.array([function(x) for x in values])",
    "ts)+1))",
    "_source_line(arg) for arg in node.args]\n        if func_name:",
    "t use_flip:\n                trans_data = Affine2D().rotate(i * angle + rotation_offset)",
    "x = lines[function_call['end_line'] - 1][start_idx + 1:function_call['end_col_offset'] - 1]",
    "height, half)",
    "str]]]:\n    \"\"\"\n    Extracts datasets from code blocks.\n\n    :param code_blocks: List of code blocks.\n    :param max_values: List of maximum values to extract.\n    :param max_context_lines: List of maximum context lines to extract.\n    :param dataset_type: Type of dataset to extract.\n    :param extract_method: Method to extract examples.\n    :return: List of datasets.\n    \"\"\"\n    datasets = []\n    for max_value in max_values:",
    " np.vstack((x_values, y_values)).T\n        elif input_coordinate == \"value\":",
    "ode.func, ast.Name):\n            func_name = node.func.id",
    "sults['bleu'] = self.bleu_score(generated, expected)\n        results['rouge'] = self.rouge_score(generated, expected)\n        results['meteor'] = self.meteor_score(generated, expected)\n        results['bert'] = self.bert_score(generated, expected)\n        if check_syntax:\n            results['syntax_valid'] = self.syntax_validity(generated)\n        return results\n\n    def evaluate_batch(self, generated, expected, check_syntax=False):\n        results = {}\n        results['exact_match'] = self.",
    "eta1, theta2, segments)\n        inner_rho = np.ones(segments) * inner_radius\n        outer_rho = np.ones(segments) * outer_radius\n        if aligned:\n            inner_rho = inner_rho + teeth_width / 2.0\n            outer_rho = outer_rho - teeth_width / 2.0",
    "      'name': target.id,\n              'start_line': start_line,\n              'start_col': start_col,",
    "= [Affine2D()]\n        self.LocalOutlineCurves = local_outline_curves\n        self.AdditionalCurves = []\n\n    def __repr__(self):\n        return f\"ImageClip(Image={self.Image}, Extent={self.Extent}, MainClipPath={self.MainClipPath}, LocalOutlineCurves={self.LocalOutlineCurves}, AdditionalCurves={self.AdditionalCurves})\"\n\n    def __str__(self):\n        return f\"ImageClip(Image={self.Image}, Extent={self.Extent}, MainClipPath={self.MainClipPath},",
    "  while parentheses_balance > 0:\n            char = lines[current_line][start_idx]",
    "tions\n        if reverse_rotation:\n            angle = -angle",
    " 1], [1, 1], [1, 0]])\n        curve = CurveTransforms.scale_single(control_nodes, (width, height), inplace=False)\n        curve = np.vstack((curve, np.flip(CurveTransforms.scale_single(curve, (-1, 1), inplace=False), 0)))\n        return curve\n\n    @staticmethod\n    def leaf_half(values=np.linspace(0, 1, 100), width=0.1, height=0.2, half=False):\n        control_nodes = np",
    " range(len(self.Curves)):\n            if self.PlotType[i] == \"outline\":",
    "1_info['color_histogram'],\n                                            region1_info['size'],\n                                            regions[neighbour]['color_histogram'],\n                                            regions[neighbour]['size'])\n        if neighbour < new_id:\n            similarities[(neighbour, new_id)] = similarity",
    "] = True\n            j = perm1_mapped[j]\n            cycle_length += 1",
    "th, gap, pits_per_segment), 1, inner_radius, depth, \"cartesian\")\n        if half:\n            if left_edge:\n                outer_curve = (CurveTransforms.translate_single(outer_curve, 0, 0, -depth), 1, outer_radius, depth, \"cartesian\")\n                inner_curve = (CurveTransforms.translate_single(inner_curve, 0, 0, -depth), 1, inner_radius, depth, \"cartesian\")\n            else:\n                outer_curve = (CurveTransforms.",
    "ce from code text.\n\n        Args:\n            line: Line of code.\n\n        Returns:\n            Tuple of indentation and code text.\n        \"\"\"\n        indentation = line[:line.find(line.lstrip())]\n        indentation_length = len(indentation)"
]