[
    "lyline=False):\n        if polyline:\n            control_points = np.vstack((control_points, control_points[0]))\n        nodes = np.asfortranarray(control_points)",
    "debug_colors:\n            outline_color = ImageSample.outline_colors[ImageSample.current_outline]\n        else:\n            outline_color = [0.0, 0.0, 0.0]\n        for i in range(len(self.PersistentClipPaths)):\n            im = ax.imshow(self.Image, extent=self.Extent, origin=\"upper\", cmap=\"gray\", clip_on=True, interpolation=\"bicubic\",\n                           zorder=z_order, transform=self.PersistentTransforms[i])\n            im.set_clip_path(self.PersistentClipPaths[i], self.PersistentTransforms[i])\n            for curve in self.LocalOutlineCurves:\n                ax.plot(curve[:, 0], curve[:, 1], color=outline_color, solid_capstyle='round', transform",
    "nt = -1) -> Tuple[str, str, str]:\n        \"\"\"Extract section with character limit and surrounding context.\"\"\"\n        start_line, start_idx = start_pos\n        end_line, end_idx = end_pos\n        num_lines = len(lines)\n        if start_line >= num_lines or end_line >= num_lines:",
    "ne_thickness=0.5, debug_colors=False):\n        if debug_colors:\n            outline_color = ImageSample.outline_colors[ImageSample.current_outline]\n        else:",
    "[i] == \"plot\":\n                ax.plot(self.Curves[i][:, 0], self.Curves[i][:, 1], color=\"k\", zorder=self.z_order)\n            elif self.PlotType[i] == \"plot_dashed\":\n                ax.plot(self.Curves[i][:, 0], self.Curves[i][:, 1], color=\"k\", linestyle=\"--\", zorder=self.z_order)\n            elif self.PlotType[i] == \"plot_dotted\":\n                ax.plot(self.Curves[i][:, 0], self.Curves[i][:, 1], color=\"k\", linestyle=\":\", zorder=self.z_order)\n            elif self.PlotType[i] == \"",
    "to_polar(curve2, (radius2, radius2+width2), (theta1, theta1 + (theta2-theta1)/periods2))\n            curve2 = CurveTransforms.polar_to_cartesian(curve2)\n        else:",
    "n(middle) - min_right))\n                if split_idx > len(middle) - min_right:\n                    continue\n                new_examples.append((prefix, middle[:split_idx], middle[split_idx:]))\n                break",
    "np.vstack(curves)\n        return curve\n    @staticmethod\n    def polar_to_cartesian(polar_curve):\n        x = polar_curve[:, 0] * np.cos(polar_curve[:, 1])",
    "ode.func\n            while isinstance(current, ast.Attribute):\n                parts.append(current.attr)",
    "   image_sample = ImageSample(image_sliced, extent, path, outline_curves)\n        ImageSampleTransformer.rotational_repeat_additive(image_sample, 2 * segments, None,\n                                                          rotation_offset=-sample_rotation, use_flip=True,\n                                                          flip_angle=(2 * sample_rotation + np.pi / segments) / 2)\n        return image_sample\n    @staticmethod\n    def test_ring_type1(image, dpu=1000.0, segments=8, inner_radius=0.5, outer_radius=0.8, width=0.05, sample_rotation=0.0) -> ImageSample:\n        inner_curve = (CurveGenerator.edge_type1(), 1, inner_radius, width, \"cartesian\")",
    "_(self):\n        self.Curves = []\n        self.PlotType = []\n        self.Images = []",
    "set=(0.0, 0.0), polar=False):\n        curve = np.array([[0.0, 0.0]])\n        for i in range(n):\n            curve = np.vstack((curve, np.array([radius, 0.0])))\n            CurveTransforms.rotate_single(curve, 2 * np.pi / n, (0, 0))\n        CurveTransforms.translate_single(curve, offset[0], offset[1], inplace=True)\n        if polar:\n            curve = CurveTransforms.polar_to_cartesian(curve)\n        return curve\n    @staticmethod\n    def regular_polygon_with_hole(n, radius=1.0, hole_radius=0.5, offset=(0.0, 0.0), polar=False):\n        curve = Curve",
    "ed, expected)\n        results['meteor'] = self.meteor_score(generated, expected)\n        results['bert'] = self.bert_score(generated, expected)\n        if check_syntax:",
    "     code_blocks,\n            num_lines,\n            max_context_lines,\n            'lines',",
    "range(repetitions):\n            if i % 2 == 0 or not use_flip:\n                trans_data = Affine2D().rotate(i * angle + rotation_offset)\n            else:",
    "ds[1]-old_y_bounds[0]))\n        transform = transform.translate(new_x_bounds[0], new_y_bounds[0])\n        return CurveTransforms.apply_affine_single(curve, transform, inplace=True)\n    @staticmethod\n    def remap_polar_to_c2c(curve_polar, old_rho_bounds, old_theta_bounds, new_x_bounds, new_y_bounds):\n        return CurveTransforms.remap_c2c(curve_polar, old_theta_bounds, old_rho_bounds, new_x_bounds, new_y_bounds)\n    @staticmethod\n    def remap_c2c_to_polar(curve, extent):",
    "self, bounds):\n        if self.X_bounds is None:\n            self.X_bounds = bounds[0]\n            self.Y_bounds = bounds[1]",
    "sides+1))).T\n        curve = CurveTransforms.polar_to_cartesian(curve)\n        outline_curves = [curve]\n        (image, extent, path) = ImageSlicer.custom_ring_arc(image, dpu, inner_curve=None, outer_curve=curve,",
    "all in function_calls:\n            if len(call['args']) > max_arguments:\n                continue",
    " scale_curves(curves: \"list\", scale=1.0):\n        scale = np.array(scale)\n        if scale.size == 1:\n            scales = scale*np.ones(len(curves))\n        elif scale.size == 2:\n            scales = np.linspace(scale[0], scale[1], len(curves))\n        elif scale.size == len(curves):\n            scales = scale\n        else:\n            scales = np.ones(len(curves))\n        for i in range(len(curves)):\n            curves[i] *= scales[i]\n    @staticmethod",
    "ffineTransform(rotation=angle)\n        for i in range(len(curves)):\n            curves[i] = transform.transform(curves[i])",
    " str,\n        extract_method: Callable[[str, int, int], List[Tuple[str, str, str]]],\n    ) -> List[Tuple[str, List[Tuple[str, str, str]]]]:\n        datasets = []",
    "ines >= 0 else num_lines))\n        prefix = '\\n'.join(lines[start:start_line] + [lines[start_line][:start_idx]])\n        suffix = '\\n'.join([lines[end_line][end_idx:]] + lines[end_line + 1:end])\n        return prefix, middle_text, suffix\n    @staticmethod",
    "nt = None, delta_angle: float = None, rotation_offset=0.0, use_flip=False, flip_angle=0.0, reverse_rotation=False):\n        if repetitions is None and delta_angle is None:\n            repetitions = 1\n            angle = None\n        elif repetitions is None:",
    "aluate_curve_bounds(curve))\n    def add_image(self, image):\n        self.Images.append(image)\n    def append_figure(self, figure: \"Figure\"):\n        self.Curves.extend(figure.Curves)",
    "        curve = CurveGenerator.circular_arc(n, width/2, 0, np.pi, (0, 0))\n        curve = np.vstack((curve, np.flip(curve, 0)))\n        curve = np.vstack((curve, gap1, gap2))",
    "\n        curve = curve[:, ::-1]\n    @staticmethod\n    def reverse_curves(curves: \"list\"):",
    "r_to_polar(curve_polar, old_rho_bounds, old_theta_bounds, rho_bounds, theta_bounds):\n        transform = Affine2D().translate(-old_rho_bounds[0], -old_theta_bounds[0])\n        transform = transform.scale((rho_bounds[1]-rho_bounds[0])/(old_rho_bounds[1]-old_rho_bounds[0]),\n                                    (theta_bounds[1]-theta_bounds[0])/(old_theta_bounds[1]-old_theta_bounds[0]))\n        transform = transform.translate(rho_bounds[0], theta_bounds[0])\n        return transform.transform(curve_polar)",
    "ve[:, 1])\n        y = polar_curve[:, 0] * np.sin(polar_curve[:, 1])\n        return np.vstack((x, y)).T",
    "\n        curves.clear()\n        for i in range(repetitions):\n            new_curves = copy.deepcopy(curves)",
    "n range(segments)])\n        outer_rho = np.array([outer_radius - (i % 2) * teeth_width for i in range(segments)])\n        curve1 = np.vstack((inner_rho, theta)).T",
    " str) -> Tuple[str, str]:\n        \"\"\"Split a line into indentation and code text.\"\"\"\n        indentation = ''\n        code_text = line\n        while code_text and code_text[0] in'\\t':\n            indentation += code_text[0]\n            code_text = code_text[1:]",
    "ageSlicer.custom_ring_arc(image, dpu, inner_curve, outer_curve, theta1, theta2, left_side, right_side)\n        return image, extent, path, outline_curves\n    @staticmethod\n    def custom_ring_arc_from_sides(image, dpu=1000.0, sides=3, inner_radius=0.5, outer_radius=0.8, theta1=0.0, theta2=np.pi/6,\n                                   left_side=False, right_side=False) -> (np.ndarray, (float, float, float, float), Path, List[np.ndarray]):",
    "       for i in range(length):\n            results = self.evaluate(generated[i], expected[i], check_syntax)\n            for key in results:\n                total[key] += results[key]",
    "ds[0])\n        return CurveTransforms.apply_affine_single(curve, transform, inplace=True)\n    @staticmethod\n    def tight_remap_c2c(curve, extent):\n        x_bounds = (np.min(curve[:, 0]), np.max(curve[:, 0]))",
    "_line + 1:end_line] + [lines[end_line][end_idx:]]\n            )\n        )\n        if len(middle_text) > max_characters > 0:",
    " outline_curves = [curve1, curve2]\n        curve = np.vstack((curve1, curve2))",
    "      \"\"\"Extract assignment sections with character limit and surrounding context.\"\"\"\n        assignments = find_assignments(block)\n        lines = block.splitlines()\n        examples = []",
    "sforms.cartesian_to_polar(nodes)\n        curve = np.array([np.interp(value, values, nodes[:, 0]), np.interp(value, values, nodes[:, 1])]).T\n        if polar:\n            curve = CurveTransforms.polar_to_cartesian(curve)\n        return curve\n    @staticmethod",
    "gle + rotation_offset)\n            else:\n                trans_data = Affine2D().rotate(-flip_angle).scale(1, -1).rotate(flip_angle + rotation_offset)\n            transforms.append(trans_data)",
    "ine_curves = [np.vstack((curve1, curve2))]\n        curve = np.vstack((curve1, curve2))\n        (image, extent, path) = ImageSlicer.sample_from_curve(image, curve, dpu)",
    "(2 * sample_rotation + np.pi / segments) / 2)\n        return image_sample\n    @staticmethod\n    def sine_wave_ring_type1(image, dpu=1000.0, segments=8, periods_per_segment=3, period_offset=0.25, inner_radius=0.5,\n                             outer_radius=0.8, amplitude=0.1, sample_rotation=0.0) -> ImageSample:\n        (image_sliced, extent, path, outline_curves) = ImageSlicer.sine_wave_ring_arc_type1(image, dpu, periods_per_segment,\n                                                                                           period_offset, inner_radius, outer_radius, amplitude, sample_rotation, sample_rotation + np.pi /",
    " rotation_repeat_curves(curves: \"list\", number_of_segments=None, delta_angle=None, scale=1.0, reverse_rotation=False):\n        if number_of_segments is None and delta_angle is None:\n            repetitions = 1",
    "min_context_lines:\n                continue\n            prefix = '\\n'.join(lines[call['start_line'] - 1:call['start_line'] - 1 - (max_context_lines if max_context_lines >= 0 else call['start_line'] - 1)])\n            middle = '\\n'.join(call['arguments'])\n            suffix = '\\n'.join(lines[call['end_line']:call['end_line'] + 1 + (max_context_lines if max_context_lines >= 0 else num_lines)])\n            examples.append((prefix, middle, suffix))\n        return examples\n    @staticmethod\n    def extract_function_calls(block: str, max_arguments: int = 5, min_context_lines: int = 1, max_context_lines:",
    "        repetitions = np.trunc(2 * np.pi / delta_angle)\n            angle = None\n        elif delta_angle is None:",
    "a1=0.0, theta2=np.pi / 2, amplitude=0.1, period=1.0, period_offset=0.0, offset=(0.0, 0.0)):\n        theta = np.linspace(theta1, theta2, n)",
    "titions = np.maximum(1, repetitions)",
    "rve[:, 1], color=outline_color, linewidth=outline_thickness, zorder=z_order, transform=self.PersistentTransforms[i] + transform + ax.transData)\n            for curve in self.AdditionalCurves:\n                ax.plot(curve[:, 0], curve[:, 1], color=outline_color, linewidth=outline_thickness, zorder=z_order, transform=self.PersistentTransforms[i] + transform + ax.transData)\n            z_order += 0.001\n    def plot(self, ax: \"Axes\", z_order, outline_thickness=0.5, debug_colors=False):",
    "h, x_abs*dpu)), width-1)\n            new_height = int(new_width / clip_ar)\n        origin = (int(np.round(x1 * dpu)), int(np.round(y1 * dpu)))\n        new_height = np.minimum(new_height, height-1)\n        new_width = np.minimum(new_width, width-1)",
    "\n        Transformer.rotation_repeat_curves(figure.Curves, number_of_segments, delta_angle, scale)\n        figure.evaluate_bounds()\n    @staticmethod\n    def flip_horizontal(curves):"
]