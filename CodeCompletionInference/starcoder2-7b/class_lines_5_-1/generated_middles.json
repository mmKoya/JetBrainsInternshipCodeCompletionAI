[
    "raise ValueError(\"Either number_of_segments or delta_angle must be specified\")",
    "y_values = values\n            x_values = np.array([function(y) for y in y_values])\n            curve = np.vstack((x_values, y_values)).T\n        elif input_coordinate == \"xy_input\":\n            result = []\n            for x in values:\n                for y in values:\n                    result.append([x, function(x, y)])",
    "return CurveTransforms.apply_affine_multi(curves, transform, inplace)\n    @staticmethod\n    def translate_single(curve: np.ndarray, x=0.0, y=0.0, inplace=True) -> np.ndarray:\n        transform = Affine2D().translate(x, y)\n        return CurveTransforms.apply_affine_single(curve, transform, inplace)",
    "\"func_name\": func_name,\n                \"args\": args,\n                \"start_line\": node.lineno,\n                \"start_col_offset\": node.col_offset,\n                \"end_line\": node.end_lineno,",
    "elif left_side:\n            outline_curves = [np.vstack((curve1, curve2, np.array([[curve1[0, 0], curve1[0, 1]]])))]\n        elif right_side:\n            outline_curves = [np.vstack((curve2, curve1, np.array([[curve2[0, 0], curve2[0, 1]]])))]\n        else:",
    "outline_curves = [inner_curve, outer_curve]\n        curve = np.vstack((inner_curve, outer_curve))\n        (image, extent, path) = ImageSlicer.sample_from_curve(image, curve, dpu)\n        return image, extent, path, outline_curves\n    @staticmethod\n    def sine_wave_ring_arc_with_teeth(image, dpu=1000.0, n_periods=2, period_offset=0.25, inner_radius=0.5, outer_radius=0.8,\n                                      amplitude=0.1, theta1=0.0, theta2=np.pi/2, teeth_width=0.05):\n        inner_curve = CurveGenerator.sine_wave_circular_arc(100, inner_radius+amplitude, theta1, theta2, amplitude, n",
    "(image, extent, path) = ImageSlicer.sample_from_curve(image, curve, dpu)\n        return image, extent, path, outline_curves\n    @staticmethod\n    def ring_arc_with_teeth(image, dpu=1000.0, teeth_width=0.05, inner_radius=0.5, outer_radius=0.8, theta1=0.0, theta2=np.pi/6, aligned=False):\n        segments = int(np.ceil((theta2 - theta1) / (2 * teeth_width)))",
    "curve = np.vstack((curve, np.flip(curve, 0)))\n        return CurveTransforms.merge_curves([triangle1, curve, triangle2])\n    @staticmethod\n    def edge_type2(width=1.0, height=0.2, flip=False, half=False):\n        if flip:\n            height = -height\n        triangle1 = np.array([[0, 0], [0.1*width, height], [0.2*width, 0]])\n        triangle2 = np.array([[0.8*width, 0], [0.9*width, height], [width, 0]])\n        curve_nodes = np.array([[0.2*width, 0], [0.4*width, height], [0.6*width, height], [0.8*width, 0]])\n        curve = CurveGenerator.bezier(curve_nodes, np.",
    "parts.insert(0, current.id)\n            func_name = \".\".join(parts)\n        args = []\n        for arg in node.args:\n            if isinstance(arg, ast.Name):\n                args.append(arg.id)\n            elif isinstance(arg, ast.Str):\n                args.append(arg.s)\n            elif isinstance(arg, ast.Num):\n                args.append(arg.n)\n            elif isinstance(arg, ast.Tuple):\n                args.append(tuple([self.visit(x) for x in arg.elts]))\n            elif isinstance(arg, ast.List):\n                args.append(list([self.visit(x) for x in arg.elts]))\n            elif isinstance(arg, ast.Dict):\n                args.append(dict([(self.visit(k), self.visit(v)) for k, v in zip(arg.keys, arg.values)]))\n            elif isinstance",
    "curve = np.array([np.interp(value, nodes[:, 0], nodes[:, 1]) for value in values])\n        else:\n            curve = np.array([np.interp(value, nodes[:, 0], nodes[:, 1]) for value in values])\n        return curve\n    @staticmethod\n    def function(function, values=np.linspace(0.0, 1.0, 100), input_coordinate=\"x_input\", polar=False):\n        if input_coordinate == \"x_input\":\n            x_values = values\n            y_values = np.array([function(x) for x in x_values])\n            curve = np.vstack((x_values, y_values)).T\n        elif input_coordinate == \"y_input\":\n            y_values = values\n            x_values = np.array([function(y) for y in y_values])\n            curve = np.v",
    "curves[i][0, :] = -curves[i][0, :]\n    @staticmethod\n    def flip_vertical(curves):\n        for i in range(len(curves)):\n            curves[i][1, :] = -curves[i][1, :]\n    @staticmethod\n    def flip_figure(figure: \"Figure\", horizontal=True, vertical=True):\n        if horizontal:\n            Transformer.flip_horizontal(figure.Curves)\n        if vertical:\n            Transformer.flip_vertical(figure.Curves)\n        figure.evaluate_bounds()",
    "self.function_calls.append({\n                \"func_name\": func_name,\n                \"args\": args,\n                \"lineno\": node.lineno,",
    "dataset_name = f'{dataset_type}_{max_value}_{max_context}'\n                examples = extract_method(code_blocks, max_value, max_context)\n                if examples:",
    "def evaluate_curve_bounds(self, curve):\n        x = curve[:, 0]\n        y = curve[:, 1]\n        rho = np.sqrt(x**2 + y**2)\n        theta = np.arctan2(y, x)\n        x_bounds = (np.min(x), np.max(x))\n        y_bounds = (np.min(y), np.max(y))",
    "def fit_polar(curve, extent):\n        rho_bounds = (np.min(curve[:, 0]), np.max(curve[:, 0]))\n        theta_bounds = (np.min(curve[:, 1]), np.max(curve[:, 1]))\n        return CurveTransforms.remap_polar_to_polar(curve, rho_bounds, theta_bounds, extent[0:2], extent[2:4])\n    @staticmethod\n    def fit_polar_tight(curve, extent):\n        rho_bounds = (np.min(curve[:, 0]), np.max(curve[:, 0]))\n        theta_bounds = (np.min(curve[:, 1]), np.max(curve[:, 1]))\n        return CurveTransforms.square_map_cartesian_to_polar(curve, theta_bounds, rho_bounds, extent[0:2], extent[2:4])\n    @staticmethod\n    def fit",
    "new_figure = Figure()\n        new_figure += self\n        new_figure += figure\n        return new_figure\n    def __radd__(self, figure: \"Figure\"):\n        new_figure = Figure()\n        new_figure += figure\n        new_figure += self\n        return new_figure\n    def __sub__(self, figure: \"Figure\"):\n        new_figure = Figure()\n        new_figure += self\n        new_figure -= figure\n        return new_figure\n    def __rsub__(self, figure: \"Figure\"):\n        new_figure = Figure()\n        new_figure += figure\n        new_figure -= self\n        return new_figure\n    def __isub__(self, figure: \"Figure\"):\n        if isinstance(figure, Figure):\n            self.append_figure(figure)\n        else:",
    " local_rotation_offset=0.0,",
    "transform = Affine2D().translate(x, y)\n        return CurveTransforms.apply_affine_multi(curves, transform, inplace)\n    @staticmethod\n    def scale_single(curve: np.ndarray, scale=(1.0, 1.0), pivot=(0.0, 0.0), inplace=True) -> np.ndarray:\n        transform = Affine2D().translate(-pivot[0], -pivot[1]).scale(scale[0], scale[1]).translate(pivot[0], pivot[1])",
    "@staticmethod\n    def translate_multi(curves: List[np.ndarray], x=0.0, y=0.0, inplace=True) -> List[np.ndarray]:\n        transform = Affine2D().translate(x, y)\n        return CurveTransforms.apply_affine_multi(curves, transform, inplace)\n    @staticmethod",
    "interpolated_curve = interpolate.interp1d(curve[:, 0], curve[:, 1], kind=kind, axis=0)(np.linspace(curve[0, 0], curve[-1, 0], samples))\n        if inplace:",
    "def sample_from_curve_with_outline(image, curve, dpu=1000.0, outline_curves=None):\n        if outline_curves is None:\n            outline_curves = [curve]\n        height = image.shape[0]\n        width = image.shape[1]\n        image_ar = width / height\n        x1 = np.min(curve[:, 0])\n        x2 = np.max(curve[:, 0])\n        y1 = np.min(curve[:, 1])\n        y2 = np.max(curve[:, 1])\n        extent = (x1, x2, y1, y2)\n        x_abs = x2 - x1\n        y_abs = y2 - y1\n        clip_ar = x_abs / y_abs\n        if clip_ar < image_ar:\n            new_height = np.minimum(int(np.",
    "curve2 = np.vstack((outer_rho, theta)).T\n        curve = np.vstack((curve1, curve2))\n        outline_curves = [curve1, curve2]",
    "image_sample = ImageSample(image_sliced, extent, path, outline_curves)\n        ImageSampleTransformer.rotational_repeat_additive(image_sample, 2 * segments, None,\n                                                          rotation_offset=-sample_rotation+global_rotation, use_flip=True,\n                                                          flip_angle=(2 * sample_rotation + np.pi / segments) / 2)\n        return image_sample\n    @staticmethod\n    def leaf_ring(image, dpu=1000.0, segments=8, inner_radius=0.5, outer_radius=0.8, width=0.1, sample_rotation=0.0, global_rotation=0.0, left_edge=False, right_edge=False):\n        (image_sliced, extent, path, outline_curves) = ImageSlicer.leaf(image, dpu, width, outer_radius-",
    "if self.PlotType[i] > 0:\n                ax.fill(self.Curves[i][:, 0], self.Curves[i][:, 1], color=\"w\", zorder=self.z_order)",
    "def translate_single(curve: np.ndarray, x=0.0, y=0.0, inplace=True) -> np.ndarray:\n        transform = Affine2D().translate(x, y)\n        return CurveTransforms.apply_affine_single(curve, transform, inplace)\n    @staticmethod\n    def translate_multi(curves: List[np.ndarray], x=0.0, y=0.0, inplace=True) -> List[np.ndarray]:",
    "np.maximum(self.X_bounds[1], bounds[0][1]))\n            self.Y_bounds = (np.minimum(self.Y_bounds[0], bounds[1][0]),\n                             np.maximum(self.Y_bounds[1], bounds[1][1]))\n            self.Rho_bounds = (np.minimum(self.Rho_bounds[0], bounds[2][0]),\n                               np.maximum(self.Rho_bounds[1], bounds[2][1]))",
    "image_ar = width / height\n        x1, y1 = curve[0, :]\n        x2, y2 = curve[-1, :]",
    "self.classes = []\n    def visit_FunctionDef(self, node):\n        function_source = ast.get_source_segment(self.code, node)\n        self.functions.append(function_source)\n        self.generic_visit(node)",
    "if angle is None:\n            angle = 2*np.pi/repetitions\n        if reverse_rotation:\n            angle = -angle\n        if angle.size == 1:\n            angles = angle*np.ones(repetitions)\n        elif angle.size == 2:\n            angles = np.linspace(angle[0], angle[1], repetitions)\n        elif angle.size == repetitions:\n            angles = angle\n        else:\n            angles = np.ones(repetitions)\n        base_curves = copy.deepcopy(curves)\n        Transformer.rotate_curves(curves, angles[0])\n        for i in range(1, repetitions):\n            new_curves = copy.deepcopy(base_curves)\n            Transformer.rotate_curves(new_curves, i*angle)\n            curves.extend(new_curves)",
    "for i in range(len(curves)):\n            curves[i] = np.hstack(curves[i])\n    @staticmethod\n    def reverse_curve(curve):",
    "image_sample.PersistentTransforms.extend(new_persistent_transforms)\n        return\n    @staticmethod\n    def additive_transforms(image_sample: ImageSample, additive_transforms: list):",
    "curve2 = CurveGenerator.circular_arc(100, outer_radius, theta1, theta2)\n        outline_curves = [curve1, curve2]\n        curve = np.vstack((curve1, curve2))\n        (image, extent, path) = ImageSlicer.sample_from_curve(image, curve, dpu)\n        return image, extent, path, outline_curves\n    @staticmethod\n    def ring_arc_with_center(image, dpu=1000.0, inner_radius=0.0, outer_radius=1.0, theta1=0.0, theta2=np.pi / 6, center_radius=0.1, center_width=0.05):\n        curve1 = CurveGenerator.circular_arc(100, inner_radius, theta1, theta2)\n        curve2 = CurveGenerator.circular_arc",
    "def serrated_ring_type1(image, dpu=1000.0, segments=8, teeth_per_segment=3, aligned=True, teeth_width=0.05, inner_radius=0.5,\n                      outer_radius=0.8, sample_rotation=0.0) -> ImageSample:\n        inner_curve = (CurveGenerator.edge_type1(half=True), 1, inner_radius, teeth_width, \"cartesian\")\n        outer_curve = (CurveGenerator.edge_type1(half=True), 1, outer_radius, teeth_width, \"cartesian\")\n        (image_sliced, extent, path, outline_curves) = ImageSlicer.custom_ring_arc(image, dpu, inner_curve, outer_curve, sample_rotation,\n                                                                                   sample_rotation + np.pi",
    "    return self\n    def __add__(self, figure: \"Figure\"):\n        new_figure = Figure()\n        new_figure += self\n        new_figure += figure\n        return new_figure\n    def __radd__(self, figure: \"Figure\"):\n        new_figure = Figure()\n        new_figure += figure\n        new_figure += self\n        return new_figure\n    def __sub__(self, figure: \"Figure\"):\n        new_figure = Figure()\n        new_figure += self\n        new_figure -= figure\n        return new_figure\n    def __rsub__(self, figure: \"Figure\"):\n        new_figure = Figure()\n        new_figure += figure\n        new_figure -= self\n        return new_figure\n    def __isub__(self, figure: \"Figure\"):\n        if isinstance(figure, Figure):\n            for i in range(len(figure.Curves)):\n                for j in range(len(self.Curves)):\n                    if np",
    "outline_curves = [np.vstack((curve2, curve1))]\n        else:\n            outline_curves = [curve1, curve2]\n        curve = np.vstack((curve1, curve2))\n        (image, extent, path) = ImageSlicer.sample_from_curve(image, curve, dpu)",
    "def extract_middle_sections(block: str, middle_line_count: int = 1, max_characters: int = 100, min_context_lines: int = 1, max_context_lines: int = -1) -> List[Tuple[str, str, str]]:\n        \"\"\"Extract middle sections with character limit and surrounding context.\"\"\"\n        lines = block.splitlines()\n        num_lines = len(lines)\n        if num_lines < min_context_lines + middle_line_count + max_context_lines:",
    "lines = block.splitlines()\n        examples = []\n        for start_pos, end_pos in assignments:\n            result = CodeSegmentExtractor.extract_section(lines, start_pos, end_pos, max_characters, min_context_lines, max_context_lines)\n            if result:",
    "return affine.transform(curve)\n    @staticmethod\n    def apply_affine_multi(curves: List[np.ndarray], affine: Affine2D, inplace=True) -> List[np.ndarray]:\n        if inplace:\n            for i in range(len(curves)):",
    "targets = [node.target]\n            value = node.value\n        elif isinstance(node, ast.AnnAssign):\n            targets = [node.target]\n            value = node.value",
    "split_idx = random.randint(min_left, len(middle) - min_right)\n            prefix = prefix + middle[:split_idx]",
    "rho = radius * np.ones(n)\n        curve = CurveTransforms.polar_to_cartesian(np.vstack((rho, theta)).T)\n        CurveTransforms.translate_single(curve, offset[0], offset[1], inplace=True)\n        return curve\n    @staticmethod",
    "new_curves = copy.deepcopy(base_curves)\n            curves.extend(new_curves)\n    @staticmethod\n    def translation_repeat_figure(figure: \"Figure\", repetitions=(2, 2), step=(0.1, 0.1)):\n        Transformer.translation_repeat_curves(figure.Curves, repetitions, step)\n        figure.evaluate_bounds()\n    @staticmethod\n    def remove_curves(curves: \"list\", indices=None):\n        if indices is None:\n            indices = np.arange(len(curves))\n        for i in np.sort(indices)[::-1]:\n            del curves[i]\n    @staticmethod\n    def remove_figure(figure: \"Figure\", indices=None):\n        Transformer.remove_curves(figure.Curves, indices)\n        figure.evaluate_bounds()\n    @staticmethod\n    def remove_curve(curve):",
    "self.Image = image\n    def add_persistent_clip_path(self, clip_path, transform):\n        self.PersistentClipPaths.append(clip_path)\n        self.PersistentTransforms.append(transform)\n    def add_local_outline_curve(self, curve):\n        self.LocalOutlineCurves.append(curve)",
    "curve = np.vstack((x_values, y_values)).T\n        return curve\n    @staticmethod\n    def circular_arc(n=100, radius=1.0, theta1=0.0, theta2=np.pi, offset=(0.0, 0.0)):\n        theta = np.linspace(theta1, theta2, n)\n        rho = radius * np.ones(n)",
    "sliced_image = cv2.resize(sliced_image, (new_width, new_height))\n        path = Path(curve - origin)\n        return sliced_image, extent, path\n    @staticmethod\n    def random_edge(grid_size=(5, 5), step_size=(1, 1), interpolation=\"spline\"):\n        grid_size = np.array(grid_size)\n        step_size = np.array(step_size)\n        grid_size = np.maximum(grid_size, 1)\n        step_size = np.maximum(step_size, 1)\n        grid_size = np.minimum(grid_size, 100)\n        step_size = np.minimum(step_size, 100)\n        grid_size = np.maximum(grid_size, 1)\n        step_size = np.maximum(step_size, 1",
    "try:\n            return sentence_chrf(expected, generated)\n        except Exception as e:\n            print(f\"Error calculating ChrF score: {e}\")\n            return None",
    "value = node.value\n        else:\n            return\n        start_line = node.lineno\n        end_line = node.end_lineno",
    "self.AdditionalCurves.append(curve)\n    def add_persistent_clip_path(self, clip_path, transform):\n        self.PersistentClipPaths.append(clip_path)\n        self.PersistentTransforms.append(transform)\n    def set_main_clip_path(self, clip_path, transform):\n        self.MainClipPath = clip_path\n        self.PersistentClipPaths = [clip_path]\n        self.PersistentTransforms = [transform]\n    def set_main_clip_path_and_transform(self, clip_path, transform):\n        self.MainClipPath = clip_path\n        self.PersistentClipPaths = [clip_path]\n        self.PersistentTransforms = [transform]\n    def set_main_clip_path_and_transforms(self, clip_path, transforms):\n        self.MainClipPath = clip_path\n        self.PersistentClipPaths = [clip_path]\n        self",
    "def interpolate_curve(curve, samples, inplace=True):\n        interpolated_curve = interpolate.interp1d(curve[:, 0], curve[:, 1], kind='cubic', axis=0, fill_value=\"extrapolate\")(np.linspace(curve[0, 0], curve[-1, 0], samples))",
    "if i % 2 == 0 or not use_flip:\n                trans_data = Affine2D().rotate(rotation_offset).translate(0, 0).rotate(i * angle)\n            else:\n                trans_data = Affine2D().rotate(-flip_angle).scale(1, -1).rotate(flip_angle + rotation_offset).translate(0, 0).rotate(i * angle)\n            transforms.append(trans_data)"
]