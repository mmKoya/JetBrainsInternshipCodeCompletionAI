[
    "\"\"\"\n        Generates a random edge.\n        \"\"\"\n        control_nodes = []\n        for i in range(2):\n            control_nodes.append(np.random.uniform(0, grid_size[i], 1))\n        control_nodes = np.array(control_nodes)\n        if interpolation_type == \"bezier\":\n            curve = CurveGenerator.bezier(control_nodes)\n        elif interpolation_type == \"linear\":\n            curve = control_nodes\n        else:\n            curve = CurveTransforms.interpolate(control_nodes, 100, \"cubic\", False)\n        return curve\n\n    @staticmethod\n    def random_curve(grid_size=(1,1), grid_step=(0.1, 0.1), interpolation_type=\"bezier\"):\n        \"\"\"\n        Generates a random curve.\n        \"\"\"\n        control_nodes = []\n       ",
    "                        outer_radius=0.1, **kwargs):\n    \"\"\"\n    Creates a serrated ring arc.\n\n    :param image: The image to be modified.\n    :param dpu: The distance per unit.\n    :param segments: The number of segments.\n    :param aligned: Whether the teeth are aligned.\n    :param teeth_width: The width of the teeth.\n    :param inner_radius: The inner radius of the arc.\n    :param outer_radius: The outer radius of the arc.\n    :param kwargs: Additional arguments.\n    :return: The modified image.\n    \"\"\"\n    theta = np.linspace(0, 2 * np.pi, segments + 1)",
    "targets = [node.target]\n            value = node.annotation\n        else:\n            return\n        if not isinstance(value, ast.Call):",
    "results['bleu'] = self.bleu_score(generated, expected)\n        results['rouge'] = self.rouge_score(generated, expected)",
    "for assignment in assignments:\n            start_line = assignment.start_line - min_context_lines\n            end_line = assignment.end_line + max_context_lines\n            if start_line < 0:\n                start_line = 0\n            if end_line >= len(lines):\n                end_line = len(lines) - 1\n            context = \"\\n\".join(lines[start_line:end_line])\n            if len(context) > max_characters:\n                context = context[:max_characters]\n            result = (assignment.name, assignment.value, context)",
    "x_fine = np.linspace(curve[0, 0], curve[0, -1], samples)\n        y_fine = interpolate.interp1d(curve[0, :], curve[1, :], kind=kind)(x_fine)",
    "for i in range(len(self.Curves)):\n            if self.PlotType[i] == \"line\":\n                ax.plot(self.Curves[i][:, 0], self.Curves[i][:, 1], color=\"k\", zorder=self.z_order)",
    "path = Path(image)\n        extent = (0, 1, 0, 1)\n        image_sliced = ImageSampleTransformer.slice_image(image, extent, dpu, segments, inner_radius, outer_radius, width,",
    "curves.extend(new_curves)\n        for y in range(1, y_repetitions):",
    "self.X = None\n        self.Y = None\n        self.Rho = None\n        self.Theta = None",
    "ax.fill(self.Curves[i][:, 0], self.Curves[i][:, 1], color=\"w\", zorder=self.z_order)\n                ax.plot(self.Curves[i][:, 0], self.Curves[i][:, 1], color=\"k\", solid_capstyle='round',",
    "func_name = node.func.id\n        elif isinstance(node.func, ast.Attribute):\n            parts = []",
    "self.Extent = extent\n        self.MainClipPath = main_clip_path",
    "scales = np.linspace(scale[0], scale[1], repetitions)",
    "function_call['start_line'],\n            function_call['start_idx'],\n            function_call['end_idx'],",
    "clip_ar = x_abs / y_abs\n        if image_ar > clip_ar:\n            new_height = np.minimum(int(np.minimum(height, y_abs*dpu)), height-1)",
    "rho = (curve_cartesian[:, 1] - y_bounds[0]) / (y_bounds[1] - (y_bounds[0])) * (rho_bounds[1] - rho_bounds[0]) + rho_bounds[0]\n        if x_bounds[0] == x_bounds[1]:",
    "function_call['end_idx'] - 1,\n            function_call['end_idx']\n        )\n        while current_line > function_call['start_line'] - 1:\n            char = lines[current_line][start_idx]\n            if char == '(':\n                parentheses_balance = 1\n                while parentheses_balance:\n                    char = lines[current_line][start_idx]\n                    parentheses_balance += 1 if char == ')' else -1 if char == '(' else 0\n                    start_idx -= 1\n                    if start_idx < 0:\n                        current_line -= 1\n                        start_idx = len(lines[current_line]) - 1\n                break\n            start_idx -= 1\n            if start_idx < 0:\n                current_line -= 1\n                start_idx = len",
    "results = {}\n        results['bleu'] = self.bleu_score(generated, expected)\n        results['rouge'] = self.rouge_score(generated, expected)\n        results['meteor'] = self.meteor_score(generated, expected)\n        results['bert'] = self.bert_score(generated, expected)\n        if check_syntax:\n            results['syntax_valid'] = self.syntax_validity(generated)\n        return results\n\n    def evaluate_batch(self, generated, expected, check_syntax=False):\n        results = {}",
    "curve1 = CurveTransforms.tight_remap_polar_to_polar(curve1, (radius1, radius1+width1), (theta1, theta1 + (theta2-theta1)/periods1))\n                curve1 = CurveTransforms.polar_to_cartesian(curve1)\n            else:",
    "if image_ar > clip_ar:\n            new_height = np.minimum(int(np.minimum(height, y_abs*dpu)), height-1)\n            new_width = int(new_height * clip_ar)",
    "dataset_name = f'{dataset_type}_{max_value}_{max_context}'\n                examples = []\n                for block in code_blocks:",
    "                   segments=segments,",
    "start_line, start_idx = start_pos\n        end_line, end_idx = end_pos\n        if start_line < 0 or start_line >= num_lines or end_line < 0 or end_line >= num_lines:\n            return None\n        if start_idx < 0 or start_idx >= len(lines[start_line]) or end_idx < 0 or end_idx >= len(lines[end_line]):\n            return None\n        if start_line == end_line and start_idx >= end_idx:",
    "self.MainClipPath = main_clip_path\n        self.LocalClipPaths = []",
    "'image': image[region_mask],\n            'centroid': np.mean(image[region_mask], axis=0),\n            'area': np.sum(region_mask),\n            'perimeter': np.sum(np.any(np.diff(region_mask, axis=0), axis=0) + np.any(np.diff(region_mask, axis=1), axis=0)),\n            'bbox': np.array(region_mask.nonzero()).T,\n            'bbox_area': np.prod(np.diff(np.array(region_mask.nonzero()).T, axis=0)),\n            'bbox_perimeter': np.sum(np.any(np.diff(region_mask, axis=0), axis=0) + np.any(np.diff(region_",
    "y2 = np.max(curve[:, 1])\n        x_abs = x2 - x1",
    "self.X_bounds = bounds[0]\n            self.Y_bounds = bounds[1]\n            self.Rho_bounds = bounds[2]",
    "'neighbors': region1_info['neighbors'].union(region2_info['neighbors']),\n        'color_histogram': color_histogram(new_mask,\n                                            region1_info['color_histogram'],",
    "repetitions = np.maximum(1, number_of_segments)\n            angle = None\n        elif delta_angle is None:",
    "else:\n            repetitions = np.maximum(1, repetitions)\n            angle = delta_angle",
    "condition = ast.get_source_segment(code, node.test)\n            start_line = node.test.lineno\n            start_col = node.test.col_offset",
    "datasets.append((dataset_name, examples))\n        return datasets\n\n    def extract_random_splits(\n        self,\n        code_blocks: List[str],\n        max_values: List[int],\n        max_context_lines: List[int],\n        dataset_type: str,\n        extract_method: Callable[[str, Any, Any], List[Tuple[str, str, str]]]\n    ) -> List[Tuple[str, List[Tuple[str, str, str]]]]:\n        datasets = []\n        for max_value in max_values:\n            for max_context in max_context_lines:\n                dataset_name = f'{dataset_type}_{max_value}_{max_context}'\n                examples = []\n                for block in code_blocks:\n                    examples.extend(extract_method(block, max_value, max_",
    "scales = scale\n        else:\n            raise ValueError(\"scale must be a scalar, a vector of length 1 or 2, or a vector of length repetitions\")\n        curves = copy.deepcopy(curves)\n        Transformer.scale_curves(curves, scales[0])\n        for i in range(1, repetitions):\n            new_curves = copy.deepcopy(curves)\n            Transformer.rotate_curves(new_curves, i*angle)\n            Transformer.scale_curves(new_curves, scales[i])\n            curves.extend(new_curves)\n        return curves\n\n    @staticmethod\n    def scale_curves(curves: \"list\", scale: float):\n        for curve in curves:\n            curve.scale(scale)\n\n    @staticmethod\n    def rotate_curves(curves: \"",
    "code_blocks: List[str],\n        max_values: List[int],\n        max_context_lines: List[int],",
    "else:\n            rho = (curve_cartesian[:, 1] - y_bounds[0]) / (y_bounds[1] - (y_bounds[0])) * (rho_bounds[1] - rho_bounds[0]) + rho_bounds[0]",
    "code_blocks,\n            max_characters,\n            max_context_lines,",
    "elif scale.size == repetitions:",
    "curve1 = CurveTransforms.tight_map_cartesian_to_polar(curve1, (radius1, radius1+width1), (theta1, theta1 + (theta2-theta1)/periods1))\n        curve1 = CurveTransforms.polar_to_cartesian(curve1)\n        curve1 = np.flip(np.vstack([CurveTransforms.rotate_single(curve1, i*(theta2-theta1)/periods1, inplace=False) for i in range(0, periods1)]), 0)\n        if outer_curve is None:\n            curve2 = np.array([[0, 0]])\n        else:",
    "if local_outline_curves is not None:",
    "    ax.plot(self.Curves[i][:, 0], self.Curves[i][:, 1], color=\"k\", solid_capstyle='round',\n                         linewidth=self.PlotType[i], zorder=self.z_order)\n            elif self.PlotType[i] > 0:\n                ax.fill(self.Curves[i][:, 0], self.Curves[i][:, 1], color=\"w\", zorder=self.z_order)",
    "if right_side:",
    "if outer_curve is None:\n            curve2 = np.array([[0, 0]])\n        else:\n            (curve2, periods2, radius2, width2, coordinate_type2) = outer_curve\n            if coordinate_type2 == \"polar\":\n                curve2 = CurveTransforms.tight_remap_polar_to_polar(curve2, (radius2 - width2, radius2), (theta1, theta1 + (theta2-theta1)/periods2))\n                curve2 = CurveTransforms.polar_to_cartesian(curve2)\n            else:\n                curve2 = np.vstack((-curve2[:, 0], curve2[:, 1])).T\n                curve2 = CurveTransforms.tight_map_cartesian_to_polar(curve2, (radius2 - width2, radius2), (",
    "return extract_sections(\n            code_blocks,\n            max_characters,",
    "angle = None\n        else:",
    "diamonds = []\n        for i in range(subdivisions[0]):\n            for j in range(subdivisions[1]):\n                diamonds.append(Diamond(x_bounds[0] + i * x_delta, y_bounds[0] + j * y_delta, x_delta, y_delta))",
    "raise ValueError(\"Either number_of_segments or delta_angle must be specified\")\n        elif number_of_segments is None:",
    "path = Path()\n        extent = Extent(0, 0, 0, 0)\n        outline_curves = []\n        for i in range(segments):\n            path.add_arc(dpu, inner_radius, outer_radius, width, depth, gap,\n                         sample_rotation + i * 2 * np.pi / segments, left_edge, right_edge)\n            outline_curves.append(path.get_outline_curve())\n            path.clear()\n        image_sliced = ImageSlicer.slice_image(image, dpu, segments, pits_per_segment, inner_radius, outer_radius, width, depth, gap,",
    "regions = {}\n    for id in np.unique(mask):",
    "image_sample = ImageSample(image)\n        ImageSampleTransformer.rotational_repeat_additive(image_sample, segments, None, rotation_offset=period_offset, use_flip=True, flip_angle=np.pi / segments)\n        ImageSampleTransformer.rotational_repeat_additive(image_sample, periods_per_segment, None, rotation_offset=period_offset, use_flip=True, flip_angle=np.pi / segments)"
]