[
    "            function_call['end_col_offset'] - 2,\n            function_call['end_col_offset'] - 1,\n        )\n        parentheses_balance = 0\n        start_idx = function_call['start_col_offset']\n        current_line = function_call['start_line_offset']\n        while parentheses_balance:\n            char = lines[current_line][start_idx]\n            parentheses_balance += 1 if char == ')' else -1 if char == '(' else 0\n            start_idx -= 1\n            if start_idx < \n        while parentheses_balance:\n            char = lines[current_line][start_idx]\n            parentheses_balance += 1 if char == ')' else -1 if char == '(' else 0",
    "def bezier(control_points, values=np.linspace(0.0, 1.0, 100), polar=False):\n        nodes = np.asfortranarray(control_points)\n        if polar:\n            nodes = CurveTransforms.polar_to_cartesian(control_points)\n        nodes = np.asfortranarray(nodes)\n        return Curve.bezier(nodes, values)\n\n        if polar:\n            nodes = CurveTransforms.polar_to_cartesian(control_points)\n        nodes = np.asfortranarray(nodes)",
    "            targets = node.targets\n            value = node.value\n        elif isinstance(node, ast.AugAssign):\n            targets = [node.target]\n            value = node.value\n        elif isinstance(node, ast.AnnAssign):\n            targets = [node.target]",
    "def rotate_curves(curves: \"list\", angle=0):\n        transform = AffineTransform(rotation=angle)\n        for i in range(len(curves)):\n            curves[i] = transform.transform(curves[i])",
    "def find_assignments(code):\n    tree = ast.parse(code)\n    visitor = AssignmentFinder()\n    visitor.visit(tree)\n    assignments_positions = []\n    for assignment in visitor.assignments:",
    "def sine_wave_circular_arc(n=100, radius=0.5, theta1=0.0, theta2=np.pi/2, amplitude=0.1, n_periods=2, period_offset=0.25, offset=(0.0, 0.0)):\n        theta = np.linspace(theta1, theta2, n)\n        period = 2*np.pi/n_periods\n        freq = 2*np.pi/period\n        rho = radius + amplitude*np.sin((theta-theta1+period_offset*period)*freq)\n        curve = CurveTransforms.polar_to_cartesian(np.vstack((rho, theta)).T)",
    "        period = (theta2 - theta1)/n_periods\n        freq = 2*np.pi/period\n        rho = radius + amplitude*np.sin((theta-theta1+period_offset*period)*freq)\n        curve = CurveTransforms.polar_to_cartesian(rho, theta)\n        CurveTransforms.translate_single(curve, offset[0], offset[1], inplace=True)\n        return curve",
    "def calculate_similarities(regions):\n    similarities = {}\n    for region_id, region in regions.items():\n        for neighbour_id in region['neighbors']:\n            if region_id < neighbour_id:",
    "def leaf_placement(image, dpu=1000.0, segments=8 , inner_radius=0.5, outer_radius=0.8, width=0.2, sample_rotation=0.0, global_rotation=0.0):\n        (image_sliced, extent, path, outline_curves) = image.slice_image(dpu)\n        image_sample = ImageSample(image_sliced, extent, path, outline_curves)\n        ImageSampleTransformer.mirror_persistent(image_sample, np.pi/2)\n        ImageSampleTransformer.circular_placement_additive(image_sample, inner_radius, segments, None, -np.pi/2, global_rotation)",
    "            for key, value in self.evaluate(gen, exp, check_syntax).items():\n                if value is not None:\n                    total[key] += value\n                    counts[key] += 1\n        averaged = {key: (total[key] / counts[key]) if counts[key] > 0 else None for key in total}\n        return averaged",
    "            angle = None\n        else:\n            repetitions = np.maximum(1, number_of_segments)\n            angle = np.linspace(0, 2*np.pi, repetitions)\n        if angle is None:\n            angle = 2*np.pi/repetitions\n        if reverse_rotation:",
    "        image_ar = width / height\n        x1 = np.min(curve[:, 0])\n        x2 = np.max(curve[:, 0])\n        y1 = np.min(curve[:, 1])\n        y2 = np.max(curve[:, 1])\n        extent = (x1, x2, y1, y2)\n        x_abs = x2 - x1",
    "        (curve2, periods2, radius2, width2, coordinate_type2) = outer_curve\n        if coordinate_type2 == \"polar\":\n            curve2 = CurveTransforms.tight_remap_polar_to_polar(curve2, (radius2 - width2, radius2), (theta1, theta1 + (theta2-theta1)/periods2))\n            curve2 = CurveTransforms.tight_map_polar_to_polar(curve2, (radius2 - width2, radius2), (theta1, theta1 + (theta2-theta1)/periods2))\n        else:\n            curve2 = np.vstack((-curve2[:, 0], curve2[:, 1])).T\n            curve2 = CurveTransforms.tight_map_cartesian_to_polar(curve2, (radius2 - width2, radius2), (theta1, theta1 + (theta2-theta1)/periods2))",
    "        x_delta = np.abs(x_bounds[0] - x_bounds[1]) / subdivisions[0]\n        y_delta = np.abs(y_bounds[0] - y_bounds[1]) / subdivisions[1]\n        base_diamond = CurveGenerator.polyline([0, x_delta/2, x_delta, x_delta/2, 0], [y_delta/2, y_delta, y_delta/2, 0, y_delta/2])\n        diamonds = Transformer.translate_curves(base_diamond, x_bounds[0], y_bounds[0])\n        print(diamonds)\n        Transformer.translation_repeat_curves(diamonds, subdivisions, (x_delta, y_delta))\n        Transformer.translate_curves(diamonds, x_bounds[0], y_bounds[0])",
    "def extract_section(lines: List[str], start_pos: (int, int), end_pos: (int, int), max_characters: int = -1,\n                        min_context_lines: int = 1, max_context_lines: int = -1) -> Tuple[str, str, str]:\n        num_lines = len(lines)\n        if num_lines < min_context_lines:\n            min_context_lines = num_lines\n        if max_context_lines < 0:\n            max_context_lines = num_lines\n        if max_context_lines > num_lines:\n            max_context_lines = num_lines\n        if max_characters < 0:\n            max_characters = -1\n        start_line, start_idx = start_pos[0] - 1, start_pos[1]\n        end_line, end_idx = end_pos[0] - 1, end_pos[1]\n        if start_line < min_context_lines or num_lines - end_line - 1 < min_context_lines:",
    "        cycle_length = 0\n        j = i\n        while not visited[j]:\n            visited[j] = True\n            j = perm1_mapped[j]\n            cycle_length += 1\n        if cycle_length > 0:",
    "def serrated_ring(image, dpu=1000.0, segments=8, teeth_per_segment=3, aligned=True, teeth_width=0.05, inner_radius=0.5,\n                      outer_radius=0.8, sample_rotation=0.0) -> ImageSample:\n        (image_sliced, extent, path, outline_curves) = sliced_ring(image, dpu, segments, teeth_per_segment, aligned, teeth_width, inner_radius, outer_radius)\n        image_sample = ImageSample(image_sliced, extent, path, outline_curves)\n        ImageSampleTransformer.rotational_repeat_additive(image_sample, 2*segments, None, rotation_offset=-sample_rotation,\n                                                          use_flip=True, flip_angle=(2*sample_rotation+np.pi/segments)/2)",
    "                          outer_radius=1.0, theta1=0.0, theta2=np.pi / 6):\n        segments = np.maximum(1, segments)\n        theta = np.linspace(theta1, theta2, segments + 1)\n        inner_rho = np.array([inner_radius + ((i + aligned) % 2) * teeth_width for i in range(segments + 1)])\n        outer_rho = np.array([outer_radius - ((i + aligned) % 2) * teeth_width for i in range(segments + 1)])\n        curve1 = np.vstack((inner_rho, theta)).T\n        curve2 = np.vstack((outer_rho, np.flip(theta))).T",
    "def evaluate(self, generated, expected, check_syntax=False):\n        results = {}\n        results['exact_match'] = self.exact_match(generated, expected)\n        results['chrf'] = self.chrf_score(generated, expected)\n        results['bleu'] = self.bleu_score(generated, expected)\n        results['rouge'] = self.rouge_score(generated, expected)\n        results['meteor'] = self.meteor_score(generated, expected)",
    "            angle = None\n        elif delta_angle is None:\n            repetitions = np.maximum(1, number_of_segments)\n            angle = delta_angle\n        else:\n            repetitions = np.maximum(1, number_of_segments)\n            angle = delta_angle",
    "        else:\n            return\n        start_line = node.lineno\n        end_line = node.end_lineno\n        end_col = node.end_col_offset\n        start_col = value.col_offset if hasattr(value, 'col_offset') else 0\n        for target in targets:",
    "        if isinstance(node.func, ast.Name):\n            func_name = node.func.id\n        elif isinstance(node.func, ast.Attribute):\n            parts = []\n            current = node.func\n            while isinstance(current, ast.Attribute):\n                parts.insert(0, current.attr)",
    "    strings = {} \n    def string_replacer(match):\n        placeholder = f\"{{{{STR_{len(strings)}}}}}\"\n        strings[placeholder] = match.group(1)\n        return placeholder\n    code_without_strings = re.sub(string_pattern, string_replacer, code, flags=re.DOTALL)\n    code_without_comments = re.sub(comment_pattern, \"\", code_without_strings)",
    "def ring_arc(image, dpu=1000.0, inner_radius=0.0, outer_radius=1.0, theta1=0.0, theta2=np.pi / 6) -> (np.ndarray, (float, float, float, float), Path, List[np.ndarray]):\n        curve1 = CurveGenerator.circular_arc(100, inner_radius, theta1, theta2)\n        curve2 = np.flip(CurveGenerator.circular_arc(100, outer_radius, theta1, theta2), 0)\n        outline_curves = [curve1, curve2]\n        curve = np.vstack((curve1, curve2))\n        (image, extent, path) = ImageSlicer.sample_from_curve(image, curve, dpu)\n        return image, extent, path, outline_curves",
    "def visit_ClassDef(self, node):\n        class_source = self.get_class_source(node)\n        self.classes.append(class_source)\n        self.generic_visit(node)",
    "        curve = CurveTransforms.fit_c2c(curve, x_bounds + y_bounds)\n        transform = Affine2D().rotate(sample_rotation)\n        curve = transform.transform(curve)\n        outline_curves = CurveTransforms.fit_c2c(outline_curves, x_bounds + y_bounds)\n        transform = Affine2D().rotate(sample_rotation)\n        outline_curves = transform.transform(outline_curves)\n        (image, extent, path) = ImageSlicer.sample_from_curve(image, curve, dpu)\n        return image, extent, path, outline_curves",
    "def mirror_persistent(image_sample: ImageSample, mirror_angle=0.0):\n        transform = tf.AffineTransform(scale=(1, 1), rotation=mirror_angle)\n        new_image = tf.warp(image_sample.Image, transform)\n        new_image_sample = ImageSample(new_image, image_sample.PersistentTransforms, image_sample.PersistentPaths)\n        return new_image_sample\n\n    @staticmethod\n    def mirror_persistent_batch(image_samples:\n        new_persistent_transforms = []\n        new_persistent_paths = []\n        for i in range(len(image_sample.PersistentTransforms)):",
    "            del similarities[(neighbour, region1_id)]\n        else:\n            del similarities[(region1_id, neighbour)]\n    similarities[(region1_id, region2_id)] = similarity\n\nfor region1_id, region1_info in regions.items():\n    for region2_id, region2_info in regions.items():\n        if region1_id == region2_id:\n            continue\n        if region1_id in region2_info['neighbors']:\n            continue\n        if region2_id in region1_info['neighbors']:\n            continue\n        similarity = get_\n    for neighbour in region2_info['neighbors']:\n        if neighbour < region2_id:\n            del similarities[(neighbour, region2_id)]",
    "def neighbouring_regions(segments_mask, region_mask):\n    mask = np.zeros(region_mask.shape, dtype=np.uint8)\n    mask[region_mask == 1] = 1\n    kernel = np.array([[0, 1, 0], [1, 1, 1], [0, 1, 0]], dtype=np.uint8)\n    mask_dilated = cv2.dilate(mask, kernel, iterations=1)\n    return np.unique(segments_mask[(mask_dilated - mask) == 1])",
    "            angle = None\n        else:\n            repetitions = np.maximum(1, repetitions)\n            angle = np.linspace(0, 2 * np.pi, repetitions, endpoint=False)\n        if angle is None:\n            angle = 2 * np.pi / repetitions\n        if reverse_rotation:",
    "                   global_rotation=0.0, half=False, left_edge=False, right_edge=False) -> ImageSample:\n        outer_curve = (CurveGenerator.pit(100, width, gap, pits_per_segment), 1, outer_radius, depth, \"cartesian\")\n        inner_curve = (CurveTransforms.scale_single(CurveGenerator.pit(100, width, gap, pits_per_segment), (1, -1)), 1, inner_radius, depth, \"cartesian\")\n        (image_sliced, extent, path, outline_curves) = ImageSampleTransformer.slice_curves(outer_curve, inner_curve, segments,\n                                                                                      global_rotation=global_rotation,\n                                                                                      half=half, left_edge=left_edge,\n                                                                                      right_edge=right_edge)\n        image_sample = ImageSample(image_sliced, extent, path, outline_curves)\n        ImageSampleTransformer.rotational_repeat_additive(image_sample, 2 * segments, None,\n                                                          rotation_offset=-sample_rotation+global_rotation, use_flip=True,",
    "def extract_condition_sections(block: str, max_characters: int = 100, min_context_lines: int = 1, max_context_lines: int = -1) -> List[Tuple[str, str, str]]:\n        \"\"\"Extract condition sections with character limit and surrounding context.\"\"\"\n        conditions = extract_conditions(block)\n        lines = block.splitlines()\n        examples = []\n        for start_pos, end_pos in conditions:",
    "        if isinstance(figure, Figure):\n            new_figure = Figure()\n            new_figure += self\n            new_figure += figure\n        else:\n            raise TypeError(\"Operator + can only be used with instance of class Figure\")\n        return new_figure",
    "def leaf_circle(image, dpu=1000.0, repetitions=50, radius=0.7, leaf_width=0.1, leaf_height=0.2, leaf_rotation=np.pi/6):\n        circle = CurveGenerator.regular_polygon(1000, radius)\n        (image_sliced, extent, path, outline_curves) = ImageSampleTransformer.slice_image(image, dpu, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        image_sample = ImageSample(image_sliced, extent, path, outline_curves)\n        image_sample.add_additional_curve(circle)\n        ImageSampleTransformer.circular_placement_additive(image_sample, radius, repetitions, None, leaf_rotation, 0, True, np.pi/2-leaf_rotation, True, False)",
    "def circular_arc(n=100, radius=0.5, theta1=0.0, theta2=np.pi / 2, offset=(0.0, 0.0)):\n        theta = np.linspace(theta1, theta2, n)\n        rho = np.ones(n) * radius\n        curve = CurveTransforms.polar_to_cartesian(np.vstack((rho, theta)).T)\n        CurveTransforms.translate_single(curve, offset[0], offset[1], inplace=True)\n        return curve",
    "                curve1 = CurveTransforms.tight_remap_polar_to_polar(curve1, (radius1, radius1+width1), (theta1, theta1 + (theta2-theta1)/periods1))\n                curve1 = CurveTransforms.polar_to_cartesian(curve1)\n            else:\n                curve1 = CurveTransforms.map_cartesian_to_polar(curve1, (radius1, radius1+width1), (theta1, theta1 + (theta2-theta1)/periods1))\n                curve1 = CurveTransforms.tight_map_cartesian_to_polar(curve1, (radius1, radius1+width1), (theta1, theta1 + (theta2-theta1)/periods1))\n            curve1 = CurveTransforms.polar_to_cartesian(curve1)\n            curve1 = np.vstack([CurveTransforms.rotate_single(curve1, i * (theta2 - theta1) / periods1, inplace=False) for i in range(0, periods1)])",
    "        outer_rho = np.array([outer_radius - ((i + aligned) % 2) * teeth_width for i in range(segments + 1)])\n        curve1 = np.vstack((inner_rho, theta)).T\n        curve2 = np.vstack((outer_rho, np.flip(theta))).T\n        curve1 = CurveTransforms.polar_to_cartesian(curve1)\n        curve2 = CurveTransforms.polar_to_cartesian(curve2)\n        outline_curves = [curve1, curve2]\n        curve = np.vstack((curve1, curve2))",
    "def bezier(control_points, values=np.linspace(0.0, 1.0, 100), polar=False):\n        nodes = control_points\n        if polar:\n            nodes = np.array([np.cos(nodes), np.sin(nodes)]).T\n        nodes = np.asfortranarray(nodes)\n        bezier_curve = bezier.Curve(nodes.T, degree=nodes.shape[0] - 1)\n        return bezier_curve.evaluate_multi(values).T",
    "def plot_persistent(self, ax: \"Axes\", transform, z_order, outline_thickness=0.5, debug_colors=False):\n        if debug_colors:\n            outline_color = [0.0, 0.0, 0.0]\n            fill_color = [0.0, 0.0, 0.0]\n        else:\n            outline_color = [0.0, 0.0, 0.0]\n        for i in range(len(self.PersistentClipPaths)):",
    "def polar_to_cartesian(polar_curve):\n        x = polar_curve[:, 0] * np.cos(polar_curve[:, 1])\n        y = polar_curve[:, 0] * np.sin(polar_curve[:, 1])\n        return np.vstack((x, y)).T",
    "def min_swaps_to_transform(perm1, perm2):\n    n = len(perm1)\n    index_map = {value: index for index, value in enumerate(perm2)}\n    \n    perm1_mapped = [index_map[value] for value in perm1]  \n    visited = [False] * n\n    swaps = 0",
    "def rotation_repeat_curves(curves: \"list\", number_of_segments=None, delta_angle=None, scale=1.0, reverse_rotation=False):\n        if number_of_segments is None and delta_angle is None:\n            repetitions = 1\n        elif number_of_segments is None:\n            repetitions = np.trunc(2*np.pi/delta_angle)\n        else:\n            repetitions = number_of_segments\n        if delta_angle is None:\n            angle = None\n        elif number_of_segments is None:\n            repetitions = np.trunc(2*np.pi/delta_angle)",
    "        inner_curve = CurveGenerator.sine_wave_circular_arc(100, inner_radius+amplitude, theta1, theta2, amplitude, n_periods, period_offset)\n        outer_curve = np.flip(CurveGenerator.sine_wave_circular_arc(100, outer_radius-amplitude, theta1, theta2, amplitude, n_periods, period_offset), 0)\n        outline_curves = [inner_curve, outer_curve]\n        curve = CurveGenerator.combine_curves(outline_curves)\n        (image, extent, path) = ImageSlicer.sample_from_curve(image, curve, dpu)\n        return image, extent, path, outline_curves",
    "        curve2 = np.vstack((outer_rho, np.flip(theta))).T\n        curve1 = CurveTransforms.polar_to_cartesian(curve1)\n        curve2 = CurveTransforms.polar_to_cartesian(curve2)\n        outline_curves = [curve1, curve2]\n        curve = np.vstack((curve1, curve2))\n        (image, extent, path) = ImageSlicer.sample_from_curve(image, curve, dpu)\n        return image, extent, path, outline_curves",
    "def rotate_single(curve: np.ndarray, angle=0.0, pivot=(0.0, 0.0), inplace=True) -> np.ndarray:\n        transform = AffineTransform(angle, pivot)\n        return CurveTransforms.apply_affine_single(curve, transform, inplace)",
    "            print(\"Invalid input_coordinate, curve will default to 0,0\")\n            curve = np.array([[0.0, 0.0]])\n        if polar:\n            curve = self.polar_to_cartesian(curve)\n        return curve",
    "def strip_empty_lines(code):\n    lines = code.splitlines()\n    stripped_lines = [line for line in lines if line.strip()]\n    stripped_code = '\\n'.join(stripped_lines)\n    return stripped_code",
    "def colorize_segments(segments):\n    num_segments = np.max(segments) + 1\n    colors = np.random.randint(0, 255, size=(num_segments, 3), dtype=np.uint8)\n    color_image = np.zeros((segments.shape[0], segments.shape[1], 3), dtype=np.uint8)\n    for i in range(num_segments):",
    "        interpolated_curve = np.vstack((x_fine, y_fine)).T\n        if inplace:\n            curve.resize((2, samples), refcheck=False)\n            curve[:] = interpolated_curve\n            return curve\n        else:\n            return interpolated_curve",
    "        nodes = control_points\n        if polar:\n            nodes = CurveTransforms.polar_to_cartesian(control_points)\n        nodes = np.array(nodes)\n        bezier_curve = bezier.Curve(nodes.T, degree=nodes.shape[0] - 1)\n        return bezier_curve.evaluate_multi(values).T"
]