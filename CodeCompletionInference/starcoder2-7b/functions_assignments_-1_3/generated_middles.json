[
    "0\n        start_idx = function_call['start_col_offset']\n        current_line = function_call['start_line_offset']\n        while parentheses_balance:\n            char = lines[current_line][start_idx]\n            parentheses_balance += 1 if char == ')' else -1 if char == '(' else 0\n            start_idx -= 1\n            if start_idx < ",
    "np.asfortranarray(control_points)\n        if polar:\n            nodes = CurveTransforms.polar_to_cartesian(control_points)\n        nodes = np.asfortranarray(nodes)\n        return Curve.bezier(nodes, values)\n",
    "[node.target]",
    "AffineTransform(rotation=angle)",
    "AssignmentFinder()",
    "2*np.pi/n_periods",
    "CurveTransforms.polar_to_cartesian(rho, theta)",
    "{}",
    "image.slice_image(dpu)",
    "1",
    "np.linspace(0, 2*np.pi, repetitions)",
    "np.min(curve[:, 1])",
    "CurveTransforms.tight_map_polar_to_polar(curve2, (radius2 - width2, radius2), (theta1, theta1 + (theta2-theta1)/periods2))",
    "Transformer.translate_curves(base_diamond, x_bounds[0], y_bounds[0])",
    "len(lines)\n        if num_lines < min_context_lines:\n            min_context_lines = num_lines\n        if max_context_lines < 0:\n            max_context_lines = num_lines\n        if max_context_lines > num_lines:\n            max_context_lines = num_lines\n        if max_characters < 0:\n            max_characters = -1",
    "True",
    "sliced_ring(image, dpu, segments, teeth_per_segment, aligned, teeth_width, inner_radius, outer_radius)",
    "np.array([inner_radius + ((i + aligned) % 2) * teeth_width for i in range(segments + 1)])",
    "self.chrf_score(generated, expected)",
    "delta_angle",
    "node.end_lineno",
    "[]",
    "match.group(1)",
    "[curve1, curve2]",
    "self.get_class_source(node)",
    "CurveTransforms.fit_c2c(outline_curves, x_bounds + y_bounds)\n        transform = Affine2D().rotate(sample_rotation)\n        outline_curves = transform.transform(outline_curves)",
    "tf.AffineTransform(scale=(1, 1), rotation=mirror_angle)\n        new_image = tf.warp(image_sample.Image, transform)\n        new_image_sample = ImageSample(new_image, image_sample.PersistentTransforms, image_sample.PersistentPaths)\n        return new_image_sample\n\n    @staticmethod\n    def mirror_persistent_batch(image_samples:",
    "similarity\n\nfor region1_id, region1_info in regions.items():\n    for region2_id, region2_info in regions.items():\n        if region1_id == region2_id:\n            continue\n        if region1_id in region2_info['neighbors']:\n            continue\n        if region2_id in region1_info['neighbors']:\n            continue\n        similarity = get_",
    "np.zeros(region_mask.shape, dtype=np.uint8)\n    mask[region_mask == 1] = 1",
    "np.linspace(0, 2 * np.pi, repetitions, endpoint=False)",
    "ImageSampleTransformer.slice_curves(outer_curve, inner_curve, segments,\n                                                                                      global_rotation=global_rotation,\n                                                                                      half=half, left_edge=left_edge,\n                                                                                      right_edge=right_edge)",
    "extract_conditions(block)",
    "figure",
    "ImageSampleTransformer.slice_image(image, dpu, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,",
    "np.ones(n) * radius",
    "CurveTransforms.map_cartesian_to_polar(curve1, (radius1, radius1+width1), (theta1, theta1 + (theta2-theta1)/periods1))",
    "CurveTransforms.polar_to_cartesian(curve1)",
    "np.array([np.cos(nodes), np.sin(nodes)]).T",
    "[0.0, 0.0, 0.0]\n            fill_color = [0.0, 0.0, 0.0]",
    "polar_curve[:, 0] * np.cos(polar_curve[:, 1])",
    "{value: index for index, value in enumerate(perm2)}\n  ",
    "1\n        elif number_of_segments is None:\n            repetitions = np.trunc(2*np.pi/delta_angle)\n        else:\n            repetitions = number_of_segments\n        if delta_angle is None:",
    "CurveGenerator.combine_curves(outline_curves)",
    "[curve1, curve2]",
    "AffineTransform(angle, pivot)",
    "self.polar_to_cartesian(curve)",
    "[line for line in lines if line.strip()]",
    "np.max(segments) + 1",
    "interpolated_curve",
    "np.array(nodes)"
]