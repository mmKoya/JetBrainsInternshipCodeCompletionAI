[
    "isinstance(node, ast.Assign)",
    "inplace:\n            for i in range(len(curves)):\n                curves[i][:] = affine.transform(curves[i])\n            return None\n        else",
    "half == 1",
    "repetitions <= 0",
    "left_side",
    "scale.size == 1",
    "neighbour in region1_info['neighbors']",
    "neighbour in region2_info['neighbors']",
    "angle < 0",
    "angle < 0",
    "curve_type == \"polar\"",
    "len(examples) > 0",
    "self.show_points",
    "inplace:\n            affine.transform(curve, curve)\n            return curve\n        else",
    "number_of_segments is None and delta_angle is None",
    "angle < 0",
    "not visited[j]",
    "angle is None",
    "scale.size == 2",
    "isinstance(node, ast.AnnAssign)",
    "result is not None",
    "coordinate_type1 == 'polar'",
    "self.AdditiveTransforms",
    "additive_transforms[0] is not None and additive_transforms[1] is not None",
    "start_line < 0 or start_line >= num_lines or end_line < 0 or end_line >= num_lines:\n            return None\n        if start_line == end_line:\n            return lines[start_line][start_idx:end_idx]\n        if start",
    "call['function_name'] in self.ignore_functions",
    "isinstance(current, ast.Attribute)",
    "bounds is not None",
    "isinstance(node.func, ast.Attribute)",
    "polar:\n            x_values = np.array([x[0] for x in values])\n            y_values = np.array([x[1] for x in values])\n            curve = np.vstack((x_values, y_values)).T\n        else",
    "value is not None",
    "len(examples_split) > 0",
    "repetitions == 1",
    "parentheses_balance == 0:\n                break\n        if parentheses_balance!= 0:\n            current_line -= 1\n            start_idx = len(lines[current_line]) - 1\n        else:\n            while parentheses_balance!= 0",
    "isinstance(node, ast.If):\n            condition = ast.get_source_segment(code, node.test)\n            start_line = node.test.lineno\n            start_col = node.test.col_offset\n            end_line = node.test.end_lineno\n            end_",
    "split_idx == 0 or split_idx == len(middle)",
    "flip:\n            width = -width\n        if half:\n            height = -height\n        triangle1 = np.array([[0, 0], [0.1*width, height], [0.2*width, 0]])\n        triangle2 = np.array([[0.8*width,",
    "curve_cartesian[:, 0] < x_bounds[0]",
    "region_id == neighbour_id:\n                continue\n            if (region_id, neighbour_id) not in similarities",
    "polar",
    "self.syntax_validity is not None",
    "curve.shape[1]!= samples",
    "leaf_type == \"sharp\":\n            leaf = CurveGenerator.bezier(np.array([[-1, 0], [-1, 1], [0, 1], [0, 2]]))\n        elif leaf_type == \"round\"",
    "prefix is None or middle is None or suffix is None:\n                continue\n            if middle.strip() == '':\n                continue\n            if middle.strip().startswith('(') and middle.strip().endswith(')'):\n                middle = middle.strip()[1:-1]\n            if middle.strip().startswith('",
    "self.figure_type!= figure.figure_type:\n            raise TypeError(\"Cannot add two different figure types\")\n        else",
    "clip_ar > 1:\n            new_width = np.minimum(int(np.minimum(width, x_abs*dpu)), width-1)\n            new_height = int(new_width / clip_ar)\n        elif clip_ar < 1",
    "repetitions is None and delta_angle is None",
    "isinstance(node.func, ast.Name)",
    "parentheses_balance > 0:\n            start_idx -= 1\n            if start_idx < 0:\n                break\n            if lines[current_line][start_idx] == '(':\n                parentheses_balance -= 1\n            elif lines[current_line][start_idx] == ')'",
    "self.PlotType[i] == 0"
]