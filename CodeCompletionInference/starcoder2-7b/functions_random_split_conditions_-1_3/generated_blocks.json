[
    "def circular_placement(radius=0.5, repetitions: int = None, delta_angle: float = None, local_rotation_offset=0.0,\n                           global_rotation_offset=0.0, use_flip=False, flip_angle=0.0, reverse_rotation=False):\n        if repetitions is None and angle is None:\n            repetitions = 1\n            angle = None\n        elif repetitions is None:",
    "        new_examples = []\n        for example in examples:\n            prefix, middle, suffix = example\n            if len(middle) < min_right or len(middle) < min_left:\n                continue\n            while True:\n                split_idx = random.randint(min_left, min_left + (len(middle) - min_right - min_left) // 2 + 1)",
    "        if isinstance(node, ast.Assign):\n            targets = node.targets\n            value = node.value\n        elif isinstance(node, ast.AugAssign):\n            targets = [node.target]\n            value = node.value\n        elif isinstance(node, ast.AnnAssign):",
    "        control_nodes = np.array(control_nodes)\n        if interpolation_type == \"bezier\":\n            curve = CurveGenerator.bezier(control_nodes)\n        elif interpolation_type == \"linear\":\n            curve = control_nodes\n        else:\n            curve = CurveTransforms.interpolate(control_nodes, 100, \"cubic\", False)",
    "            if call['start_line'] - 1 < min_context_lines or num_lines - call['end_line'] < min_context_lines:\n                continue\n            prefix, middle, suffix = TextUtils.extract_function_call_details(lines, call)\n            if not middle:\n                continue\n            if not prefix and not suffix:\n                continue\n            start = max(0, call['start_line'] - 1 - (max_context_lines if max_context_lines >= 0 else call['start_line'] - 1))\n            end = min(num_lines, call['end_line'] + (max_context_lines if max_context_lines >= 0 else num_lines))",
    "        self.PlotType.append(plot_type)\n        if bounds:\n            self.update_curve_bounds(bounds)\n        elif evaluate_bounds:\n            self.update_curve_bounds(self.evaluate_curve_bounds(curve))\n        else:\n            self.update_curve_bounds(self.evaluate_curve_bounds(curve))\n\n    def update_curve:\n            self.update_curve_bounds(self.evaluate_curve_bounds(curve))",
    "        z_order += 0.001\n        for curve in self.AdditionalCurves:\n            ax.plot(curve[:, 0], curve[:, 1], color=\"k\", solid_capstyle='round', zorder=z_order, transform=ax.transData, linewidth=outline_thickness)\n        if len(self.AdditiveTransforms):\n            self.plot_persistent(ax, Affine2D(), z_order, outline_thickness, debug_colors)\n        else:\n            for transform in self.AdditiveTransforms:",
    "def collect_assignment_info(self, node):\n        if isinstance(node, ast.Assign):\n            targets = node.targets\n            value = node.value\n        elif isinstance(node, ast.AugAssign):",
    "        else:\n            repetitions = np.maximum(1, repetitions)\n            angle = delta_angle\n        if angle is None:\n            angle = 2 * np.pi / repetitions\n        if reverse_rotation:\n            angle = -angle",
    "        results['rouge'] = self.rouge_score(generated, expected)\n        results['meteor'] = self.meteor_score(generated, expected)\n        results['bert'] = self.bert_score(generated, expected)\n        if check_syntax:\n            results['syntax_valid'] = self.syntax_validity(generated)\n        return results",
    "                continue\n            while True:\n                split_idx = random.randint(min_left, min_left + (len(middle) - min_right - min_left) // 2 + 1)\n                if middle[split_idx - 1:] == middle[-1]:\n                    break\n            prefix += middle[:split_idx]\n            middle = middle[split_idx:]",
    "        else:\n            repetitions = np.maximum(1, number_of_segments)\n            angle = delta_angle\n        if angle == 0:\n            angle = 2*np.pi/repetitions\n        if reverse_rotation:\n            angle = -angle",
    "        elif isinstance(node.func, ast.Attribute):\n            parts = []\n            current = node.func\n            while isinstance(current, ast.Attribute):\n                parts.insert(0, current.attr)\n                current = current.value\n            if isinstance(current, ast.Name):",
    "            function_call['end_col_offset'] - 1,\n        )\n        parentheses_balance = 1\n        while parentheses_balance > 0:\n            char = lines[current_line][start_idx]\n            parentheses_balance += 1 if char == '(' else -1 if char == ')' else 0\n            start_idx -= 1\n        function:\n            char = lines[current_line][start_idx]\n            parentheses_balance += 1 if char == ')' else -1 if char == '(' else 0\n            start_idx -= 1",
    "def visit_Call(self, node):\n        func_name = None\n        if isinstance(node.func, ast.Name):\n            func_name = node.func.id\n        elif isinstance(node.func, ast.Attribute):\n            parts = []",
    "    new_region['neighbors'].discard(max(region1_id, region2_id))\n    for neighbour in new_region['neighbors']:\n        similarity = histogram_intersection(regions[neighbour]['color_histogram'], regions[new_id]['color_histogram'])\n        if neighbour not in similarities:\n            similarities[(neighbour, new_id)] = similarity\n        else:\n            similarities[(new_id, neighbour)] = similarity",
    "        for call in function_calls:\n            if len(call['arguments']) > max_arguments > 0:\n                continue\n            if call['start_line'] - 1 < min_context_lines > 0:\n                continue\n            if call['end_line'] + 1 > max_context_lines > 0:\n                continue\n            prefix, middle, suffix = TextUtils.extract_function_call_details(lines, call)\n            if not middle:",
    "        for i in range(len(self.Curves)):\n            if self.PlotType[i] == \"clear\":\n                ax.fill(self.Curves[i][:, 0], self.Curves[i][:, 1], color=\"w\", zorder=self.z_order)\n            elif self.PlotType[i] == \"black\":\n                ax.fill(self.Curves[i][:, 0], self.Curves[i][:, 1], color=\"k\", zorder=self.z_order)\n            elif self.PlotType[i] > 0:\n                ax.plot(self.Curves[i][:, 0], self.Curves[i][:, 1], color=\"k\", solid_capstyle='round',",
    "        additive_transforms = TransformsGenerator.circular_placement(radius, repetitions, delta_angle, local_rotation_offset,\n                                                                     global_rotation_offset, use_flip, flip_angle, reverse_rotation)\n        image_sample.AdditiveTransforms = additive_transforms\n        if calculate_overlap:\n            (new_persistent_paths, new_persistent_transforms, outline_curves) = paths_self_overlap(image_sample.PersistentClipPaths, image_sample.PersistentTransforms,\n                                                                                                   additive_transforms[0], additive_transforms[1])\n            image_sample.PersistentTransforms = new_persistent_transforms",
    "            while isinstance(current, ast.Attribute):\n                parts.insert(0, current.attr)\n                current = current.value\n            if isinstance(current, ast.Name):\n                parts.insert(0, current.id)\n            func_name = \".\".join(parts)\n        args = [ast.get_source_segment(self.source_code, arg) for arg in node.args]",
    "            curve2 = CurveTransforms.tight_map_cartesian_to_polar(curve2, (radius2 - width2, radius2), (theta1, theta1 + (theta2-theta1)/periods2))\n        curve2 = CurveTransforms.polar_to_cartesian(curve2)\n        curve2 = np.flip(np.vstack([CurveTransforms.rotate_single(curve2, i*(theta2-theta1)/periods2, inplace=False) for i in range(0, periods2)]), 0)\n        if left_side and right_side:\n            outline_curves = [np.vstack((curve1, curve2, np.array([[curve1[0, 0], curve1[0, 1]]])))]\n        elif right_side:\n            outline_curves = [np.vstack((curve1, curve2))]",
    "    visited = [False] * n\n    swaps = 0\n    for i in range(n):\n        if visited[i] or:\n            continue\n        cycle_length = 0\n        j = i",
    "        func_name = None\n        if isinstance(node.func, ast.Name):\n            func_name = node.func.id\n        elif isinstance(node.func, ast.Attribute):\n            parts = []\n            current = node.func\n            while isinstance(current, ast.Attribute):",
    "def update_curve_bounds(self, bounds):\n        if self.X_bounds is None or self.Y_bounds is None or self.Rho_bounds is None:\n            self.X_bounds = bounds[0]\n            self.Y_bounds = bounds[1]\n            self.Rho_bounds = bounds[2]",
    "        \"\"\"Generate examples by extracting specified middle lines with configurable context lines.\"\"\"\n        lines = block.splitlines()\n        num_lines = len(lines)\n        if num_lines < 2 * middle_line_count + min_context_lines:\n            return []\n        examples = []\n        for middle_start in range(min_context_lines, num_lines - min_context_lines - middle_line_count):",
    "def rotational_repeat(repetitions: int = None, delta_angle: float = None, rotation_offset=0.0, use_flip=True, flip_angle=0.0, reverse_rotation=False):\n        if repetitions is None and delta_angle is None:\n            repetitions = 1\n            angle = None\n        elif repetitions is None:",
    "            continue\n        cycle_length = 0\n        j = i\n        while not visited[j]:\n            visited[j] = True\n            j = perm1_mapped[j]\n            cycle_length += 1",
    "                [lines[start_line][start_idx:]] + lines[start_line + 1:end_line] + [lines[end_line][:end_idx]]\n            )\n        )\n        if 0 < max_characters < len(lines[start_line][start_idx:]):\n            start_idx += len(lines[start_line][start_idx:]) - max_characters\n        if 0 < max_characters < len(lines[:\n            return None\n        start = max(0, start_line - (max_context_lines if max_context_lines >= 0 else start_line))\n        end = min(num_lines, end_line + 1 + (max_context_lines if max_context_lines >= 0 else num_lines))",
    "def evaluate_multi(self, generated: List[str], expected: List[str], check_syntax=False):\n        length = len(generated)\n        if length != len(expected):\n            return None\n        total = defaultdict(float)\n        counts = defaultdict(int)",
    "        num_lines = len(lines)\n        examples = []\n        for call in function_calls:\n            if len(call['arguments']) == 0:\n                continue\n            if call['start_line'] - 1 < min_context_lines or num_lines - call['end_line'] < min_context_lines:\n                continue",
    "def __add__(self, figure: \"Figure\"):\n        if isinstance(figure, Figure):\n            new_figure = Figure()\n            new_figure += self\n            new_figure += figure",
    "        num_lines = len(lines)\n        start_line, start_idx = start_pos[0] - 1, start_pos[1]\n        end_line, end_idx = end_pos[0] - 1, end_pos[1]\n        if start_line < min_context_lines or num_lines - end_line < min_context_lines:\n            return None\n        middle_text = (\n            lines[start_line][start_idx:end_idx] if start_line == end_line",
    "            visited[j] = True\n            j = perm1_mapped[j]\n            cycle_length += 1\n        if cycle_length > 0:\n            swaps += cycle_length - 1  \n    return swaps",
    "    similarities = {}\n    for region_id, region in regions.items():\n        for neighbour_id in region['neighbors']:\n            if region_id == neighbour_id:\n                continue\n            if (neighbour_id, region_id) in similarities:\n                continue\n            if region_id not in similarities:\n                similarities[(region_id, neighbour_id)] = histogram_intersection(regions[region_id]['color_histogram'], regions[neighbour_id]['color_histogram'])\n    return similarities",
    "    region1_info = regions[region1_id]\n    region2_info = regions[region2_id]\n    for neighbour in region1_info['neighbors']:\n        if neighbour == region2_id:\n            del similarities[(neighbour, region1_id)]\n        else:\n            del similarities[(region1_id, neighbour)]",
    "            end_line = node.test.end_lineno\n            end_col = node.test.end_col_offset\n            conditions.append(((start_line, start_col), (end_line, end_col)))\n        elif isinstance(node, ast.If):\n            condition = ast.get_source_segment(code, node.test)\n            start_line = node.test.lineno\n            start_col = node.test.col_offset\n            end_line = node:\n            condition = ast.get_source_segment(code, node.test)\n            start_line = node.test.lineno\n            start_col = node.test.col_offset",
    "            y_values = values\n            x_values = np.array([function(y) for y in y_values])\n            curve = np.vstack((x_values, y_values)).T\n        elif input_class == np.ndarray:\n            result = [function(value) for value in values]\n            curve = np.array(result)\n        else:",
    "            angle = delta_angle\n        if angle is None:\n            angle = 2 * np.pi / repetitions\n        if reverse:\n            angle = -angle\n        transforms = []\n        for i in range(repetitions):",
    "        scale = np.array(scale)\n        if scale.size == 1:\n            scales = scale*np.ones(repetitions)\n        elif scale.size == 2:\n            scales = np.linspace(scale[0], scale[1], repetitions)\n        elif scale.size == repetitions:\n            scales = scale",
    "        if number_of_segments is None and delta_angle is None:\n            repetitions = 1\n            angle = None\n        elif number_of_segments is None and delta_angle is not None:\n            repetitions = np.trunc(2*np.pi/delta_angle)\n            angle = None\n        elif delta_angle is None:",
    "        elif repetitions is None:\n            repetitions = int(np.trunc(2 * np.pi / delta_angle))\n            angle = None\n        elif delta_angle is None:\n            repetitions = np.maximum(1, repetitions)\n            angle = None\n        else:",
    "            angle = -angle\n        transforms = []\n        for i in range(repetitions):\n            if i % 2 == 0:\n                trans_data = Affine2D().rotate(i * angle + rotation_offset)\n            else:\n                trans_data = Affine2D().rotate(-flip_angle).scale(1, -1).rotate:\n                trans_data = Affine2D().rotate(i * angle + rotation_offset)\n            else:\n                trans_data = Affine2D().rotate(-flip_angle).scale(1, -1).rotate(i * angle + flip_angle + rotation_offset)",
    "            image.plot(ax, self.z_order, image_outline_width)\n            Figure.z_order += 1\n        for i in range(len(self.Curves)):\n            if self.PlotType[i] == \"line\":\n                ax.plot(self.Curves[i][:, 0], self.Curves[i][:, 1], color=\"k\", zorder=self.z_order)\n            elif self:\n                ax.fill(self.Curves[i][:, 0], self.Curves[i][:, 1], color=\"w\", zorder=self.z_order)\n            elif self.PlotType[i] == \"fill\":\n                ax.fill(self.Curves[i][:, 0], self.Curves[i][:, 1], color=\"k\", zorder=self.z_order)",
    "        for i in range(grid_size[0] + 1):\n            control_nodes.append([i * grid_step[0], np.random.randint(0, grid_size[1] + 1) * grid_step[1]])\n        control_nodes = np.array(control_nodes)\n        if interpolation_type == \"bezier\":\n            curve = CurveGenerator.bezier(control_nodes)\n        elif interpolation_type == \"linear\":\n            curve = control_nodes",
    "def custom_ring_arc(image, dpu=1000.0, inner_curve: (np.ndarray, int, float, float, str) = (np.array([[0.0, 0.0]]), 1, 0.5, 0.05, \"cartesian\"),\n                        outer_curve: (np.ndarray, int, float, str) = (np.array([[0.0, 0.0]]), 1, 0.8, 0.05, \"cartesian\"), theta1=0.0, theta2=np.pi/6,\n                        left_side=False, right_side=False) -> (np.ndarray, (float, float, float, float), Path, List[np.ndarray]):\n        if inner_curve[0].shape[0] == 1:\n            curve1 = np.array([[0, 0]])\n        else:\n            (curve1, periods1, radius1, width1, coordinate_type1) = inner_curve",
    "            curve1 = CurveTransforms.polar_to_cartesian(curve1)\n            curve1 = np.vstack([CurveTransforms.rotate_single(curve1, i * (theta2 - theta1) / periods1, inplace=False) for i in range(0, periods1)])\n        (curve2, periods2, radius2, width2, coordinate_type2) = outer_curve\n        if coordinate_type2 == 'polar':\n            curve2 = CurveTransforms.tight_remap_polar_to_polar(curve2, (radius2 - width2, radius2), (theta1, theta1 + (theta2-theta1)/periods2))\n            curve2 = CurveTransforms.polar_to_cartesian(curve2)\n        else:",
    "def plot_persistent(self, ax: \"Axes\", transform, z_order, outline_thickness=0.5, debug_colors=False):\n        if debug_colors:\n            outline_color = ImageSample.outline_colors[ImageSample.current_outline]\n        else:\n            outline_color = [0.0, 0.0, 0.0]",
    "        curve2 = np.flip(np.vstack([CurveTransforms.rotate_single(curve2, i*(theta2-theta1)/periods2, inplace=False) for i in range(0, periods2)]), 0)\n        if left_side and right_side:\n            outline_curves = [np.vstack((curve1, curve2, np.array([[curve1[0, 0], curve1[0, 1]]])))]\n        elif right_side:\n            outline_curves = [np.vstack((curve1, curve2, np.array([[curve2[0, 0], curve2[0, 1]]])))]\n        elif left_side:\n            outline_curves = [np.vstack((curve1, curve2))]\n        elif left_side:\n            outline_curves = [np.vstack((curve2, curve1))]",
    "        counts = defaultdict(int)\n        for gen, exp in zip(generated, expected):\n            for key, value in self.evaluate(gen, exp, check_syntax).items():\n                if value is not None:\n                    total[key] += value\n                    counts[key] += 1\n        averaged = {key: (total[key] / counts[key]) if counts[key] > 0 else None for key in total}",
    "            angle = delta_angle\n        if angle is None:\n            angle = 2*np.pi/repetitions\n        if reverse:\n            angle = -angle\n        scale = np.array(scale)\n        if scale.size == 1:"
]