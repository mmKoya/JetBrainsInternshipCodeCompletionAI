[
    "inplace",
    "isinstance(figure, Figure)",
    "input_coordinate == \"value\"",
    "func_name",
    "delta_angle is None",
    "use_flip",
    "max_characters >= 0 and len(middle_text) > max_characters",
    "neighbour < region2_id",
    "reverse_rotation",
    "isinstance(node, ast.Assign)",
    "inner_curve[0].shape[0] == 0",
    "isinstance(node, ast.For):\n            condition = ast.get_source_segment(code, node.iter)\n            start_line = node.iter.lineno\n            start_col = node.iter.col_offset\n            end_line = node.iter.",
    "len(call['args']) > max_arguments",
    "region_id < neighbour_id",
    "repetitions is None and delta_angle is None",
    "len(middle) - split_idx >= min_right",
    "scale.size == 1",
    "self.AdditiveTransforms is not None",
    "interpolation_type == \"bezier\"",
    "isinstance(node, ast.TryExcept)",
    "delta_angle is None",
    "self.PlotType[i] == \"fill\"",
    "scale.size == 2",
    "start_idx < 0",
    "cycle_length > 0",
    "input_coordinate == \"x_input\"",
    "num_lines < min_context_lines + middle_line_count",
    "polar",
    "reverse_rotation",
    "isinstance(figure, Figure)",
    "isinstance(node.func, ast.Name)",
    "isinstance(node, ast.If)",
    "isinstance(current, ast.Attribute)",
    "clip_ar > image_ar",
    "isinstance(node.func, ast.Attribute)",
    "not visited[j]",
    "delta_angle is None",
    "delta_angle is None",
    "input_coordinate == \"y_input\"",
    "start_line < 0 or start_line >= num_lines or end_line < 0 or end_line >= num_lines:\n            return None\n        if start_idx < 0 or start_idx >= len(lines[start_line]) or end",
    "half:\n            return CurveTransforms.merge_curves([curve, triangle2])\n        if flip",
    "coordinate_type2 == \"polar\"",
    "use_flip",
    "isinstance(current, ast.Name)",
    "value is not None",
    "neighbour < region1_id",
    "result is not None",
    "len(middle) < min_left + min_right",
    "x_bounds[0] == x_bounds[1]",
    "evaluate_bounds"
]