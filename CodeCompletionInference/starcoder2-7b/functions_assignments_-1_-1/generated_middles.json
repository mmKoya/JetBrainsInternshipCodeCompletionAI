[
    "(CurveGenerator.bezier(np.array([[0, 0], [0, 1], [1, 1], [1, 2]])), 1, inner_radius, width, \"cartesian\")",
    "CurveTransforms.merge_curves([gap1, arc, gap2])",
    "ImageSample(image_sliced, extent, path, outline_curves)",
    "[]",
    "source_code\n        self.function_definitions = []",
    "min(num_lines - 1, end_line + (max_context_lines if max_context_lines >= 0 else num_lines - end_line - 1))",
    "CodeExtractor()",
    "CurveTransforms.tight_map_cartesian_to_polar(curve2, (radius2 - width2, radius2), (theta1, theta1 + (theta2-theta1)/periods2))",
    "bounds[1]",
    "ast.parse(code)",
    "np.minimum(int(np.minimum(height, y_abs*dpu)), height-1)",
    "bounds[0]",
    "nltk.word_tokenize(expected)",
    "CurveTransforms.interpolate(control_nodes, 100, \"cubic\", True)",
    "min(num_lines - 1, call['end_line'] + 1 + (max_context_lines if max_context_lines >= 0 else num_lines - call['end_line'] - 1))",
    "np.array(perm)\n  ",
    "CurveGenerator.draw_curves(image, outline_curves, dpu)",
    "[]",
    "np.histogram(region[:, 2], range=(0.0, 1.0), bins=n_bins)",
    "1",
    "CurveGenerator.draw_curves(image, curve, dpu)",
    "[curve]",
    "delta_angle",
    "-width/2",
    "None",
    "node.value.test.end_lineno",
    "bert_score.compute_score(self.tokenizer, generated, expected)",
    "np.abs(x_bounds[0] - x_bounds[1]) / subdivisions[0]",
    "nltk.word_tokenize(generated)",
    "affine.transform(curve)",
    "i\n        while perm1_mapped[j]!= i:\n            j = perm1_mapped[j]\n        while i!= j:\n            visited[i] = True\n            i = perm1_mapped[i]\n            cycle_length += 1",
    "local_outline_curves",
    "cv2.fitLine(curve, cv2.DIST_L2, 0, 0.01, 0.01)",
    "curves[0]\n        for c in curves[1:]:\n            curve = np.concatenate((curve, c))",
    "[]",
    "self.chrf_score(generated, expected)",
    "delta_angle",
    "'\\n'.join(lines[start:start_line])",
    "[]",
    "1 if char == '(' else -1\n            start_idx -= 1\n            if start_idx < 0:\n                current_line -= 1\n                start_idx = len(lines[current_line]) - 1\n        prefix = '\\n'.join(lines[function_call['start_line'] - 1:current_line] + [lines[",
    "draw_outline_curves(image, outline_curves, dpu)",
    "outer_curve\n        if coordinate_type2 == \"polar\":\n            curve2 = CurveTransforms.tight_remap_polar_to_polar(curve2, (radius2 - width2, radius2), (theta1, theta1 + (theta2-theta1)/periods2))\n            curve2 = CurveTransforms.polar_to_cartesian(curve2)",
    "spline(t_fine)",
    "np.array([[0.0, 0.0]])\n        else:\n            (curve1, periods1, radius1, width1, coordinate_type1) = inner_curve\n            if coordinate_type1 == \"polar\":\n                curve1 = CurveTransforms.tight_remap_polar_to_polar(curve1, (radius1, radius1+width",
    "x",
    "1",
    "np.array(result)",
    "values",
    "current.value",
    "[]\n        self.X_bounds = None\n        self.Y_bounds = None\n        self.Rho_bounds = None\n        self.Theta_bounds = None\n\nclass PlotData:\n    def __init__(self):\n        self.Curves = []\n        self.PlotType = []\n        self.Images = []"
]