[
    [
        "def apply_affine_multi(curves: List[np.ndarray], affine: Affine2D, inplace=True) -> List[np.ndarray]:\n        if inplace:\n            for i in range(len(c",
        "urves)",
        "):\n                curves[i][:] = affine.transform(curves[i])\n            return curves\n        else:\n            transformed_curves = []\n            for i in range(len(curves)):\n                transformed_curves.append(affine.transform(curves[i]))\n            return transformed_curves"
    ],
    [
        "def apply_affine_multi(curves: List[np.ndarray], affine: Affine2D, inplace=True) -> List[np.ndarray]:\n        if inplace:\n            for i in range(len(curves)):\n                curves[i][:] = affine.transform(curves[i])\n            return curves\n        else:\n            transformed_curves = []\n            for i in range(len(c",
        "urves)",
        "):\n                transformed_curves.append(affine.transform(curves[i]))\n            return transformed_curves"
    ],
    [
        "def apply_affine_multi(curves: List[np.ndarray], affine: Affine2D, inplace=True) -> List[np.ndarray]:\n        if inplace:\n            for i in range(len(curves)):\n                curves[i][:] = affine.transform(curves[i])\n            return curves\n        else:\n            transformed_curves = []\n            for i in range(len(curves)):\n                transformed_curves.append(affin",
        "e.transform(curves[i])",
        ")\n            return transformed_curves"
    ],
    [
        "def rotate_single(curve: np.ndarray, angle=0.0, pivot=(0.0, 0.0), inplace=True) -> np.ndarray:\n        transform = Affine2D().translate(-pivot[0], -pivot[1]).rotate(angle).translate(pivot",
        "[0], pivot[1]",
        ")\n        return CurveTransforms.apply_affine_single(curve, transform, inplace)"
    ],
    [
        "def rotate_single(curve: np.ndarray, angle=0.0, pivot=(0.0, 0.0), inplace=True) -> np.ndarray:\n        transform = Affine2D().translate(-pivot[",
        "0], -pivot[1]",
        ").rotate(angle).translate(pivot[0], pivot[1])\n        return CurveTransforms.apply_affine_single(curve, transform, inplace)"
    ],
    [
        "def rotate_multi(curves: List[np.ndarray], angle=0.0, pivot=(0.0, 0.0), inplace=True) -> List[np.ndarray]:\n        transform = Affine2D().translate(-pivot[0], -pivot[1]).rotate(angle).translate(pivot[0",
        "], pivot[1]",
        ")\n        return CurveTransforms.apply_affine_multi(curves, transform, inplace)"
    ],
    [
        "def rotate_multi(curves: List[np.ndarray], angle=0.0, pivot=(0.0, 0.0), inplace=True) -> List[np.ndarray]:\n        transform = Affine2D().translate(-pivot[0],",
        " -pivot[1]",
        ").rotate(angle).translate(pivot[0], pivot[1])\n        return CurveTransforms.apply_affine_multi(curves, transform, inplace)"
    ],
    [
        "def scale_single(curve: np.ndarray, scale=(1.0, 1.0), pivot=(0.0, 0.0), inplace=True) -> np.ndarray:\n        transform = Affine2D().translate(-pivot[0], -pivot[1]).scale(scale[0], scale[1]).translate(pivot",
        "[0], pivot[1]",
        ")\n        return CurveTransforms.apply_affine_single(curve, transform, inplace)"
    ],
    [
        "def scale_single(curve: np.ndarray, scale=(1.0, 1.0), pivot=(0.0, 0.0), inplace=True) -> np.ndarray:\n        transform = Affine2D().translate(-pivot[0], -pivot[1]).scale(scale[",
        "0], scale[1]",
        ").translate(pivot[0], pivot[1])\n        return CurveTransforms.apply_affine_single(curve, transform, inplace)"
    ],
    [
        "def scale_single(curve: np.ndarray, scale=(1.0, 1.0), pivot=(0.0, 0.0), inplace=True) -> np.ndarray:\n        transform = Affine2D().translate(-pivot[0],",
        " -pivot[1]",
        ").scale(scale[0], scale[1]).translate(pivot[0], pivot[1])\n        return CurveTransforms.apply_affine_single(curve, transform, inplace)"
    ],
    [
        "def scale_multi(curves: List[np.ndarray], scale=(1.0, 1.0), pivot=(0.0, 0.0), inplace=True) -> List[np.ndarray]:\n        transform = Affine2D().translate(-pivot[0], -pivot[1]).scale(scale[0], scale[1]).translate(pivot[",
        "0], pivot[1]",
        ")\n        return CurveTransforms.apply_affine_multi(curves, transform, inplace)"
    ],
    [
        "def scale_multi(curves: List[np.ndarray], scale=(1.0, 1.0), pivot=(0.0, 0.0), inplace=True) -> List[np.ndarray]:\n        transform = Affine2D().translate(-pivot[0], -pivot[1]).scale(scale[0]",
        ", scale[1]",
        ").translate(pivot[0], pivot[1])\n        return CurveTransforms.apply_affine_multi(curves, transform, inplace)"
    ],
    [
        "def scale_multi(curves: List[np.ndarray], scale=(1.0, 1.0), pivot=(0.0, 0.0), inplace=True) -> List[np.ndarray]:\n        transform = Affine2D().translate(-pivot[",
        "0], -pivot[1]",
        ").scale(scale[0], scale[1]).translate(pivot[0], pivot[1])\n        return CurveTransforms.apply_affine_multi(curves, transform, inplace)"
    ],
    [
        "def polar_to_cartesian(polar_curve):\n        x = polar_curve[:, 0] * np.cos(polar_cur",
        "ve[:, 1]",
        ")\n        y = polar_curve[:, 0] * np.sin(polar_curve[:, 1])\n        return np.vstack((x, y)).T"
    ],
    [
        "def polar_to_cartesian(polar_curve):\n        x = polar_curve[:, 0] * np.cos(polar_curve[:, 1])\n        y = polar_curve[:, 0] * np.sin(polar_",
        "curve[:, 1]",
        ")\n        return np.vstack((x, y)).T"
    ],
    [
        "def cartesian_to_polar(x, y):\n        rho = np.sqrt(x ** 2",
        " + y ** 2",
        ")\n        theta = np.arctan2(y, x)\n        return np.vstack((rho, theta))"
    ],
    [
        "def square_map_cartesian_to_polar(curve_cartesian, x_bounds, y_bounds, rho_bounds, theta_bounds):\n        if y_bounds[0] == y_bounds[1]:\n            rho = np.ones(curve_ca",
        "rtesian[:, 1].shape",
        ") * rho_bounds[0]\n        else:\n            rho = (curve_cartesian[:, 1] - y_bounds[0]) / (y_bounds[1] - (y_bounds[0])) * (\n                        rho_bounds[1] - rho_bounds[0]) + rho_bounds[0]\n        if x_bounds[0] == x_bounds[1]:\n            theta = np.ones(curve_cartesian[:, 0].shape) * theta_bounds[0]\n        else:\n            theta = (curve_cartesian[:, 0] - x_bounds[0]) / (x_bounds[1] - (x_bounds[0])) * (theta_bounds[1] - theta_bounds[0]) + theta_bounds[0]\n        return np.vstack((rho, theta)).T"
    ],
    [
        "def square_map_cartesian_to_polar(curve_cartesian, x_bounds, y_bounds, rho_bounds, theta_bounds):\n        if y_bounds[0] == y_bounds[1]:\n            rho = np.ones(curve_cartesian[:, 1].shape) * rho_bounds[0]\n        else:\n            rho = (curve_cartesian[:, 1] - y_bounds[0]) / (y_bounds[1] - (y_bounds[0])) * (\n                        rho_bounds[1] - rho_bounds[0]) + rho_bounds[0]\n        if x_bounds[0] == x_bounds[1]:\n            theta = np.ones(curve_",
        "cartesian[:, 0].shape",
        ") * theta_bounds[0]\n        else:\n            theta = (curve_cartesian[:, 0] - x_bounds[0]) / (x_bounds[1] - (x_bounds[0])) * (theta_bounds[1] - theta_bounds[0]) + theta_bounds[0]\n        return np.vstack((rho, theta)).T"
    ],
    [
        "def tight_map_cartesian_to_polar(curve_cartesian, rho_bounds, theta_bounds):\n        x_bounds = (np.min(curve_car",
        "tesian[:, 0]",
        "), np.max(curve_cartesian[:, 0]))\n        y_bounds = (np.min(curve_cartesian[:, 1]), np.max(curve_cartesian[:, 1]))\n        return CurveTransforms.square_map_cartesian_to_polar(curve_cartesian, x_bounds, y_bounds, rho_bounds, theta_bounds)"
    ],
    [
        "def tight_map_cartesian_to_polar(curve_cartesian, rho_bounds, theta_bounds):\n        x_bounds = (np.min(curve_cartesian[:, 0]), np.max(curve_cart",
        "esian[:, 0]",
        "))\n        y_bounds = (np.min(curve_cartesian[:, 1]), np.max(curve_cartesian[:, 1]))\n        return CurveTransforms.square_map_cartesian_to_polar(curve_cartesian, x_bounds, y_bounds, rho_bounds, theta_bounds)"
    ],
    [
        "def tight_map_cartesian_to_polar(curve_cartesian, rho_bounds, theta_bounds):\n        x_bounds = (np.min(curve_cartesian[:, 0]), np.max(curve_cartesian[:, 0]))\n        y_bounds = (np.min(curve_",
        "cartesian[:, 1]",
        "), np.max(curve_cartesian[:, 1]))\n        return CurveTransforms.square_map_cartesian_to_polar(curve_cartesian, x_bounds, y_bounds, rho_bounds, theta_bounds)"
    ],
    [
        "def tight_map_cartesian_to_polar(curve_cartesian, rho_bounds, theta_bounds):\n        x_bounds = (np.min(curve_cartesian[:, 0]), np.max(curve_cartesian[:, 0]))\n        y_bounds = (np.min(curve_cartesian[:, 1]), np.max(curve_car",
        "tesian[:, 1]",
        "))\n        return CurveTransforms.square_map_cartesian_to_polar(curve_cartesian, x_bounds, y_bounds, rho_bounds, theta_bounds)"
    ],
    [
        "def remap_c2c(curve, old_x_bounds, old_y_bounds, new_x_bounds, new_y_bounds):\n        transform = Affine2D().translate(-old_x_bounds[0",
        "], -old_y_bounds[0]",
        ")\n        transform = transform.scale((new_x_bounds[1]-new_x_bounds[0])/(old_x_bounds[1]-old_x_bounds[0]),\n                                    (new_y_bounds[1]-new_y_bounds[0])/(old_y_bounds[1]-old_y_bounds[0]))\n        transform = transform.translate(new_x_bounds[0], new_y_bounds[0])\n        return transform.transform(curve)"
    ],
    [
        "def remap_c2c(curve, old_x_bounds, old_y_bounds, new_x_bounds, new_y_bounds):\n        transform = Affine2D().translate(-old_x_bounds[0], -old_y_bounds[0])\n        transform = transform.scale((new_x_bounds[1]-new_x_bounds[",
        "0])/(old_x_bounds[1]-old_x_bounds[0]), (new_y_bounds[1]-new_y_bounds[0])/(old_y_bounds[1]-old_y_bounds[0])",
        ")\n        transform = transform.translate(new_x_bounds[0], new_y_bounds[0])\n        return transform.transform(curve)"
    ],
    [
        "def remap_c2c(curve, old_x_bounds, old_y_bounds, new_x_bounds, new_y_bounds):\n        transform = Affine2D().translate(-old_x_bounds[0], -old_y_bounds[0])\n        transform = transform.scale((new_x_bounds[1]-new_x_bounds[0])/(old_x_bounds[1]-old_x_bounds[0]),\n                                    (new_y_bounds[1]-new_y_bounds[0])/(old_y_bounds[1]-old_y_bounds[0]))\n        transform = transform.translate(new_x_bounds[0], ",
        "new_y_bounds[0]",
        ")\n        return transform.transform(curve)"
    ],
    [
        "def fit_c2c(curve, extent):\n        x_bounds = (np.min(curve[",
        ":, 0]",
        "), np.max(curve[:, 0]))\n        y_bounds = (np.min(curve[:, 1]), np.max(curve[:, 1]))\n        return CurveTransforms.remap_c2c(curve, x_bounds, y_bounds, extent[0:2], extent[2:4])"
    ],
    [
        "def fit_c2c(curve, extent):\n        x_bounds = (np.min(curve[:, 0]), np.max(curve",
        "[:, 0]",
        "))\n        y_bounds = (np.min(curve[:, 1]), np.max(curve[:, 1]))\n        return CurveTransforms.remap_c2c(curve, x_bounds, y_bounds, extent[0:2], extent[2:4])"
    ],
    [
        "def fit_c2c(curve, extent):\n        x_bounds = (np.min(curve[:, 0]), np.max(curve[:, 0]))\n        y_bounds = (np.min(curve[",
        ":, 1]",
        "), np.max(curve[:, 1]))\n        return CurveTransforms.remap_c2c(curve, x_bounds, y_bounds, extent[0:2], extent[2:4])"
    ],
    [
        "def fit_c2c(curve, extent):\n        x_bounds = (np.min(curve[:, 0]), np.max(curve[:, 0]))\n        y_bounds = (np.min(curve[:, 1]), np.max(curve[",
        ":, 1]",
        "))\n        return CurveTransforms.remap_c2c(curve, x_bounds, y_bounds, extent[0:2], extent[2:4])"
    ],
    [
        "def tight_remap_polar_to_polar(curve_polar, rho_bounds, theta_bounds):\n        old_rho_bounds = (np.min(curve_po",
        "lar[:, 0]",
        "), np.max(curve_polar[:, 0]))\n        old_theta_bounds = (np.min(curve_polar[:, 1]), np.max(curve_polar[:, 1]))\n        return CurveTransforms.remap_polar_to_polar(curve_polar, old_rho_bounds, old_theta_bounds, rho_bounds, theta_bounds)"
    ],
    [
        "def tight_remap_polar_to_polar(curve_polar, rho_bounds, theta_bounds):\n        old_rho_bounds = (np.min(curve_polar[:, 0]), np.max(curve_pol",
        "ar[:, 0]",
        "))\n        old_theta_bounds = (np.min(curve_polar[:, 1]), np.max(curve_polar[:, 1]))\n        return CurveTransforms.remap_polar_to_polar(curve_polar, old_rho_bounds, old_theta_bounds, rho_bounds, theta_bounds)"
    ],
    [
        "def tight_remap_polar_to_polar(curve_polar, rho_bounds, theta_bounds):\n        old_rho_bounds = (np.min(curve_polar[:, 0]), np.max(curve_polar[:, 0]))\n        old_theta_bounds = (np.min(curve",
        "_polar[:, 1]",
        "), np.max(curve_polar[:, 1]))\n        return CurveTransforms.remap_polar_to_polar(curve_polar, old_rho_bounds, old_theta_bounds, rho_bounds, theta_bounds)"
    ],
    [
        "def tight_remap_polar_to_polar(curve_polar, rho_bounds, theta_bounds):\n        old_rho_bounds = (np.min(curve_polar[:, 0]), np.max(curve_polar[:, 0]))\n        old_theta_bounds = (np.min(curve_polar[:, 1]), np.max(curve_",
        "polar[:, 1]",
        "))\n        return CurveTransforms.remap_polar_to_polar(curve_polar, old_rho_bounds, old_theta_bounds, rho_bounds, theta_bounds)"
    ],
    [
        "def interpolate(curve: np.ndarray, samples=100, kind=\"cubic\", inplace=True) -> np.ndarray:\n        spline = interp1d(np.linspace(",
        "0, 1, curve.shape[0]), curve.T",
        ")\n        t_fine = np.linspace(0, 1, samples)\n        x_fine, y_fine = spline(t_fine)\n        interpolated_curve = np.vstack((x_fine, y_fine)).T\n        if inplace:\n            curve.resize((2, samples), refcheck=False)\n            curve[:] = interpolated_curve\n            return curve\n        else:\n            return interpolated_curve"
    ],
    [
        "def interpolate(curve: np.ndarray, samples=100, kind=\"cubic\", inplace=True) -> np.ndarray:\n        spline = interp1d(np.linspace(0, 1, curve",
        ".shape[0]",
        "), curve.T, kind=kind)\n        t_fine = np.linspace(0, 1, samples)\n        x_fine, y_fine = spline(t_fine)\n        interpolated_curve = np.vstack((x_fine, y_fine)).T\n        if inplace:\n            curve.resize((2, samples), refcheck=False)\n            curve[:] = interpolated_curve\n            return curve\n        else:\n            return interpolated_curve"
    ],
    [
        "def interpolate(curve: np.ndarray, samples=100, kind=\"cubic\", inplace=True) -> np.ndarray:\n        spline = interp1d(np.linspace(0, 1, curve.shape[0]), curve.T, kind=kind)\n        t_fine = np.linspace(0, 1, ",
        "samples",
        ")\n        x_fine, y_fine = spline(t_fine)\n        interpolated_curve = np.vstack((x_fine, y_fine)).T\n        if inplace:\n            curve.resize((2, samples), refcheck=False)\n            curve[:] = interpolated_curve\n            return curve\n        else:\n            return interpolated_curve"
    ],
    [
        "def interpolate(curve: np.ndarray, samples=100, kind=\"cubic\", inplace=True) -> np.ndarray:\n        spline = interp1d(np.linspace(0, 1, curve.shape[0]), curve.T, kind=kind)\n        t_fine = np.linspace(0, 1, samples)\n        x_fine, y_fine = spline(t_fine)\n        interpolated_curve = np.vstack((x_fine,",
        " y_fine)",
        ").T\n        if inplace:\n            curve.resize((2, samples), refcheck=False)\n            curve[:] = interpolated_curve\n            return curve\n        else:\n            return interpolated_curve"
    ],
    [
        "def interpolate(curve: np.ndarray, samples=100, kind=\"cubic\", inplace=True) -> np.ndarray:\n        spline = interp1d(np.linspace(0, 1, curve.shape[0]), curve.T, kind=kind)\n        t_fine = np.linspace(0, 1, samples)\n        x_fine, y_fine = spline(t_fine)\n        interpolated_curve = np.vstack((x_fine, y_fine)).T\n        if inplace:\n            curve.resize((2, sam",
        "ples)",
        ")\n            curve[:] = interpolated_curve\n            return curve\n        else:\n            return interpolated_curve"
    ],
    [
        "def bezier(control_points, values=np.linspace(0.0, 1.0, 100), polar=False):\n        nodes = control_points\n        if polar:\n            nodes = CurveTransforms.polar_to_cartesian(control",
        "_points",
        ")\n        nodes = np.asfortranarray(nodes)\n        bezier_curve = bezier.Curve(nodes.T, degree=nodes.shape[0] - 1)\n        return bezier_curve.evaluate_multi(values).T"
    ],
    [
        "def math_function(function, values, input_coordinate=\"x_input\", polar=False):\n        if input_coordinate == \"x_input\":\n            x_values = values\n            y_values = np.array([functi",
        "on(x) for x in x_values]",
        ")\n            curve = np.vstack((x_values, y_values)).T\n        elif input_coordinate == \"y_input\":\n            y_values = values\n            x_values = np.array([function(y) for y in y_values])\n            curve = np.vstack((x_values, y_values)).T\n        elif input_coordinate == \"parametric\":\n            result = [function(value) for value in values]\n            curve = np.array(result)\n        else:\n            print(\"Invalid input_coordinate, curve will default to 0,0\")\n            curve = np.array([[0.0, 0.0]])\n        if polar:\n            curve = CurveTransforms.polar_to_cartesian(curve)\n        return curve"
    ],
    [
        "def math_function(function, values, input_coordinate=\"x_input\", polar=False):\n        if input_coordinate == \"x_input\":\n            x_values = values\n            y_values = np.array([function(x) for x in x_values])\n            curve = np.vstack((x_valu",
        "es, y_values)",
        ").T\n        elif input_coordinate == \"y_input\":\n            y_values = values\n            x_values = np.array([function(y) for y in y_values])\n            curve = np.vstack((x_values, y_values)).T\n        elif input_coordinate == \"parametric\":\n            result = [function(value) for value in values]\n            curve = np.array(result)\n        else:\n            print(\"Invalid input_coordinate, curve will default to 0,0\")\n            curve = np.array([[0.0, 0.0]])\n        if polar:\n            curve = CurveTransforms.polar_to_cartesian(curve)\n        return curve"
    ],
    [
        "def math_function(function, values, input_coordinate=\"x_input\", polar=False):\n        if input_coordinate == \"x_input\":\n            x_values = values\n            y_values = np.array([function(x) for x in x_values])\n            curve = np.vstack((x_values, y_values)).T\n        elif input_coordinate == \"y_input\":\n            y_values = values\n            x_values = np.array([functi",
        "on(y) for y in y_values]",
        ")\n            curve = np.vstack((x_values, y_values)).T\n        elif input_coordinate == \"parametric\":\n            result = [function(value) for value in values]\n            curve = np.array(result)\n        else:\n            print(\"Invalid input_coordinate, curve will default to 0,0\")\n            curve = np.array([[0.0, 0.0]])\n        if polar:\n            curve = CurveTransforms.polar_to_cartesian(curve)\n        return curve"
    ],
    [
        "def math_function(function, values, input_coordinate=\"x_input\", polar=False):\n        if input_coordinate == \"x_input\":\n            x_values = values\n            y_values = np.array([function(x) for x in x_values])\n            curve = np.vstack((x_values, y_values)).T\n        elif input_coordinate == \"y_input\":\n            y_values = values\n            x_values = np.array([function(y) for y in y_values])\n            curve = np.vstack((x_values",
        ", y_values)",
        ").T\n        elif input_coordinate == \"parametric\":\n            result = [function(value) for value in values]\n            curve = np.array(result)\n        else:\n            print(\"Invalid input_coordinate, curve will default to 0,0\")\n            curve = np.array([[0.0, 0.0]])\n        if polar:\n            curve = CurveTransforms.polar_to_cartesian(curve)\n        return curve"
    ],
    [
        "def math_function(function, values, input_coordinate=\"x_input\", polar=False):\n        if input_coordinate == \"x_input\":\n            x_values = values\n            y_values = np.array([function(x) for x in x_values])\n            curve = np.vstack((x_values, y_values)).T\n        elif input_coordinate == \"y_input\":\n            y_values = values\n            x_values = np.array([function(y) for y in y_values])\n            curve = np.vstack((x_values, y_values)).T\n        elif input_coordinate == \"parametric\":\n            result = [function(value) for value in values]\n            curve = np.array(result)\n        else:\n            print(\"Invalid input_coordinate,",
        " curve will default to 0,0\"",
        ")\n            curve = np.array([[0.0, 0.0]])\n        if polar:\n            curve = CurveTransforms.polar_to_cartesian(curve)\n        return curve"
    ],
    [
        "def math_function(function, values, input_coordinate=\"x_input\", polar=False):\n        if input_coordinate == \"x_input\":\n            x_values = values\n            y_values = np.array([function(x) for x in x_values])\n            curve = np.vstack((x_values, y_values)).T\n        elif input_coordinate == \"y_input\":\n            y_values = values\n            x_values = np.array([function(y) for y in y_values])\n            curve = np.vstack((x_values, y_values)).T\n        elif input_coordinate == \"parametric\":\n            result = [function(value) for value in values]\n            curve = np.array(result)\n        else:\n            print(\"Invalid input_coordinate, curve will default to 0,0\")\n            curve = np.array([[0.0, ",
        "0.0]]",
        ")\n        if polar:\n            curve = CurveTransforms.polar_to_cartesian(curve)\n        return curve"
    ],
    [
        "def regular_polygon(n, radius=1.0, offset=(0.0, 0.0)):\n        theta = np.linspace(0, 2 * np.",
        "pi, n + 1",
        ")\n        rho = radius * np.ones(n + 1)\n        curve = CurveTransforms.polar_to_cartesian(np.vstack((rho, theta)).T)\n        CurveTransforms.translate_single(curve, offset[0], offset[1], inplace=True)\n        return curve"
    ],
    [
        "def regular_polygon(n, radius=1.0, offset=(0.0, 0.0)):\n        theta = np.linspace(0, 2 * np.pi, n + 1)\n        rho = radius * np.ones(n + 1)\n        curve = CurveTransforms.polar_to_cartesian(np.vstac",
        "k((rho, theta)).T",
        ")\n        CurveTransforms.translate_single(curve, offset[0], offset[1], inplace=True)\n        return curve"
    ],
    [
        "def regular_polygon(n, radius=1.0, offset=(0.0, 0.0)):\n        theta = np.linspace(0, 2 * np.pi, n + 1)\n        rho = radius * np.ones(n + 1)\n        curve = CurveTransforms.polar_to_cartesian(np.vstack((rho, t",
        "heta)",
        ").T)\n        CurveTransforms.translate_single(curve, offset[0], offset[1], inplace=True)\n        return curve"
    ],
    [
        "def regular_polygon(n, radius=1.0, offset=(0.0, 0.0)):\n        theta = np.linspace(0, 2 * np.pi, n + 1)\n        rho = radius * np.ones(n + 1)\n        curve = CurveTransforms.polar_to_cartesian(np.vstack((rho, theta)).T)\n        CurveTransforms.translate_single(curve, offse",
        "t[0], offset[1]",
        ")\n        return curve"
    ],
    [
        "def edge_type1(width=1.0, height=0.2, flip=False, half=False):\n        if flip:\n            height = -height\n        triangle1 = np.array([[0, 0], [0.",
        "1*width, height], [0.2*width, 0]]",
        ")\n        triangle2 = np.array([[0.8*width, 0], [0.9*width, height], [width, 0]])\n        curve_nodes = np.array([[0.2*width, 0], [0.4*width, height], [0.6*width, height], [0.8*width, 0]])\n        curve = CurveGenerator.bezier(curve_nodes, np.linspace(0, 1 - 0.5 * half, 100))\n        if half:\n            return CurveTransforms.merge_curves([triangle1, curve])\n        return CurveTransforms.merge_curves([triangle1, curve, triangle2])"
    ],
    [
        "def edge_type1(width=1.0, height=0.2, flip=False, half=False):\n        if flip:\n            height = -height\n        triangle1 = np.array([[0, 0], [0.1*width, height], [0.2*width, 0]])\n        triangle2 = np.array([[0.8*width, 0], [0.9*w",
        "idth, height], [width, 0]]",
        ")\n        curve_nodes = np.array([[0.2*width, 0], [0.4*width, height], [0.6*width, height], [0.8*width, 0]])\n        curve = CurveGenerator.bezier(curve_nodes, np.linspace(0, 1 - 0.5 * half, 100))\n        if half:\n            return CurveTransforms.merge_curves([triangle1, curve])\n        return CurveTransforms.merge_curves([triangle1, curve, triangle2])"
    ],
    [
        "def edge_type1(width=1.0, height=0.2, flip=False, half=False):\n        if flip:\n            height = -height\n        triangle1 = np.array([[0, 0], [0.1*width, height], [0.2*width, 0]])\n        triangle2 = np.array([[0.8*width, 0], [0.9*width, height], [width, 0]])\n        curve_nodes = np.array([[0.2*width, 0], [0.4*width, height], ",
        "[0.6*width, height], [0.8*width, 0]]",
        ")\n        curve = CurveGenerator.bezier(curve_nodes, np.linspace(0, 1 - 0.5 * half, 100))\n        if half:\n            return CurveTransforms.merge_curves([triangle1, curve])\n        return CurveTransforms.merge_curves([triangle1, curve, triangle2])"
    ],
    [
        "def edge_type1(width=1.0, height=0.2, flip=False, half=False):\n        if flip:\n            height = -height\n        triangle1 = np.array([[0, 0], [0.1*width, height], [0.2*width, 0]])\n        triangle2 = np.array([[0.8*width, 0], [0.9*width, height], [width, 0]])\n        curve_nodes = np.array([[0.2*width, 0], [0.4*width, height], [0.6*width, height], [0.8*width, 0]])\n        curve = CurveGenerator.bezier(curve_nodes, np.linspace(",
        "0, 1 - 0.5 * half, 100)",
        ")\n        if half:\n            return CurveTransforms.merge_curves([triangle1, curve])\n        return CurveTransforms.merge_curves([triangle1, curve, triangle2])"
    ],
    [
        "def edge_type1(width=1.0, height=0.2, flip=False, half=False):\n        if flip:\n            height = -height\n        triangle1 = np.array([[0, 0], [0.1*width, height], [0.2*width, 0]])\n        triangle2 = np.array([[0.8*width, 0], [0.9*width, height], [width, 0]])\n        curve_nodes = np.array([[0.2*width, 0], [0.4*width, height], [0.6*width, height], [0.8*width, 0]])\n        curve = CurveGenerator.bezier(curve_nodes, np.linspace(0, 1 - 0.",
        "5 * half, 100",
        "))\n        if half:\n            return CurveTransforms.merge_curves([triangle1, curve])\n        return CurveTransforms.merge_curves([triangle1, curve, triangle2])"
    ],
    [
        "def edge_type1(width=1.0, height=0.2, flip=False, half=False):\n        if flip:\n            height = -height\n        triangle1 = np.array([[0, 0], [0.1*width, height], [0.2*width, 0]])\n        triangle2 = np.array([[0.8*width, 0], [0.9*width, height], [width, 0]])\n        curve_nodes = np.array([[0.2*width, 0], [0.4*width, height], [0.6*width, height], [0.8*width, 0]])\n        curve = CurveGenerator.bezier(curve_nodes, np.linspace(0, 1 - 0.5 * half, 100))\n        if half:\n            return CurveTransforms.merge_curves([triangle",
        "1, curve]",
        ")\n        return CurveTransforms.merge_curves([triangle1, curve, triangle2])"
    ],
    [
        "def random_edge(grid_size=(1,1), grid_step=(0.1, 0.1), interpolation_type=\"bezier\"):\n        control_nodes = []\n        for i in range(grid_si",
        "ze[0] + 1",
        "):\n            control_nodes.append([i * grid_step[0], np.random.randint(0, grid_size[1] + 1) * grid_step[1]])\n        control_nodes = np.array(control_nodes)\n        if interpolation_type == \"bezier\":\n            curve = CurveGenerator.bezier(control_nodes)\n        elif interpolation_type == \"linear\":\n            curve = control_nodes\n        else:\n            curve = CurveTransforms.interpolate(control_nodes, 100, \"cubic\", False)\n        return curve"
    ],
    [
        "def random_edge(grid_size=(1,1), grid_step=(0.1, 0.1), interpolation_type=\"bezier\"):\n        control_nodes = []\n        for i in range(grid_size[0] + 1):\n            control_nodes.append([i * grid_step[0]",
        ", np.random.randint(0, grid_size[1] + 1) * grid_step[1]]",
        ")\n        control_nodes = np.array(control_nodes)\n        if interpolation_type == \"bezier\":\n            curve = CurveGenerator.bezier(control_nodes)\n        elif interpolation_type == \"linear\":\n            curve = control_nodes\n        else:\n            curve = CurveTransforms.interpolate(control_nodes, 100, \"cubic\", False)\n        return curve"
    ],
    [
        "def random_edge(grid_size=(1,1), grid_step=(0.1, 0.1), interpolation_type=\"bezier\"):\n        control_nodes = []\n        for i in range(grid_size[0] + 1):\n            control_nodes.append([i * grid_step[0], np.random.randint(0, grid_",
        "size[1] + 1",
        ") * grid_step[1]])\n        control_nodes = np.array(control_nodes)\n        if interpolation_type == \"bezier\":\n            curve = CurveGenerator.bezier(control_nodes)\n        elif interpolation_type == \"linear\":\n            curve = control_nodes\n        else:\n            curve = CurveTransforms.interpolate(control_nodes, 100, \"cubic\", False)\n        return curve"
    ],
    [
        "def random_edge(grid_size=(1,1), grid_step=(0.1, 0.1), interpolation_type=\"bezier\"):\n        control_nodes = []\n        for i in range(grid_size[0] + 1):\n            control_nodes.append([i * grid_step[0], np.random.randint(0, grid_size[1] + 1) * grid_step[1]])\n        control_nodes = np.array(control",
        "_nodes",
        ")\n        if interpolation_type == \"bezier\":\n            curve = CurveGenerator.bezier(control_nodes)\n        elif interpolation_type == \"linear\":\n            curve = control_nodes\n        else:\n            curve = CurveTransforms.interpolate(control_nodes, 100, \"cubic\", False)\n        return curve"
    ],
    [
        "def random_edge(grid_size=(1,1), grid_step=(0.1, 0.1), interpolation_type=\"bezier\"):\n        control_nodes = []\n        for i in range(grid_size[0] + 1):\n            control_nodes.append([i * grid_step[0], np.random.randint(0, grid_size[1] + 1) * grid_step[1]])\n        control_nodes = np.array(control_nodes)\n        if interpolation_type == \"bezier\":\n            curve = CurveGenerator.bezier(control",
        "_nodes",
        ")\n        elif interpolation_type == \"linear\":\n            curve = control_nodes\n        else:\n            curve = CurveTransforms.interpolate(control_nodes, 100, \"cubic\", False)\n        return curve"
    ],
    [
        "def random_edge(grid_size=(1,1), grid_step=(0.1, 0.1), interpolation_type=\"bezier\"):\n        control_nodes = []\n        for i in range(grid_size[0] + 1):\n            control_nodes.append([i * grid_step[0], np.random.randint(0, grid_size[1] + 1) * grid_step[1]])\n        control_nodes = np.array(control_nodes)\n        if interpolation_type == \"bezier\":\n            curve = CurveGenerator.bezier(control_nodes)\n        elif interpolation_type == \"linear\":\n            curve = control_nodes\n        else:\n            curve = CurveTransforms.interpolate(control_no",
        "des, 100, \"cubic\", False",
        ")\n        return curve"
    ],
    [
        "def circular_arc(n=100, radius=0.5, theta1=0.0, theta2=np.pi / 2, offset=(0.0, 0.0)):\n        theta = np.linspace(theta1, t",
        "heta2, n",
        ")\n        rho = np.ones(100) * radius\n        curve = CurveTransforms.polar_to_cartesian(np.vstack((rho, theta)).T)\n        CurveTransforms.translate_single(curve, offset[0], offset[1], inplace=True)\n        return curve"
    ],
    [
        "def circular_arc(n=100, radius=0.5, theta1=0.0, theta2=np.pi / 2, offset=(0.0, 0.0)):\n        theta = np.linspace(theta1, theta2, n)\n        rho = np.ones(100) * radius\n        curve = CurveTransforms.polar_to_cartesian(np.vstack(",
        "(rho, theta)).T",
        ")\n        CurveTransforms.translate_single(curve, offset[0], offset[1], inplace=True)\n        return curve"
    ],
    [
        "def circular_arc(n=100, radius=0.5, theta1=0.0, theta2=np.pi / 2, offset=(0.0, 0.0)):\n        theta = np.linspace(theta1, theta2, n)\n        rho = np.ones(100) * radius\n        curve = CurveTransforms.polar_to_cartesian(np.vstack((rho, ",
        "theta)",
        ").T)\n        CurveTransforms.translate_single(curve, offset[0], offset[1], inplace=True)\n        return curve"
    ],
    [
        "def circular_arc(n=100, radius=0.5, theta1=0.0, theta2=np.pi / 2, offset=(0.0, 0.0)):\n        theta = np.linspace(theta1, theta2, n)\n        rho = np.ones(100) * radius\n        curve = CurveTransforms.polar_to_cartesian(np.vstack((rho, theta)).T)\n        CurveTransforms.translate_single(curve, offs",
        "et[0], offset[1]",
        ")\n        return curve"
    ],
    [
        "def sine_wave_circular_arc(n=100, radius=0.5, theta1=0.0, theta2=np.pi/2, amplitude=0.1, n_periods=2, period_offset=0.25, offset=(0.0, 0.0)):\n        theta = np.linspace(theta1,",
        " theta2, n",
        ")\n        period = (theta2 - theta1)/n_periods\n        freq = 2*np.pi/period\n        rho = radius + amplitude*np.sin((theta-theta1+period_offset*period)*freq)\n        curve = CurveTransforms.polar_to_cartesian(np.vstack((rho, theta)).T)\n        CurveTransforms.translate_single(curve, offset[0], offset[1], inplace=True)\n        return curve"
    ],
    [
        "def sine_wave_circular_arc(n=100, radius=0.5, theta1=0.0, theta2=np.pi/2, amplitude=0.1, n_periods=2, period_offset=0.25, offset=(0.0, 0.0)):\n        theta = np.linspace(theta1, theta2, n)\n        period = (theta2 - theta1)/n_periods\n        freq = 2*np.pi/period\n        rho = radius + amplitude*np.sin((theta-theta1+period_",
        "offset*period)*freq",
        ")\n        curve = CurveTransforms.polar_to_cartesian(np.vstack((rho, theta)).T)\n        CurveTransforms.translate_single(curve, offset[0], offset[1], inplace=True)\n        return curve"
    ],
    [
        "def sine_wave_circular_arc(n=100, radius=0.5, theta1=0.0, theta2=np.pi/2, amplitude=0.1, n_periods=2, period_offset=0.25, offset=(0.0, 0.0)):\n        theta = np.linspace(theta1, theta2, n)\n        period = (theta2 - theta1)/n_periods\n        freq = 2*np.pi/period\n        rho = radius + amplitude*np.sin((theta-theta1+period_offset*period)*freq)\n        curve = CurveTransforms.polar_to_cartesian(np.vstack((r",
        "ho, theta)).T",
        ")\n        CurveTransforms.translate_single(curve, offset[0], offset[1], inplace=True)\n        return curve"
    ],
    [
        "def sine_wave_circular_arc(n=100, radius=0.5, theta1=0.0, theta2=np.pi/2, amplitude=0.1, n_periods=2, period_offset=0.25, offset=(0.0, 0.0)):\n        theta = np.linspace(theta1, theta2, n)\n        period = (theta2 - theta1)/n_periods\n        freq = 2*np.pi/period\n        rho = radius + amplitude*np.sin((theta-theta1+period_offset*period)*freq)\n        curve = CurveTransforms.polar_to_cartesian(np.vstack((rho, ",
        "theta)",
        ").T)\n        CurveTransforms.translate_single(curve, offset[0], offset[1], inplace=True)\n        return curve"
    ],
    [
        "def sine_wave_circular_arc(n=100, radius=0.5, theta1=0.0, theta2=np.pi/2, amplitude=0.1, n_periods=2, period_offset=0.25, offset=(0.0, 0.0)):\n        theta = np.linspace(theta1, theta2, n)\n        period = (theta2 - theta1)/n_periods\n        freq = 2*np.pi/period\n        rho = radius + amplitude*np.sin((theta-theta1+period_offset*period)*freq)\n        curve = CurveTransforms.polar_to_cartesian(np.vstack((rho, theta)).T)\n        CurveTransforms.translate_single(curve",
        ", offset[0], offset[1]",
        ")\n        return curve"
    ],
    [
        "def petal(n=100, width=0.1, height=0.2, flat_stop_height=0.1, half=True):\n        arc = CurveGenerator.circular_arc(n, width / 2, 0, np.",
        "pi, (0, flat_stop_height)",
        ")\n        CurveTransforms.scale_single(arc, (1, 2 * (height - flat_stop_height) / width), (0, flat_stop_height))"
    ],
    [
        "def leaf(values=np.linspace(0, 1, 100), width=0.1, height=0.2, half=False):\n        control_nodes = np.array([[0, 0]",
        ", [0, 1], [-1, 1], [-1, 2], [0, 2], [0, 3]]",
        ")\n        curve = CurveGenerator.bezier(control_nodes, values)\n        curve = CurveTransforms.fit_c2c(curve, (-width/2, 0, 0, height))\n        if not half:\n            curve = np.vstack((curve, np.flip(CurveTransforms.scale_single(curve, (-1, 1), inplace=False), 0)))\n        return curve"
    ],
    [
        "def leaf(values=np.linspace(0, 1, 100), width=0.1, height=0.2, half=False):\n        control_nodes = np.array([[0, 0], [0, 1], [-1, 1], [-1, 2], [0, 2], [0, 3]])\n        curve = CurveGenerator.bezier(contr",
        "ol_nodes, values",
        ")\n        curve = CurveTransforms.fit_c2c(curve, (-width/2, 0, 0, height))\n        if not half:\n            curve = np.vstack((curve, np.flip(CurveTransforms.scale_single(curve, (-1, 1), inplace=False), 0)))\n        return curve"
    ],
    [
        "def leaf(values=np.linspace(0, 1, 100), width=0.1, height=0.2, half=False):\n        control_nodes = np.array([[0, 0], [0, 1], [-1, 1], [-1, 2], [0, 2], [0, 3]])\n        curve = CurveGenerator.bezier(control_nodes, values)\n        curve = CurveTransforms.fit_c2c(curve,",
        " (-width/2, 0, 0, height)",
        ")\n        if not half:\n            curve = np.vstack((curve, np.flip(CurveTransforms.scale_single(curve, (-1, 1), inplace=False), 0)))\n        return curve"
    ],
    [
        "def leaf(values=np.linspace(0, 1, 100), width=0.1, height=0.2, half=False):\n        control_nodes = np.array([[0, 0], [0, 1], [-1, 1], [-1, 2], [0, 2], [0, 3]])\n        curve = CurveGenerator.bezier(control_nodes, values)\n        curve = CurveTransforms.fit_c2c(curve, (-width/2, 0, 0, height))\n        if not half:\n            curve = np.vstack((curve, np.flip(CurveTransforms.sca",
        "le_single(curve, (-1, 1), inplace=False), 0))",
        ")\n        return curve"
    ],
    [
        "def leaf(values=np.linspace(0, 1, 100), width=0.1, height=0.2, half=False):\n        control_nodes = np.array([[0, 0], [0, 1], [-1, 1], [-1, 2], [0, 2], [0, 3]])\n        curve = CurveGenerator.bezier(control_nodes, values)\n        curve = CurveTransforms.fit_c2c(curve, (-width/2, 0, 0, height))\n        if not half:\n            curve = np.vstack((curve, np.flip(CurveTransforms.scale_single",
        "(curve, (-1, 1), inplace=False), 0",
        ")))\n        return curve"
    ],
    [
        "def leaf(values=np.linspace(0, 1, 100), width=0.1, height=0.2, half=False):\n        control_nodes = np.array([[0, 0], [0, 1], [-1, 1], [-1, 2], [0, 2], [0, 3]])\n        curve = CurveGenerator.bezier(control_nodes, values)\n        curve = CurveTransforms.fit_c2c(curve, (-width/2, 0, 0, height))\n        if not half:\n            curve = np.vstack((curve, np.flip(CurveTransforms.scale_single(curve",
        ", (-1, 1)",
        "), 0)))\n        return curve"
    ],
    [
        "def pit(n=100, width=0.8, gap=0.2, repetitions=1):\n        start = -(width+gap)/2\n        arc_start = -width/2\n        end = -start\n        arc_end = -arc_start\n        gap1 = np.linspace(start, arc",
        "_start, 10",
        ")\n        gap2 = np.linspace(arc_end, end, 10)\n        gap1 = np.vstack((gap1, np.zeros(10))).T\n        gap2 = np.vstack((gap2, np.zeros(10))).T\n        arc = CurveGenerator.circular_arc(n, width/2, 0, np.pi)\n        CurveTransforms.scale_single(arc, (-1, -1))\n        curve = CurveTransforms.merge_curves([gap1, arc, gap2])\n        curves = []\n        for i in range(repetitions):\n            curves.append(CurveTransforms.translate_single(curve, i*(width+gap), 0, False))\n        return CurveTransforms.merge_curves(curves)"
    ],
    [
        "def pit(n=100, width=0.8, gap=0.2, repetitions=1):\n        start = -(width+gap)/2\n        arc_start = -width/2\n        end = -start\n        arc_end = -arc_start\n        gap1 = np.linspace(start, arc_start, 10)\n        gap2 = np.linspace(arc_end,",
        " end, 10",
        ")\n        gap1 = np.vstack((gap1, np.zeros(10))).T\n        gap2 = np.vstack((gap2, np.zeros(10))).T\n        arc = CurveGenerator.circular_arc(n, width/2, 0, np.pi)\n        CurveTransforms.scale_single(arc, (-1, -1))\n        curve = CurveTransforms.merge_curves([gap1, arc, gap2])\n        curves = []\n        for i in range(repetitions):\n            curves.append(CurveTransforms.translate_single(curve, i*(width+gap), 0, False))\n        return CurveTransforms.merge_curves(curves)"
    ],
    [
        "def pit(n=100, width=0.8, gap=0.2, repetitions=1):\n        start = -(width+gap)/2\n        arc_start = -width/2\n        end = -start\n        arc_end = -arc_start\n        gap1 = np.linspace(start, arc_start, 10)\n        gap2 = np.linspace(arc_end, end, 10)\n        gap1 = np.vstack((gap1, np.z",
        "eros(10))",
        ").T\n        gap2 = np.vstack((gap2, np.zeros(10))).T\n        arc = CurveGenerator.circular_arc(n, width/2, 0, np.pi)\n        CurveTransforms.scale_single(arc, (-1, -1))\n        curve = CurveTransforms.merge_curves([gap1, arc, gap2])\n        curves = []\n        for i in range(repetitions):\n            curves.append(CurveTransforms.translate_single(curve, i*(width+gap), 0, False))\n        return CurveTransforms.merge_curves(curves)"
    ],
    [
        "def pit(n=100, width=0.8, gap=0.2, repetitions=1):\n        start = -(width+gap)/2\n        arc_start = -width/2\n        end = -start\n        arc_end = -arc_start\n        gap1 = np.linspace(start, arc_start, 10)\n        gap2 = np.linspace(arc_end, end, 10)\n        gap1 = np.vstack((gap1, np.zeros(10))).T\n        gap2 = np.vstack((gap2, np.",
        "zeros(10))",
        ").T\n        arc = CurveGenerator.circular_arc(n, width/2, 0, np.pi)\n        CurveTransforms.scale_single(arc, (-1, -1))\n        curve = CurveTransforms.merge_curves([gap1, arc, gap2])\n        curves = []\n        for i in range(repetitions):\n            curves.append(CurveTransforms.translate_single(curve, i*(width+gap), 0, False))\n        return CurveTransforms.merge_curves(curves)"
    ],
    [
        "def pit(n=100, width=0.8, gap=0.2, repetitions=1):\n        start = -(width+gap)/2\n        arc_start = -width/2\n        end = -start\n        arc_end = -arc_start\n        gap1 = np.linspace(start, arc_start, 10)\n        gap2 = np.linspace(arc_end, end, 10)\n        gap1 = np.vstack((gap1, np.zeros(10))).T\n        gap2 = np.vstack((gap2, np.zeros(10))).T\n        arc = CurveGenerator.circular_arc(n, wid",
        "th/2, 0, np.pi",
        ")\n        CurveTransforms.scale_single(arc, (-1, -1))\n        curve = CurveTransforms.merge_curves([gap1, arc, gap2])\n        curves = []\n        for i in range(repetitions):\n            curves.append(CurveTransforms.translate_single(curve, i*(width+gap), 0, False))\n        return CurveTransforms.merge_curves(curves)"
    ],
    [
        "def pit(n=100, width=0.8, gap=0.2, repetitions=1):\n        start = -(width+gap)/2\n        arc_start = -width/2\n        end = -start\n        arc_end = -arc_start\n        gap1 = np.linspace(start, arc_start, 10)\n        gap2 = np.linspace(arc_end, end, 10)\n        gap1 = np.vstack((gap1, np.zeros(10))).T\n        gap2 = np.vstack((gap2, np.zeros(10))).T\n        arc = CurveGenerator.circular_arc(n, width/2, 0, np.pi)\n        CurveTransforms.scale_single(arc, (-",
        "1, -1)",
        ")\n        curve = CurveTransforms.merge_curves([gap1, arc, gap2])\n        curves = []\n        for i in range(repetitions):\n            curves.append(CurveTransforms.translate_single(curve, i*(width+gap), 0, False))\n        return CurveTransforms.merge_curves(curves)"
    ],
    [
        "def pit(n=100, width=0.8, gap=0.2, repetitions=1):\n        start = -(width+gap)/2\n        arc_start = -width/2\n        end = -start\n        arc_end = -arc_start\n        gap1 = np.linspace(start, arc_start, 10)\n        gap2 = np.linspace(arc_end, end, 10)\n        gap1 = np.vstack((gap1, np.zeros(10))).T\n        gap2 = np.vstack((gap2, np.zeros(10))).T\n        arc = CurveGenerator.circular_arc(n, width/2, 0, np.pi)\n        CurveTransforms.scale_single(arc, (-1, -1))\n        curve = CurveTransforms.merge_curves([gap1, a",
        "rc, gap2]",
        ")\n        curves = []\n        for i in range(repetitions):\n            curves.append(CurveTransforms.translate_single(curve, i*(width+gap), 0, False))\n        return CurveTransforms.merge_curves(curves)"
    ],
    [
        "def pit(n=100, width=0.8, gap=0.2, repetitions=1):\n        start = -(width+gap)/2\n        arc_start = -width/2\n        end = -start\n        arc_end = -arc_start\n        gap1 = np.linspace(start, arc_start, 10)\n        gap2 = np.linspace(arc_end, end, 10)\n        gap1 = np.vstack((gap1, np.zeros(10))).T\n        gap2 = np.vstack((gap2, np.zeros(10))).T\n        arc = CurveGenerator.circular_arc(n, width/2, 0, np.pi)\n        CurveTransforms.scale_single(arc, (-1, -1))\n        curve = CurveTransforms.merge_curves([gap1, arc, gap2])\n        curves = []\n        for i in range(repeti",
        "tions",
        "):\n            curves.append(CurveTransforms.translate_single(curve, i*(width+gap), 0, False))\n        return CurveTransforms.merge_curves(curves)"
    ],
    [
        "def pit(n=100, width=0.8, gap=0.2, repetitions=1):\n        start = -(width+gap)/2\n        arc_start = -width/2\n        end = -start\n        arc_end = -arc_start\n        gap1 = np.linspace(start, arc_start, 10)\n        gap2 = np.linspace(arc_end, end, 10)\n        gap1 = np.vstack((gap1, np.zeros(10))).T\n        gap2 = np.vstack((gap2, np.zeros(10))).T\n        arc = CurveGenerator.circular_arc(n, width/2, 0, np.pi)\n        CurveTransforms.scale_single(arc, (-1, -1))\n        curve = CurveTransforms.merge_curves([gap1, arc, gap2])\n        curves = []\n        for i in range(repetitions):\n            curves.append(CurveTransforms.",
        "translate_single(curve, i*(width+gap), 0, False)",
        ")\n        return CurveTransforms.merge_curves(curves)"
    ],
    [
        "def pit(n=100, width=0.8, gap=0.2, repetitions=1):\n        start = -(width+gap)/2\n        arc_start = -width/2\n        end = -start\n        arc_end = -arc_start\n        gap1 = np.linspace(start, arc_start, 10)\n        gap2 = np.linspace(arc_end, end, 10)\n        gap1 = np.vstack((gap1, np.zeros(10))).T\n        gap2 = np.vstack((gap2, np.zeros(10))).T\n        arc = CurveGenerator.circular_arc(n, width/2, 0, np.pi)\n        CurveTransforms.scale_single(arc, (-1, -1))\n        curve = CurveTransforms.merge_curves([gap1, arc, gap2])\n        curves = []\n        for i in range(repetitions):\n            curves.append(CurveTransforms.translate_single(curve, i*(w",
        "idth+gap), 0, False",
        "))\n        return CurveTransforms.merge_curves(curves)"
    ],
    [
        "def sample_from_curve(image, curve, dpu=1000.0):\n        height = image.shape[0]\n        width = image.shape[1]\n        image_ar = width / height\n        x1 = np.min(curve[",
        ":, 0]",
        ")\n        x2 = np.max(curve[:, 0])\n        y1 = np.min(curve[:, 1])\n        y2 = np.max(curve[:, 1])\n        extent = (x1, x2, y1, y2)\n        x_abs = x2 - x1\n        y_abs = y2 - y1\n        clip_ar = x_abs / y_abs\n        if clip_ar < image_ar:\n            new_height = np.minimum(int(np.minimum(height, y_abs*dpu)), height-1)\n            new_width = int(new_height * clip_ar)\n        else:\n            new_width = np.minimum(int(np.minimum(width, x_abs*dpu)), width-1)\n            new_height = int(new_width / clip_ar)\n        origin = (np.random.randint(0, width - new_width), np.random.randint(0, height - new_height))\n        sliced_image = image[origin[1]:origin[1] + new_height, origin[0]:origin[0] + new_width]\n        path = Path(curve)\n        return sliced_image, extent, path"
    ],
    [
        "def sample_from_curve(image, curve, dpu=1000.0):\n        height = image.shape[0]\n        width = image.shape[1]\n        image_ar = width / height\n        x1 = np.min(curve[:, 0])\n        x2 = np.max(curve[",
        ":, 0]",
        ")\n        y1 = np.min(curve[:, 1])\n        y2 = np.max(curve[:, 1])\n        extent = (x1, x2, y1, y2)\n        x_abs = x2 - x1\n        y_abs = y2 - y1\n        clip_ar = x_abs / y_abs\n        if clip_ar < image_ar:\n            new_height = np.minimum(int(np.minimum(height, y_abs*dpu)), height-1)\n            new_width = int(new_height * clip_ar)\n        else:\n            new_width = np.minimum(int(np.minimum(width, x_abs*dpu)), width-1)\n            new_height = int(new_width / clip_ar)\n        origin = (np.random.randint(0, width - new_width), np.random.randint(0, height - new_height))\n        sliced_image = image[origin[1]:origin[1] + new_height, origin[0]:origin[0] + new_width]\n        path = Path(curve)\n        return sliced_image, extent, path"
    ],
    [
        "def sample_from_curve(image, curve, dpu=1000.0):\n        height = image.shape[0]\n        width = image.shape[1]\n        image_ar = width / height\n        x1 = np.min(curve[:, 0])\n        x2 = np.max(curve[:, 0])\n        y1 = np.min(curve",
        "[:, 1]",
        ")\n        y2 = np.max(curve[:, 1])\n        extent = (x1, x2, y1, y2)\n        x_abs = x2 - x1\n        y_abs = y2 - y1\n        clip_ar = x_abs / y_abs\n        if clip_ar < image_ar:\n            new_height = np.minimum(int(np.minimum(height, y_abs*dpu)), height-1)\n            new_width = int(new_height * clip_ar)\n        else:\n            new_width = np.minimum(int(np.minimum(width, x_abs*dpu)), width-1)\n            new_height = int(new_width / clip_ar)\n        origin = (np.random.randint(0, width - new_width), np.random.randint(0, height - new_height))\n        sliced_image = image[origin[1]:origin[1] + new_height, origin[0]:origin[0] + new_width]\n        path = Path(curve)\n        return sliced_image, extent, path"
    ],
    [
        "def sample_from_curve(image, curve, dpu=1000.0):\n        height = image.shape[0]\n        width = image.shape[1]\n        image_ar = width / height\n        x1 = np.min(curve[:, 0])\n        x2 = np.max(curve[:, 0])\n        y1 = np.min(curve[:, 1])\n        y2 = np.max(curve[",
        ":, 1]",
        ")\n        extent = (x1, x2, y1, y2)\n        x_abs = x2 - x1\n        y_abs = y2 - y1\n        clip_ar = x_abs / y_abs\n        if clip_ar < image_ar:\n            new_height = np.minimum(int(np.minimum(height, y_abs*dpu)), height-1)\n            new_width = int(new_height * clip_ar)\n        else:\n            new_width = np.minimum(int(np.minimum(width, x_abs*dpu)), width-1)\n            new_height = int(new_width / clip_ar)\n        origin = (np.random.randint(0, width - new_width), np.random.randint(0, height - new_height))\n        sliced_image = image[origin[1]:origin[1] + new_height, origin[0]:origin[0] + new_width]\n        path = Path(curve)\n        return sliced_image, extent, path"
    ],
    [
        "def sample_from_curve(image, curve, dpu=1000.0):\n        height = image.shape[0]\n        width = image.shape[1]\n        image_ar = width / height\n        x1 = np.min(curve[:, 0])\n        x2 = np.max(curve[:, 0])\n        y1 = np.min(curve[:, 1])\n        y2 = np.max(curve[:, 1])\n        extent = (x1, x2, y1, y2)\n        x_abs = x2 - x1\n        y_abs = y2 - y1\n        clip_ar = x_abs / y_abs\n        if clip_ar < image_ar:\n            new_height = np.minimum(int(n",
        "p.minimum(height, y_abs*dpu)), height-1",
        ")\n            new_width = int(new_height * clip_ar)\n        else:\n            new_width = np.minimum(int(np.minimum(width, x_abs*dpu)), width-1)\n            new_height = int(new_width / clip_ar)\n        origin = (np.random.randint(0, width - new_width), np.random.randint(0, height - new_height))\n        sliced_image = image[origin[1]:origin[1] + new_height, origin[0]:origin[0] + new_width]\n        path = Path(curve)\n        return sliced_image, extent, path"
    ],
    [
        "def sample_from_curve(image, curve, dpu=1000.0):\n        height = image.shape[0]\n        width = image.shape[1]\n        image_ar = width / height\n        x1 = np.min(curve[:, 0])\n        x2 = np.max(curve[:, 0])\n        y1 = np.min(curve[:, 1])\n        y2 = np.max(curve[:, 1])\n        extent = (x1, x2, y1, y2)\n        x_abs = x2 - x1\n        y_abs = y2 - y1\n        clip_ar = x_abs / y_abs\n        if clip_ar < image_ar:\n            new_height = np.minimum(int(np.min",
        "imum(height, y_abs*dpu)",
        "), height-1)\n            new_width = int(new_height * clip_ar)\n        else:\n            new_width = np.minimum(int(np.minimum(width, x_abs*dpu)), width-1)\n            new_height = int(new_width / clip_ar)\n        origin = (np.random.randint(0, width - new_width), np.random.randint(0, height - new_height))\n        sliced_image = image[origin[1]:origin[1] + new_height, origin[0]:origin[0] + new_width]\n        path = Path(curve)\n        return sliced_image, extent, path"
    ],
    [
        "def sample_from_curve(image, curve, dpu=1000.0):\n        height = image.shape[0]\n        width = image.shape[1]\n        image_ar = width / height\n        x1 = np.min(curve[:, 0])\n        x2 = np.max(curve[:, 0])\n        y1 = np.min(curve[:, 1])\n        y2 = np.max(curve[:, 1])\n        extent = (x1, x2, y1, y2)\n        x_abs = x2 - x1\n        y_abs = y2 - y1\n        clip_ar = x_abs / y_abs\n        if clip_ar < image_ar:\n            new_height = np.minimum(int(np.minimum(height,",
        " y_abs*dpu",
        ")), height-1)\n            new_width = int(new_height * clip_ar)\n        else:\n            new_width = np.minimum(int(np.minimum(width, x_abs*dpu)), width-1)\n            new_height = int(new_width / clip_ar)\n        origin = (np.random.randint(0, width - new_width), np.random.randint(0, height - new_height))\n        sliced_image = image[origin[1]:origin[1] + new_height, origin[0]:origin[0] + new_width]\n        path = Path(curve)\n        return sliced_image, extent, path"
    ],
    [
        "def sample_from_curve(image, curve, dpu=1000.0):\n        height = image.shape[0]\n        width = image.shape[1]\n        image_ar = width / height\n        x1 = np.min(curve[:, 0])\n        x2 = np.max(curve[:, 0])\n        y1 = np.min(curve[:, 1])\n        y2 = np.max(curve[:, 1])\n        extent = (x1, x2, y1, y2)\n        x_abs = x2 - x1\n        y_abs = y2 - y1\n        clip_ar = x_abs / y_abs\n        if clip_ar < image_ar:\n            new_height = np.minimum(int(np.minimum(height, y_abs*dpu)), height-1)\n            new_width = int(new_heig",
        "ht * clip_ar",
        ")\n        else:\n            new_width = np.minimum(int(np.minimum(width, x_abs*dpu)), width-1)\n            new_height = int(new_width / clip_ar)\n        origin = (np.random.randint(0, width - new_width), np.random.randint(0, height - new_height))\n        sliced_image = image[origin[1]:origin[1] + new_height, origin[0]:origin[0] + new_width]\n        path = Path(curve)\n        return sliced_image, extent, path"
    ],
    [
        "def sample_from_curve(image, curve, dpu=1000.0):\n        height = image.shape[0]\n        width = image.shape[1]\n        image_ar = width / height\n        x1 = np.min(curve[:, 0])\n        x2 = np.max(curve[:, 0])\n        y1 = np.min(curve[:, 1])\n        y2 = np.max(curve[:, 1])\n        extent = (x1, x2, y1, y2)\n        x_abs = x2 - x1\n        y_abs = y2 - y1\n        clip_ar = x_abs / y_abs\n        if clip_ar < image_ar:\n            new_height = np.minimum(int(np.minimum(height, y_abs*dpu)), height-1)\n            new_width = int(new_height * clip_ar)\n        else:\n            new_width = np.minimum(int(np.minimum(widt",
        "h, x_abs*dpu)), width-1",
        ")\n            new_height = int(new_width / clip_ar)\n        origin = (np.random.randint(0, width - new_width), np.random.randint(0, height - new_height))\n        sliced_image = image[origin[1]:origin[1] + new_height, origin[0]:origin[0] + new_width]\n        path = Path(curve)\n        return sliced_image, extent, path"
    ],
    [
        "def sample_from_curve(image, curve, dpu=1000.0):\n        height = image.shape[0]\n        width = image.shape[1]\n        image_ar = width / height\n        x1 = np.min(curve[:, 0])\n        x2 = np.max(curve[:, 0])\n        y1 = np.min(curve[:, 1])\n        y2 = np.max(curve[:, 1])\n        extent = (x1, x2, y1, y2)\n        x_abs = x2 - x1\n        y_abs = y2 - y1\n        clip_ar = x_abs / y_abs\n        if clip_ar < image_ar:\n            new_height = np.minimum(int(np.minimum(height, y_abs*dpu)), height-1)\n            new_width = int(new_height * clip_ar)\n        else:\n            new_width = np.minimum(int(np.minimum(",
        "width, x_abs*dpu)",
        "), width-1)\n            new_height = int(new_width / clip_ar)\n        origin = (np.random.randint(0, width - new_width), np.random.randint(0, height - new_height))\n        sliced_image = image[origin[1]:origin[1] + new_height, origin[0]:origin[0] + new_width]\n        path = Path(curve)\n        return sliced_image, extent, path"
    ],
    [
        "def sample_from_curve(image, curve, dpu=1000.0):\n        height = image.shape[0]\n        width = image.shape[1]\n        image_ar = width / height\n        x1 = np.min(curve[:, 0])\n        x2 = np.max(curve[:, 0])\n        y1 = np.min(curve[:, 1])\n        y2 = np.max(curve[:, 1])\n        extent = (x1, x2, y1, y2)\n        x_abs = x2 - x1\n        y_abs = y2 - y1\n        clip_ar = x_abs / y_abs\n        if clip_ar < image_ar:\n            new_height = np.minimum(int(np.minimum(height, y_abs*dpu)), height-1)\n            new_width = int(new_height * clip_ar)\n        else:\n            new_width = np.minimum(int(np.minimum(width, x_",
        "abs*dpu",
        ")), width-1)\n            new_height = int(new_width / clip_ar)\n        origin = (np.random.randint(0, width - new_width), np.random.randint(0, height - new_height))\n        sliced_image = image[origin[1]:origin[1] + new_height, origin[0]:origin[0] + new_width]\n        path = Path(curve)\n        return sliced_image, extent, path"
    ],
    [
        "def sample_from_curve(image, curve, dpu=1000.0):\n        height = image.shape[0]\n        width = image.shape[1]\n        image_ar = width / height\n        x1 = np.min(curve[:, 0])\n        x2 = np.max(curve[:, 0])\n        y1 = np.min(curve[:, 1])\n        y2 = np.max(curve[:, 1])\n        extent = (x1, x2, y1, y2)\n        x_abs = x2 - x1\n        y_abs = y2 - y1\n        clip_ar = x_abs / y_abs\n        if clip_ar < image_ar:\n            new_height = np.minimum(int(np.minimum(height, y_abs*dpu)), height-1)\n            new_width = int(new_height * clip_ar)\n        else:\n            new_width = np.minimum(int(np.minimum(width, x_abs*dpu)), width-1)\n            new_height = int(new_width",
        " / clip_ar",
        ")\n        origin = (np.random.randint(0, width - new_width), np.random.randint(0, height - new_height))\n        sliced_image = image[origin[1]:origin[1] + new_height, origin[0]:origin[0] + new_width]\n        path = Path(curve)\n        return sliced_image, extent, path"
    ],
    [
        "def sample_from_curve(image, curve, dpu=1000.0):\n        height = image.shape[0]\n        width = image.shape[1]\n        image_ar = width / height\n        x1 = np.min(curve[:, 0])\n        x2 = np.max(curve[:, 0])\n        y1 = np.min(curve[:, 1])\n        y2 = np.max(curve[:, 1])\n        extent = (x1, x2, y1, y2)\n        x_abs = x2 - x1\n        y_abs = y2 - y1\n        clip_ar = x_abs / y_abs\n        if clip_ar < image_ar:\n            new_height = np.minimum(int(np.minimum(height, y_abs*dpu)), height-1)\n            new_width = int(new_height * clip_ar)\n        else:\n            new_width = np.minimum(int(np.minimum(width, x_abs*dpu)), width-1)\n            new_height = int(new_width / clip_ar)\n        origin = (np.random.randint(0, width",
        " - new_width",
        "), np.random.randint(0, height - new_height))\n        sliced_image = image[origin[1]:origin[1] + new_height, origin[0]:origin[0] + new_width]\n        path = Path(curve)\n        return sliced_image, extent, path"
    ],
    [
        "def sample_from_curve(image, curve, dpu=1000.0):\n        height = image.shape[0]\n        width = image.shape[1]\n        image_ar = width / height\n        x1 = np.min(curve[:, 0])\n        x2 = np.max(curve[:, 0])\n        y1 = np.min(curve[:, 1])\n        y2 = np.max(curve[:, 1])\n        extent = (x1, x2, y1, y2)\n        x_abs = x2 - x1\n        y_abs = y2 - y1\n        clip_ar = x_abs / y_abs\n        if clip_ar < image_ar:\n            new_height = np.minimum(int(np.minimum(height, y_abs*dpu)), height-1)\n            new_width = int(new_height * clip_ar)\n        else:\n            new_width = np.minimum(int(np.minimum(width, x_abs*dpu)), width-1)\n            new_height = int(new_width / clip_ar)\n        origin = (np.random.randint(0, width - new_width), np.random.randint(0, height -",
        " new_height",
        "))\n        sliced_image = image[origin[1]:origin[1] + new_height, origin[0]:origin[0] + new_width]\n        path = Path(curve)\n        return sliced_image, extent, path"
    ],
    [
        "def ring_arc(image, dpu=1000.0, inner_radius=0.0, outer_radius=1.0, theta1=0.0, theta2=np.pi / 6) -> (np.ndarray, (float, float, float, float), Path, List[np.ndarray]):\n        curve1 = CurveGenerator.circular_arc(100, in",
        "ner_radius, theta1, theta2",
        ")\n        curve2 = np.flip(CurveGenerator.circular_arc(100, outer_radius, theta1, theta2), 0)\n        outline_curves = [curve1, curve2]\n        curve = np.vstack((curve1, curve2))\n        (image, extent, path) = ImageSlicer.sample_from_curve(image, curve, dpu)\n        return image, extent, path, outline_curves"
    ],
    [
        "def ring_arc(image, dpu=1000.0, inner_radius=0.0, outer_radius=1.0, theta1=0.0, theta2=np.pi / 6) -> (np.ndarray, (float, float, float, float), Path, List[np.ndarray]):\n        curve1 = CurveGenerator.circular_arc(100, inner_radius, theta1, theta2)\n        curve2 = np.flip(CurveGenerator",
        ".circular_arc(100, outer_radius, theta1, theta2), 0",
        ")\n        outline_curves = [curve1, curve2]\n        curve = np.vstack((curve1, curve2))\n        (image, extent, path) = ImageSlicer.sample_from_curve(image, curve, dpu)\n        return image, extent, path, outline_curves"
    ],
    [
        "def ring_arc(image, dpu=1000.0, inner_radius=0.0, outer_radius=1.0, theta1=0.0, theta2=np.pi / 6) -> (np.ndarray, (float, float, float, float), Path, List[np.ndarray]):\n        curve1 = CurveGenerator.circular_arc(100, inner_radius, theta1, theta2)\n        curve2 = np.flip(CurveGenerator.circular_arc(100, oute",
        "r_radius, theta1, theta2",
        "), 0)\n        outline_curves = [curve1, curve2]\n        curve = np.vstack((curve1, curve2))\n        (image, extent, path) = ImageSlicer.sample_from_curve(image, curve, dpu)\n        return image, extent, path, outline_curves"
    ],
    [
        "def ring_arc(image, dpu=1000.0, inner_radius=0.0, outer_radius=1.0, theta1=0.0, theta2=np.pi / 6) -> (np.ndarray, (float, float, float, float), Path, List[np.ndarray]):\n        curve1 = CurveGenerator.circular_arc(100, inner_radius, theta1, theta2)\n        curve2 = np.flip(CurveGenerator.circular_arc(100, outer_radius, theta1, theta2), 0)\n        outline_curves = [curve1, curve2]\n        curve = np.vstack((curve",
        "1, curve2)",
        ")\n        (image, extent, path) = ImageSlicer.sample_from_curve(image, curve, dpu)\n        return image, extent, path, outline_curves"
    ],
    [
        "def ring_arc(image, dpu=1000.0, inner_radius=0.0, outer_radius=1.0, theta1=0.0, theta2=np.pi / 6) -> (np.ndarray, (float, float, float, float), Path, List[np.ndarray]):\n        curve1 = CurveGenerator.circular_arc(100, inner_radius, theta1, theta2)\n        curve2 = np.flip(CurveGenerator.circular_arc(100, outer_radius, theta1, theta2), 0)\n        outline_curves = [curve1, curve2]\n        curve = np.vstack((curve1, curve2))\n        (image, extent, path) = ImageSlicer.sample_from_curve(image,",
        " curve, dpu",
        ")\n        return image, extent, path, outline_curves"
    ],
    [
        "def serrated_ring_arc(image, dpu=1000.0, segments=3, aligned=True, teeth_width=0.05, inner_radius=0.0,\n                          outer_radius=1.0, theta1=0.0, theta2=np.pi / 6):\n        segments = np.maximum(1, seg",
        "ments",
        ")\n        theta = np.linspace(theta1, theta2, segments + 1)\n        inner_rho = np.array([inner_radius + (i % 2) * teeth_width for i in range(segments + 1)])\n        outer_rho = np.array([outer_radius - ((i + aligned) % 2) * teeth_width for i in range(segments + 1)])\n        curve1 = np.vstack((inner_rho, theta)).T\n        curve2 = np.vstack((outer_rho, np.flip(theta))).T\n        curve1 = CurveTransforms.polar_to_cartesian(curve1)\n        curve2 = CurveTransforms.polar_to_cartesian(curve2)\n        outline_curves = [curve1, curve2]\n        curve = np.vstack((curve1, curve2))\n        (image, extent, path) = ImageSlicer.sample_from_curve(image, curve, dpu)\n        return image, extent, path, outline_curves"
    ],
    [
        "def serrated_ring_arc(image, dpu=1000.0, segments=3, aligned=True, teeth_width=0.05, inner_radius=0.0,\n                          outer_radius=1.0, theta1=0.0, theta2=np.pi / 6):\n        segments = np.maximum(1, segments)\n        theta = np.linspace(theta1, theta2,",
        " segments + 1",
        ")\n        inner_rho = np.array([inner_radius + (i % 2) * teeth_width for i in range(segments + 1)])\n        outer_rho = np.array([outer_radius - ((i + aligned) % 2) * teeth_width for i in range(segments + 1)])\n        curve1 = np.vstack((inner_rho, theta)).T\n        curve2 = np.vstack((outer_rho, np.flip(theta))).T\n        curve1 = CurveTransforms.polar_to_cartesian(curve1)\n        curve2 = CurveTransforms.polar_to_cartesian(curve2)\n        outline_curves = [curve1, curve2]\n        curve = np.vstack((curve1, curve2))\n        (image, extent, path) = ImageSlicer.sample_from_curve(image, curve, dpu)\n        return image, extent, path, outline_curves"
    ],
    [
        "def serrated_ring_arc(image, dpu=1000.0, segments=3, aligned=True, teeth_width=0.05, inner_radius=0.0,\n                          outer_radius=1.0, theta1=0.0, theta2=np.pi / 6):\n        segments = np.maximum(1, segments)\n        theta = np.linspace(theta1, theta2, segments + 1)\n        inner_rho = np.array([inner_radius + (i",
        " % 2) * teeth_width for i in range(segments + 1)]",
        ")\n        outer_rho = np.array([outer_radius - ((i + aligned) % 2) * teeth_width for i in range(segments + 1)])\n        curve1 = np.vstack((inner_rho, theta)).T\n        curve2 = np.vstack((outer_rho, np.flip(theta))).T\n        curve1 = CurveTransforms.polar_to_cartesian(curve1)\n        curve2 = CurveTransforms.polar_to_cartesian(curve2)\n        outline_curves = [curve1, curve2]\n        curve = np.vstack((curve1, curve2))\n        (image, extent, path) = ImageSlicer.sample_from_curve(image, curve, dpu)\n        return image, extent, path, outline_curves"
    ],
    [
        "def serrated_ring_arc(image, dpu=1000.0, segments=3, aligned=True, teeth_width=0.05, inner_radius=0.0,\n                          outer_radius=1.0, theta1=0.0, theta2=np.pi / 6):\n        segments = np.maximum(1, segments)\n        theta = np.linspace(theta1, theta2, segments + 1)\n        inner_rho = np.array([inner_radius + (i % 2) * teeth_width for i in range(segment",
        "s + 1",
        ")])\n        outer_rho = np.array([outer_radius - ((i + aligned) % 2) * teeth_width for i in range(segments + 1)])\n        curve1 = np.vstack((inner_rho, theta)).T\n        curve2 = np.vstack((outer_rho, np.flip(theta))).T\n        curve1 = CurveTransforms.polar_to_cartesian(curve1)\n        curve2 = CurveTransforms.polar_to_cartesian(curve2)\n        outline_curves = [curve1, curve2]\n        curve = np.vstack((curve1, curve2))\n        (image, extent, path) = ImageSlicer.sample_from_curve(image, curve, dpu)\n        return image, extent, path, outline_curves"
    ],
    [
        "def serrated_ring_arc(image, dpu=1000.0, segments=3, aligned=True, teeth_width=0.05, inner_radius=0.0,\n                          outer_radius=1.0, theta1=0.0, theta2=np.pi / 6):\n        segments = np.maximum(1, segments)\n        theta = np.linspace(theta1, theta2, segments + 1)\n        inner_rho = np.array([inner_radius + (i % 2) * teeth_width for i in range(segments + 1)])\n        outer_rho = np.array([outer_radius - ((i + ",
        "aligned) % 2) * teeth_width for i in range(segments + 1)]",
        ")\n        curve1 = np.vstack((inner_rho, theta)).T\n        curve2 = np.vstack((outer_rho, np.flip(theta))).T\n        curve1 = CurveTransforms.polar_to_cartesian(curve1)\n        curve2 = CurveTransforms.polar_to_cartesian(curve2)\n        outline_curves = [curve1, curve2]\n        curve = np.vstack((curve1, curve2))\n        (image, extent, path) = ImageSlicer.sample_from_curve(image, curve, dpu)\n        return image, extent, path, outline_curves"
    ],
    [
        "def serrated_ring_arc(image, dpu=1000.0, segments=3, aligned=True, teeth_width=0.05, inner_radius=0.0,\n                          outer_radius=1.0, theta1=0.0, theta2=np.pi / 6):\n        segments = np.maximum(1, segments)\n        theta = np.linspace(theta1, theta2, segments + 1)\n        inner_rho = np.array([inner_radius + (i % 2) * teeth_width for i in range(segments + 1)])\n        outer_rho = np.array([outer_radius - ((i + aligned) % 2) * teeth_width for i in range(segmen",
        "ts + 1",
        ")])\n        curve1 = np.vstack((inner_rho, theta)).T\n        curve2 = np.vstack((outer_rho, np.flip(theta))).T\n        curve1 = CurveTransforms.polar_to_cartesian(curve1)\n        curve2 = CurveTransforms.polar_to_cartesian(curve2)\n        outline_curves = [curve1, curve2]\n        curve = np.vstack((curve1, curve2))\n        (image, extent, path) = ImageSlicer.sample_from_curve(image, curve, dpu)\n        return image, extent, path, outline_curves"
    ],
    [
        "def serrated_ring_arc(image, dpu=1000.0, segments=3, aligned=True, teeth_width=0.05, inner_radius=0.0,\n                          outer_radius=1.0, theta1=0.0, theta2=np.pi / 6):\n        segments = np.maximum(1, segments)\n        theta = np.linspace(theta1, theta2, segments + 1)\n        inner_rho = np.array([inner_radius + (i % 2) * teeth_width for i in range(segments + 1)])\n        outer_rho = np.array([outer_radius - ((i + aligned) % 2) * teeth_width for i in range(segments + 1)])\n        curve1 = np.vstack((inner_rh",
        "o, theta)",
        ").T\n        curve2 = np.vstack((outer_rho, np.flip(theta))).T\n        curve1 = CurveTransforms.polar_to_cartesian(curve1)\n        curve2 = CurveTransforms.polar_to_cartesian(curve2)\n        outline_curves = [curve1, curve2]\n        curve = np.vstack((curve1, curve2))\n        (image, extent, path) = ImageSlicer.sample_from_curve(image, curve, dpu)\n        return image, extent, path, outline_curves"
    ],
    [
        "def serrated_ring_arc(image, dpu=1000.0, segments=3, aligned=True, teeth_width=0.05, inner_radius=0.0,\n                          outer_radius=1.0, theta1=0.0, theta2=np.pi / 6):\n        segments = np.maximum(1, segments)\n        theta = np.linspace(theta1, theta2, segments + 1)\n        inner_rho = np.array([inner_radius + (i % 2) * teeth_width for i in range(segments + 1)])\n        outer_rho = np.array([outer_radius - ((i + aligned) % 2) * teeth_width for i in range(segments + 1)])\n        curve1 = np.vstack((inner_rho, theta)).T\n        curve2 = np.vstack((outer_rho, ",
        "np.flip(theta))",
        ").T\n        curve1 = CurveTransforms.polar_to_cartesian(curve1)\n        curve2 = CurveTransforms.polar_to_cartesian(curve2)\n        outline_curves = [curve1, curve2]\n        curve = np.vstack((curve1, curve2))\n        (image, extent, path) = ImageSlicer.sample_from_curve(image, curve, dpu)\n        return image, extent, path, outline_curves"
    ],
    [
        "def serrated_ring_arc(image, dpu=1000.0, segments=3, aligned=True, teeth_width=0.05, inner_radius=0.0,\n                          outer_radius=1.0, theta1=0.0, theta2=np.pi / 6):\n        segments = np.maximum(1, segments)\n        theta = np.linspace(theta1, theta2, segments + 1)\n        inner_rho = np.array([inner_radius + (i % 2) * teeth_width for i in range(segments + 1)])\n        outer_rho = np.array([outer_radius - ((i + aligned) % 2) * teeth_width for i in range(segments + 1)])\n        curve1 = np.vstack((inner_rho, theta)).T\n        curve2 = np.vstack((outer_rho, np.flip(theta))).T\n        curve1 = CurveTransforms.polar_to_cartesian(curve1)\n        curve2 = CurveTransforms.polar_to_cartesian(curve2)\n        outline_curves = [curve1, curve2]\n        curve = np.vstack((curve",
        "1, curve2)",
        ")\n        (image, extent, path) = ImageSlicer.sample_from_curve(image, curve, dpu)\n        return image, extent, path, outline_curves"
    ],
    [
        "def serrated_ring_arc(image, dpu=1000.0, segments=3, aligned=True, teeth_width=0.05, inner_radius=0.0,\n                          outer_radius=1.0, theta1=0.0, theta2=np.pi / 6):\n        segments = np.maximum(1, segments)\n        theta = np.linspace(theta1, theta2, segments + 1)\n        inner_rho = np.array([inner_radius + (i % 2) * teeth_width for i in range(segments + 1)])\n        outer_rho = np.array([outer_radius - ((i + aligned) % 2) * teeth_width for i in range(segments + 1)])\n        curve1 = np.vstack((inner_rho, theta)).T\n        curve2 = np.vstack((outer_rho, np.flip(theta))).T\n        curve1 = CurveTransforms.polar_to_cartesian(curve1)\n        curve2 = CurveTransforms.polar_to_cartesian(curve2)\n        outline_curves = [curve1, curve2]\n        curve = np.vstack((curve1, curve2))\n        (image, extent, path) = ImageSlicer.sample_from_curve(image, ",
        "curve, dpu",
        ")\n        return image, extent, path, outline_curves"
    ],
    [
        "def sine_wave_ring_arc(image, dpu=1000.0, n_periods=2, period_offset=0.25, inner_radius=0.5, outer_radius=0.8,\n                           amplitude=0.1, theta1=0.0, theta2=np.pi/2):\n        inner_curve = CurveGenerator.sine_wave_circular_arc(100, inner_radius+amplitu",
        "de, theta1, theta2, amplitude, n_periods, period_offset",
        ")\n        outer_curve = np.flip(CurveGenerator.sine_wave_circular_arc(100, outer_radius-amplitude, theta1, theta2, amplitude, n_periods, period_offset), 0)\n        outline_curves = [inner_curve, outer_curve]\n        curve = np.vstack((inner_curve, outer_curve))\n        (image, extent, path) = ImageSlicer.sample_from_curve(image, curve, dpu)\n        return image, extent, path, outline_curves"
    ],
    [
        "def sine_wave_ring_arc(image, dpu=1000.0, n_periods=2, period_offset=0.25, inner_radius=0.5, outer_radius=0.8,\n                           amplitude=0.1, theta1=0.0, theta2=np.pi/2):\n        inner_curve = CurveGenerator.sine_wave_circular_arc(100, inner_radius+amplitude, theta1, theta2, amplitude, n_periods, period_offset)\n        outer_curve = np.flip(CurveGen",
        "erator.sine_wave_circular_arc(100, outer_radius-amplitude, theta1, theta2, amplitude, n_periods, period_offset), 0",
        ")\n        outline_curves = [inner_curve, outer_curve]\n        curve = np.vstack((inner_curve, outer_curve))\n        (image, extent, path) = ImageSlicer.sample_from_curve(image, curve, dpu)\n        return image, extent, path, outline_curves"
    ],
    [
        "def sine_wave_ring_arc(image, dpu=1000.0, n_periods=2, period_offset=0.25, inner_radius=0.5, outer_radius=0.8,\n                           amplitude=0.1, theta1=0.0, theta2=np.pi/2):\n        inner_curve = CurveGenerator.sine_wave_circular_arc(100, inner_radius+amplitude, theta1, theta2, amplitude, n_periods, period_offset)\n        outer_curve = np.flip(CurveGenerator.sine_wave_circular_arc(100, outer_radius-amplitude, the",
        "ta1, theta2, amplitude, n_periods, period_offset",
        "), 0)\n        outline_curves = [inner_curve, outer_curve]\n        curve = np.vstack((inner_curve, outer_curve))\n        (image, extent, path) = ImageSlicer.sample_from_curve(image, curve, dpu)\n        return image, extent, path, outline_curves"
    ],
    [
        "def sine_wave_ring_arc(image, dpu=1000.0, n_periods=2, period_offset=0.25, inner_radius=0.5, outer_radius=0.8,\n                           amplitude=0.1, theta1=0.0, theta2=np.pi/2):\n        inner_curve = CurveGenerator.sine_wave_circular_arc(100, inner_radius+amplitude, theta1, theta2, amplitude, n_periods, period_offset)\n        outer_curve = np.flip(CurveGenerator.sine_wave_circular_arc(100, outer_radius-amplitude, theta1, theta2, amplitude, n_periods, period_offset), 0)\n        outline_curves = [inner_curve, outer_curve]\n        curve = np.vstack((inner",
        "_curve, outer_curve)",
        ")\n        (image, extent, path) = ImageSlicer.sample_from_curve(image, curve, dpu)\n        return image, extent, path, outline_curves"
    ],
    [
        "def sine_wave_ring_arc(image, dpu=1000.0, n_periods=2, period_offset=0.25, inner_radius=0.5, outer_radius=0.8,\n                           amplitude=0.1, theta1=0.0, theta2=np.pi/2):\n        inner_curve = CurveGenerator.sine_wave_circular_arc(100, inner_radius+amplitude, theta1, theta2, amplitude, n_periods, period_offset)\n        outer_curve = np.flip(CurveGenerator.sine_wave_circular_arc(100, outer_radius-amplitude, theta1, theta2, amplitude, n_periods, period_offset), 0)\n        outline_curves = [inner_curve, outer_curve]\n        curve = np.vstack((inner_curve, outer_curve))\n        (image, extent, path) = ImageSlicer.sample_from_curve(image, c",
        "urve, dpu",
        ")\n        return image, extent, path, outline_curves"
    ],
    [
        "def custom_ring_arc(image, dpu=1000.0, inner_curve: (np.ndarray, int, float, float, str) = (np.array([[0.0, 0.0]]), 1, 0.5, 0.05, \"cartesian\"),\n                        outer_curve: (np.ndarray, int, float, str) = (np.array([[0.0",
        ", 0.0]]",
        "), 1, 0.8, 0.05, \"cartesian\"), theta1=0.0, theta2=np.pi/6,\n                        left_side=False, right_side=False) -> (np.ndarray, (float, float, float, float), Path, List[np.ndarray]):\n        if inner_curve is None:\n            curve1 = np.array([[0, 0]])\n        else:\n            (curve1, periods1, radius1, width1, coordinate_type1) = inner_curve\n            if coordinate_type1 == \"polar\":\n                curve1 = CurveTransforms.tight_remap_polar_to_polar(curve1, (radius1, radius1+width1), (theta1, theta1 + (theta2-theta1)/periods1))\n                curve1 = CurveTransforms.polar_to_cartesian(curve1)\n            else:\n                curve1 = np.vstack((-curve1[:, 0], curve1[:, 1])).T\n                curve1 = CurveTransforms.tight_map_cartesian_to_polar(curve1, (radius1, radius1+width1), (theta1, theta1 + (theta2-theta1)/periods1))\n            curve1 = CurveTransforms.polar_to_cartesian(curve1)\n            curve1 = np.vstack([CurveTransforms.rotate_single(curve1, i * (theta2 - theta1) / periods1, inplace=False) for i in range(0, periods1)])\n        (curve2, periods2, radius2, width2, coordinate_type2) = outer_curve\n        if coordinate_type2 == \"polar\":\n            curve2 = CurveTransforms.tight_remap_polar_to_polar(curve2, (radius2 - width2, radius2), (theta1, theta1 + (theta2-theta1)/periods2))\n            curve2 = CurveTransforms.polar_to_cartesian(curve2)\n        else:\n            curve2 = np.vstack((-curve2[:, 0], curve2[:, 1])).T\n            curve2 = CurveTransforms.tight_map_cartesian_to_polar(curve2, (radius2 - width2, radius2), (theta1, theta1 + (theta2-theta1)/periods2))\n        curve2 = CurveTransforms.polar_to_cartesian(curve2)\n        curve2 = np.flip(np.vstack([CurveTransforms.rotate_single(curve2, i*(theta2-theta1)/periods2, inplace=False) for i in range(0, periods2)]), 0)\n        if left_side and right_side:\n            outline_curves = [np.vstack((curve1, curve2, np.array([[curve1[0, 0], curve1[0, 1]]])))]\n        elif right_side:\n            outline_curves = [np.vstack((curve1, curve2))]\n        elif left_side:\n            outline_curves = [np.vstack((curve2, curve1))]\n        else:\n            outline_curves = [curve1, curve2]\n        curve = np.vstack((curve1, curve2))\n        (image, extent, path) = ImageSlicer.sample_from_curve(image, curve, dpu)\n        return image, extent, path, outline_curves"
    ],
    [
        "def custom_ring_arc(image, dpu=1000.0, inner_curve: (np.ndarray, int, float, float, str) = (np.array([[0.0, 0.0]]), 1, 0.5, 0.05, \"cartesian\"),\n                        outer_curve: (np.ndarray, int, float, str) = (np.array([[0.0, 0.0]]), 1, 0.8, 0.05, \"cartesian\"), theta1=0.0, theta2=np.pi/6,\n                        left_side=False, right_side=False) -> (np.ndarray, (float, float, float, float), Path, List[np.ndarray]):\n        if inner_curve is None:\n            curve1 = np.array([[0, 0]])\n        else:\n            (curve1, periods1, radius1, width1, coordinate_type1) = inner_curve\n            if coordinate_type1 == \"polar\":\n                curve1 = CurveTransforms.tight_remap_polar_to_polar(curve1, (r",
        "adius1, radius1+width1), (theta1, theta1 + (theta2-theta1)/periods1)",
        ")\n                curve1 = CurveTransforms.polar_to_cartesian(curve1)\n            else:\n                curve1 = np.vstack((-curve1[:, 0], curve1[:, 1])).T\n                curve1 = CurveTransforms.tight_map_cartesian_to_polar(curve1, (radius1, radius1+width1), (theta1, theta1 + (theta2-theta1)/periods1))\n            curve1 = CurveTransforms.polar_to_cartesian(curve1)\n            curve1 = np.vstack([CurveTransforms.rotate_single(curve1, i * (theta2 - theta1) / periods1, inplace=False) for i in range(0, periods1)])\n        (curve2, periods2, radius2, width2, coordinate_type2) = outer_curve\n        if coordinate_type2 == \"polar\":\n            curve2 = CurveTransforms.tight_remap_polar_to_polar(curve2, (radius2 - width2, radius2), (theta1, theta1 + (theta2-theta1)/periods2))\n            curve2 = CurveTransforms.polar_to_cartesian(curve2)\n        else:\n            curve2 = np.vstack((-curve2[:, 0], curve2[:, 1])).T\n            curve2 = CurveTransforms.tight_map_cartesian_to_polar(curve2, (radius2 - width2, radius2), (theta1, theta1 + (theta2-theta1)/periods2))\n        curve2 = CurveTransforms.polar_to_cartesian(curve2)\n        curve2 = np.flip(np.vstack([CurveTransforms.rotate_single(curve2, i*(theta2-theta1)/periods2, inplace=False) for i in range(0, periods2)]), 0)\n        if left_side and right_side:\n            outline_curves = [np.vstack((curve1, curve2, np.array([[curve1[0, 0], curve1[0, 1]]])))]\n        elif right_side:\n            outline_curves = [np.vstack((curve1, curve2))]\n        elif left_side:\n            outline_curves = [np.vstack((curve2, curve1))]\n        else:\n            outline_curves = [curve1, curve2]\n        curve = np.vstack((curve1, curve2))\n        (image, extent, path) = ImageSlicer.sample_from_curve(image, curve, dpu)\n        return image, extent, path, outline_curves"
    ],
    [
        "def custom_ring_arc(image, dpu=1000.0, inner_curve: (np.ndarray, int, float, float, str) = (np.array([[0.0, 0.0]]), 1, 0.5, 0.05, \"cartesian\"),\n                        outer_curve: (np.ndarray, int, float, str) = (np.array([[0.0, 0.0]]), 1, 0.8, 0.05, \"cartesian\"), theta1=0.0, theta2=np.pi/6,\n                        left_side=False, right_side=False) -> (np.ndarray, (float, float, float, float), Path, List[np.ndarray]):\n        if inner_curve is None:\n            curve1 = np.array([[0, 0]])\n        else:\n            (curve1, periods1, radius1, width1, coordinate_type1) = inner_curve\n            if coordinate_type1 == \"polar\":\n                curve1 = CurveTransforms.tight_remap_polar_to_polar(curve1, (radius1, radius1+width1), (theta1, theta1 + (theta2-theta1)/periods1))\n                curve1 = CurveTransforms.polar_to_cartesian(curve1)\n            else:\n                curve1 = np.vstack((-curve1[:",
        ", 0], curve1[:, 1])",
        ").T\n                curve1 = CurveTransforms.tight_map_cartesian_to_polar(curve1, (radius1, radius1+width1), (theta1, theta1 + (theta2-theta1)/periods1))\n            curve1 = CurveTransforms.polar_to_cartesian(curve1)\n            curve1 = np.vstack([CurveTransforms.rotate_single(curve1, i * (theta2 - theta1) / periods1, inplace=False) for i in range(0, periods1)])\n        (curve2, periods2, radius2, width2, coordinate_type2) = outer_curve\n        if coordinate_type2 == \"polar\":\n            curve2 = CurveTransforms.tight_remap_polar_to_polar(curve2, (radius2 - width2, radius2), (theta1, theta1 + (theta2-theta1)/periods2))\n            curve2 = CurveTransforms.polar_to_cartesian(curve2)\n        else:\n            curve2 = np.vstack((-curve2[:, 0], curve2[:, 1])).T\n            curve2 = CurveTransforms.tight_map_cartesian_to_polar(curve2, (radius2 - width2, radius2), (theta1, theta1 + (theta2-theta1)/periods2))\n        curve2 = CurveTransforms.polar_to_cartesian(curve2)\n        curve2 = np.flip(np.vstack([CurveTransforms.rotate_single(curve2, i*(theta2-theta1)/periods2, inplace=False) for i in range(0, periods2)]), 0)\n        if left_side and right_side:\n            outline_curves = [np.vstack((curve1, curve2, np.array([[curve1[0, 0], curve1[0, 1]]])))]\n        elif right_side:\n            outline_curves = [np.vstack((curve1, curve2))]\n        elif left_side:\n            outline_curves = [np.vstack((curve2, curve1))]\n        else:\n            outline_curves = [curve1, curve2]\n        curve = np.vstack((curve1, curve2))\n        (image, extent, path) = ImageSlicer.sample_from_curve(image, curve, dpu)\n        return image, extent, path, outline_curves"
    ],
    [
        "def custom_ring_arc(image, dpu=1000.0, inner_curve: (np.ndarray, int, float, float, str) = (np.array([[0.0, 0.0]]), 1, 0.5, 0.05, \"cartesian\"),\n                        outer_curve: (np.ndarray, int, float, str) = (np.array([[0.0, 0.0]]), 1, 0.8, 0.05, \"cartesian\"), theta1=0.0, theta2=np.pi/6,\n                        left_side=False, right_side=False) -> (np.ndarray, (float, float, float, float), Path, List[np.ndarray]):\n        if inner_curve is None:\n            curve1 = np.array([[0, 0]])\n        else:\n            (curve1, periods1, radius1, width1, coordinate_type1) = inner_curve\n            if coordinate_type1 == \"polar\":\n                curve1 = CurveTransforms.tight_remap_polar_to_polar(curve1, (radius1, radius1+width1), (theta1, theta1 + (theta2-theta1)/periods1))\n                curve1 = CurveTransforms.polar_to_cartesian(curve1)\n            else:\n                curve1 = np.vstack((-curve1[:, 0], curve1[:, 1])).T\n                curve1 = CurveTransforms.tight_map_cartesian_to_polar(curve1, (radius1, radius1+width1",
        "), (theta1, theta1 + (theta2-theta1)/periods1)",
        ")\n            curve1 = CurveTransforms.polar_to_cartesian(curve1)\n            curve1 = np.vstack([CurveTransforms.rotate_single(curve1, i * (theta2 - theta1) / periods1, inplace=False) for i in range(0, periods1)])\n        (curve2, periods2, radius2, width2, coordinate_type2) = outer_curve\n        if coordinate_type2 == \"polar\":\n            curve2 = CurveTransforms.tight_remap_polar_to_polar(curve2, (radius2 - width2, radius2), (theta1, theta1 + (theta2-theta1)/periods2))\n            curve2 = CurveTransforms.polar_to_cartesian(curve2)\n        else:\n            curve2 = np.vstack((-curve2[:, 0], curve2[:, 1])).T\n            curve2 = CurveTransforms.tight_map_cartesian_to_polar(curve2, (radius2 - width2, radius2), (theta1, theta1 + (theta2-theta1)/periods2))\n        curve2 = CurveTransforms.polar_to_cartesian(curve2)\n        curve2 = np.flip(np.vstack([CurveTransforms.rotate_single(curve2, i*(theta2-theta1)/periods2, inplace=False) for i in range(0, periods2)]), 0)\n        if left_side and right_side:\n            outline_curves = [np.vstack((curve1, curve2, np.array([[curve1[0, 0], curve1[0, 1]]])))]\n        elif right_side:\n            outline_curves = [np.vstack((curve1, curve2))]\n        elif left_side:\n            outline_curves = [np.vstack((curve2, curve1))]\n        else:\n            outline_curves = [curve1, curve2]\n        curve = np.vstack((curve1, curve2))\n        (image, extent, path) = ImageSlicer.sample_from_curve(image, curve, dpu)\n        return image, extent, path, outline_curves"
    ],
    [
        "def custom_ring_arc(image, dpu=1000.0, inner_curve: (np.ndarray, int, float, float, str) = (np.array([[0.0, 0.0]]), 1, 0.5, 0.05, \"cartesian\"),\n                        outer_curve: (np.ndarray, int, float, str) = (np.array([[0.0, 0.0]]), 1, 0.8, 0.05, \"cartesian\"), theta1=0.0, theta2=np.pi/6,\n                        left_side=False, right_side=False) -> (np.ndarray, (float, float, float, float), Path, List[np.ndarray]):\n        if inner_curve is None:\n            curve1 = np.array([[0, 0]])\n        else:\n            (curve1, periods1, radius1, width1, coordinate_type1) = inner_curve\n            if coordinate_type1 == \"polar\":\n                curve1 = CurveTransforms.tight_remap_polar_to_polar(curve1, (radius1, radius1+width1), (theta1, theta1 + (theta2-theta1)/periods1))\n                curve1 = CurveTransforms.polar_to_cartesian(curve1)\n            else:\n                curve1 = np.vstack((-curve1[:, 0], curve1[:, 1])).T\n                curve1 = CurveTransforms.tight_map_cartesian_to_polar(curve1, (radius1, radius1+width1), (theta1, theta1 + (theta2-theta1)/periods1))\n            curve1 = CurveTransforms.polar_to_cartesian(curve1)\n            curve1 = np.vstack([CurveTransforms.rotate_single(cu",
        "rve1, i * (theta2 - theta1) / periods1, inplace=False) for i in range(0, periods1)]",
        ")\n        (curve2, periods2, radius2, width2, coordinate_type2) = outer_curve\n        if coordinate_type2 == \"polar\":\n            curve2 = CurveTransforms.tight_remap_polar_to_polar(curve2, (radius2 - width2, radius2), (theta1, theta1 + (theta2-theta1)/periods2))\n            curve2 = CurveTransforms.polar_to_cartesian(curve2)\n        else:\n            curve2 = np.vstack((-curve2[:, 0], curve2[:, 1])).T\n            curve2 = CurveTransforms.tight_map_cartesian_to_polar(curve2, (radius2 - width2, radius2), (theta1, theta1 + (theta2-theta1)/periods2))\n        curve2 = CurveTransforms.polar_to_cartesian(curve2)\n        curve2 = np.flip(np.vstack([CurveTransforms.rotate_single(curve2, i*(theta2-theta1)/periods2, inplace=False) for i in range(0, periods2)]), 0)\n        if left_side and right_side:\n            outline_curves = [np.vstack((curve1, curve2, np.array([[curve1[0, 0], curve1[0, 1]]])))]\n        elif right_side:\n            outline_curves = [np.vstack((curve1, curve2))]\n        elif left_side:\n            outline_curves = [np.vstack((curve2, curve1))]\n        else:\n            outline_curves = [curve1, curve2]\n        curve = np.vstack((curve1, curve2))\n        (image, extent, path) = ImageSlicer.sample_from_curve(image, curve, dpu)\n        return image, extent, path, outline_curves"
    ],
    [
        "def custom_ring_arc(image, dpu=1000.0, inner_curve: (np.ndarray, int, float, float, str) = (np.array([[0.0, 0.0]]), 1, 0.5, 0.05, \"cartesian\"),\n                        outer_curve: (np.ndarray, int, float, str) = (np.array([[0.0, 0.0]]), 1, 0.8, 0.05, \"cartesian\"), theta1=0.0, theta2=np.pi/6,\n                        left_side=False, right_side=False) -> (np.ndarray, (float, float, float, float), Path, List[np.ndarray]):\n        if inner_curve is None:\n            curve1 = np.array([[0, 0]])\n        else:\n            (curve1, periods1, radius1, width1, coordinate_type1) = inner_curve\n            if coordinate_type1 == \"polar\":\n                curve1 = CurveTransforms.tight_remap_polar_to_polar(curve1, (radius1, radius1+width1), (theta1, theta1 + (theta2-theta1)/periods1))\n                curve1 = CurveTransforms.polar_to_cartesian(curve1)\n            else:\n                curve1 = np.vstack((-curve1[:, 0], curve1[:, 1])).T\n                curve1 = CurveTransforms.tight_map_cartesian_to_polar(curve1, (radius1, radius1+width1), (theta1, theta1 + (theta2-theta1)/periods1))\n            curve1 = CurveTransforms.polar_to_cartesian(curve1)\n            curve1 = np.vstack([CurveTransforms.rotate_single(curve1, i * ",
        "(theta2 - theta1) / periods1",
        ") for i in range(0, periods1)])\n        (curve2, periods2, radius2, width2, coordinate_type2) = outer_curve\n        if coordinate_type2 == \"polar\":\n            curve2 = CurveTransforms.tight_remap_polar_to_polar(curve2, (radius2 - width2, radius2), (theta1, theta1 + (theta2-theta1)/periods2))\n            curve2 = CurveTransforms.polar_to_cartesian(curve2)\n        else:\n            curve2 = np.vstack((-curve2[:, 0], curve2[:, 1])).T\n            curve2 = CurveTransforms.tight_map_cartesian_to_polar(curve2, (radius2 - width2, radius2), (theta1, theta1 + (theta2-theta1)/periods2))\n        curve2 = CurveTransforms.polar_to_cartesian(curve2)\n        curve2 = np.flip(np.vstack([CurveTransforms.rotate_single(curve2, i*(theta2-theta1)/periods2, inplace=False) for i in range(0, periods2)]), 0)\n        if left_side and right_side:\n            outline_curves = [np.vstack((curve1, curve2, np.array([[curve1[0, 0], curve1[0, 1]]])))]\n        elif right_side:\n            outline_curves = [np.vstack((curve1, curve2))]\n        elif left_side:\n            outline_curves = [np.vstack((curve2, curve1))]\n        else:\n            outline_curves = [curve1, curve2]\n        curve = np.vstack((curve1, curve2))\n        (image, extent, path) = ImageSlicer.sample_from_curve(image, curve, dpu)\n        return image, extent, path, outline_curves"
    ],
    [
        "def custom_ring_arc(image, dpu=1000.0, inner_curve: (np.ndarray, int, float, float, str) = (np.array([[0.0, 0.0]]), 1, 0.5, 0.05, \"cartesian\"),\n                        outer_curve: (np.ndarray, int, float, str) = (np.array([[0.0, 0.0]]), 1, 0.8, 0.05, \"cartesian\"), theta1=0.0, theta2=np.pi/6,\n                        left_side=False, right_side=False) -> (np.ndarray, (float, float, float, float), Path, List[np.ndarray]):\n        if inner_curve is None:\n            curve1 = np.array([[0, 0]])\n        else:\n            (curve1, periods1, radius1, width1, coordinate_type1) = inner_curve\n            if coordinate_type1 == \"polar\":\n                curve1 = CurveTransforms.tight_remap_polar_to_polar(curve1, (radius1, radius1+width1), (theta1, theta1 + (theta2-theta1)/periods1))\n                curve1 = CurveTransforms.polar_to_cartesian(curve1)\n            else:\n                curve1 = np.vstack((-curve1[:, 0], curve1[:, 1])).T\n                curve1 = CurveTransforms.tight_map_cartesian_to_polar(curve1, (radius1, radius1+width1), (theta1, theta1 + (theta2-theta1)/periods1))\n            curve1 = CurveTransforms.polar_to_cartesian(curve1)\n            curve1 = np.vstack([CurveTransforms.rotate_single(curve1, i * (theta2 - theta1) / periods1, inplace=False) for i in range(0, per",
        "iods1",
        ")])\n        (curve2, periods2, radius2, width2, coordinate_type2) = outer_curve\n        if coordinate_type2 == \"polar\":\n            curve2 = CurveTransforms.tight_remap_polar_to_polar(curve2, (radius2 - width2, radius2), (theta1, theta1 + (theta2-theta1)/periods2))\n            curve2 = CurveTransforms.polar_to_cartesian(curve2)\n        else:\n            curve2 = np.vstack((-curve2[:, 0], curve2[:, 1])).T\n            curve2 = CurveTransforms.tight_map_cartesian_to_polar(curve2, (radius2 - width2, radius2), (theta1, theta1 + (theta2-theta1)/periods2))\n        curve2 = CurveTransforms.polar_to_cartesian(curve2)\n        curve2 = np.flip(np.vstack([CurveTransforms.rotate_single(curve2, i*(theta2-theta1)/periods2, inplace=False) for i in range(0, periods2)]), 0)\n        if left_side and right_side:\n            outline_curves = [np.vstack((curve1, curve2, np.array([[curve1[0, 0], curve1[0, 1]]])))]\n        elif right_side:\n            outline_curves = [np.vstack((curve1, curve2))]\n        elif left_side:\n            outline_curves = [np.vstack((curve2, curve1))]\n        else:\n            outline_curves = [curve1, curve2]\n        curve = np.vstack((curve1, curve2))\n        (image, extent, path) = ImageSlicer.sample_from_curve(image, curve, dpu)\n        return image, extent, path, outline_curves"
    ],
    [
        "def custom_ring_arc(image, dpu=1000.0, inner_curve: (np.ndarray, int, float, float, str) = (np.array([[0.0, 0.0]]), 1, 0.5, 0.05, \"cartesian\"),\n                        outer_curve: (np.ndarray, int, float, str) = (np.array([[0.0, 0.0]]), 1, 0.8, 0.05, \"cartesian\"), theta1=0.0, theta2=np.pi/6,\n                        left_side=False, right_side=False) -> (np.ndarray, (float, float, float, float), Path, List[np.ndarray]):\n        if inner_curve is None:\n            curve1 = np.array([[0, 0]])\n        else:\n            (curve1, periods1, radius1, width1, coordinate_type1) = inner_curve\n            if coordinate_type1 == \"polar\":\n                curve1 = CurveTransforms.tight_remap_polar_to_polar(curve1, (radius1, radius1+width1), (theta1, theta1 + (theta2-theta1)/periods1))\n                curve1 = CurveTransforms.polar_to_cartesian(curve1)\n            else:\n                curve1 = np.vstack((-curve1[:, 0], curve1[:, 1])).T\n                curve1 = CurveTransforms.tight_map_cartesian_to_polar(curve1, (radius1, radius1+width1), (theta1, theta1 + (theta2-theta1)/periods1))\n            curve1 = CurveTransforms.polar_to_cartesian(curve1)\n            curve1 = np.vstack([CurveTransforms.rotate_single(curve1, i * (theta2 - theta1) / periods1, inplace=False) for i in range(0, periods1)])\n        (curve2, periods2, radius2, width2, coordinate_type2) = outer_curve\n        if coordinate_type2 == \"polar\":\n            curve2 = CurveTransforms.tight_remap_polar_to_polar(curve2,",
        " (radius2 - width2, radius2), (theta1, theta1 + (theta2-theta1)/periods2)",
        ")\n            curve2 = CurveTransforms.polar_to_cartesian(curve2)\n        else:\n            curve2 = np.vstack((-curve2[:, 0], curve2[:, 1])).T\n            curve2 = CurveTransforms.tight_map_cartesian_to_polar(curve2, (radius2 - width2, radius2), (theta1, theta1 + (theta2-theta1)/periods2))\n        curve2 = CurveTransforms.polar_to_cartesian(curve2)\n        curve2 = np.flip(np.vstack([CurveTransforms.rotate_single(curve2, i*(theta2-theta1)/periods2, inplace=False) for i in range(0, periods2)]), 0)\n        if left_side and right_side:\n            outline_curves = [np.vstack((curve1, curve2, np.array([[curve1[0, 0], curve1[0, 1]]])))]\n        elif right_side:\n            outline_curves = [np.vstack((curve1, curve2))]\n        elif left_side:\n            outline_curves = [np.vstack((curve2, curve1))]\n        else:\n            outline_curves = [curve1, curve2]\n        curve = np.vstack((curve1, curve2))\n        (image, extent, path) = ImageSlicer.sample_from_curve(image, curve, dpu)\n        return image, extent, path, outline_curves"
    ],
    [
        "def custom_ring_arc(image, dpu=1000.0, inner_curve: (np.ndarray, int, float, float, str) = (np.array([[0.0, 0.0]]), 1, 0.5, 0.05, \"cartesian\"),\n                        outer_curve: (np.ndarray, int, float, str) = (np.array([[0.0, 0.0]]), 1, 0.8, 0.05, \"cartesian\"), theta1=0.0, theta2=np.pi/6,\n                        left_side=False, right_side=False) -> (np.ndarray, (float, float, float, float), Path, List[np.ndarray]):\n        if inner_curve is None:\n            curve1 = np.array([[0, 0]])\n        else:\n            (curve1, periods1, radius1, width1, coordinate_type1) = inner_curve\n            if coordinate_type1 == \"polar\":\n                curve1 = CurveTransforms.tight_remap_polar_to_polar(curve1, (radius1, radius1+width1), (theta1, theta1 + (theta2-theta1)/periods1))\n                curve1 = CurveTransforms.polar_to_cartesian(curve1)\n            else:\n                curve1 = np.vstack((-curve1[:, 0], curve1[:, 1])).T\n                curve1 = CurveTransforms.tight_map_cartesian_to_polar(curve1, (radius1, radius1+width1), (theta1, theta1 + (theta2-theta1)/periods1))\n            curve1 = CurveTransforms.polar_to_cartesian(curve1)\n            curve1 = np.vstack([CurveTransforms.rotate_single(curve1, i * (theta2 - theta1) / periods1, inplace=False) for i in range(0, periods1)])\n        (curve2, periods2, radius2, width2, coordinate_type2) = outer_curve\n        if coordinate_type2 == \"polar\":\n            curve2 = CurveTransforms.tight_remap_polar_to_polar(curve2, (radius2 - width2, radius2), (theta1, theta1 + (theta2-theta1)/periods2))\n            curve2 = CurveTransforms.polar_to_cartesian(curve2)\n        else:\n            curve2 = np.vstack((-cur",
        "ve2[:, 0], curve2[:, 1])",
        ").T\n            curve2 = CurveTransforms.tight_map_cartesian_to_polar(curve2, (radius2 - width2, radius2), (theta1, theta1 + (theta2-theta1)/periods2))\n        curve2 = CurveTransforms.polar_to_cartesian(curve2)\n        curve2 = np.flip(np.vstack([CurveTransforms.rotate_single(curve2, i*(theta2-theta1)/periods2, inplace=False) for i in range(0, periods2)]), 0)\n        if left_side and right_side:\n            outline_curves = [np.vstack((curve1, curve2, np.array([[curve1[0, 0], curve1[0, 1]]])))]\n        elif right_side:\n            outline_curves = [np.vstack((curve1, curve2))]\n        elif left_side:\n            outline_curves = [np.vstack((curve2, curve1))]\n        else:\n            outline_curves = [curve1, curve2]\n        curve = np.vstack((curve1, curve2))\n        (image, extent, path) = ImageSlicer.sample_from_curve(image, curve, dpu)\n        return image, extent, path, outline_curves"
    ],
    [
        "def custom_ring_arc(image, dpu=1000.0, inner_curve: (np.ndarray, int, float, float, str) = (np.array([[0.0, 0.0]]), 1, 0.5, 0.05, \"cartesian\"),\n                        outer_curve: (np.ndarray, int, float, str) = (np.array([[0.0, 0.0]]), 1, 0.8, 0.05, \"cartesian\"), theta1=0.0, theta2=np.pi/6,\n                        left_side=False, right_side=False) -> (np.ndarray, (float, float, float, float), Path, List[np.ndarray]):\n        if inner_curve is None:\n            curve1 = np.array([[0, 0]])\n        else:\n            (curve1, periods1, radius1, width1, coordinate_type1) = inner_curve\n            if coordinate_type1 == \"polar\":\n                curve1 = CurveTransforms.tight_remap_polar_to_polar(curve1, (radius1, radius1+width1), (theta1, theta1 + (theta2-theta1)/periods1))\n                curve1 = CurveTransforms.polar_to_cartesian(curve1)\n            else:\n                curve1 = np.vstack((-curve1[:, 0], curve1[:, 1])).T\n                curve1 = CurveTransforms.tight_map_cartesian_to_polar(curve1, (radius1, radius1+width1), (theta1, theta1 + (theta2-theta1)/periods1))\n            curve1 = CurveTransforms.polar_to_cartesian(curve1)\n            curve1 = np.vstack([CurveTransforms.rotate_single(curve1, i * (theta2 - theta1) / periods1, inplace=False) for i in range(0, periods1)])\n        (curve2, periods2, radius2, width2, coordinate_type2) = outer_curve\n        if coordinate_type2 == \"polar\":\n            curve2 = CurveTransforms.tight_remap_polar_to_polar(curve2, (radius2 - width2, radius2), (theta1, theta1 + (theta2-theta1)/periods2))\n            curve2 = CurveTransforms.polar_to_cartesian(curve2)\n        else:\n            curve2 = np.vstack((-curve2[:, 0], curve2[:, 1])).T\n            curve2 = CurveTransforms.tight_map_cartesian_to_polar(curve2, (radius2 - width2, radius2), (",
        "theta1, theta1 + (theta2-theta1)/periods2)",
        ")\n        curve2 = CurveTransforms.polar_to_cartesian(curve2)\n        curve2 = np.flip(np.vstack([CurveTransforms.rotate_single(curve2, i*(theta2-theta1)/periods2, inplace=False) for i in range(0, periods2)]), 0)\n        if left_side and right_side:\n            outline_curves = [np.vstack((curve1, curve2, np.array([[curve1[0, 0], curve1[0, 1]]])))]\n        elif right_side:\n            outline_curves = [np.vstack((curve1, curve2))]\n        elif left_side:\n            outline_curves = [np.vstack((curve2, curve1))]\n        else:\n            outline_curves = [curve1, curve2]\n        curve = np.vstack((curve1, curve2))\n        (image, extent, path) = ImageSlicer.sample_from_curve(image, curve, dpu)\n        return image, extent, path, outline_curves"
    ],
    [
        "def custom_ring_arc(image, dpu=1000.0, inner_curve: (np.ndarray, int, float, float, str) = (np.array([[0.0, 0.0]]), 1, 0.5, 0.05, \"cartesian\"),\n                        outer_curve: (np.ndarray, int, float, str) = (np.array([[0.0, 0.0]]), 1, 0.8, 0.05, \"cartesian\"), theta1=0.0, theta2=np.pi/6,\n                        left_side=False, right_side=False) -> (np.ndarray, (float, float, float, float), Path, List[np.ndarray]):\n        if inner_curve is None:\n            curve1 = np.array([[0, 0]])\n        else:\n            (curve1, periods1, radius1, width1, coordinate_type1) = inner_curve\n            if coordinate_type1 == \"polar\":\n                curve1 = CurveTransforms.tight_remap_polar_to_polar(curve1, (radius1, radius1+width1), (theta1, theta1 + (theta2-theta1)/periods1))\n                curve1 = CurveTransforms.polar_to_cartesian(curve1)\n            else:\n                curve1 = np.vstack((-curve1[:, 0], curve1[:, 1])).T\n                curve1 = CurveTransforms.tight_map_cartesian_to_polar(curve1, (radius1, radius1+width1), (theta1, theta1 + (theta2-theta1)/periods1))\n            curve1 = CurveTransforms.polar_to_cartesian(curve1)\n            curve1 = np.vstack([CurveTransforms.rotate_single(curve1, i * (theta2 - theta1) / periods1, inplace=False) for i in range(0, periods1)])\n        (curve2, periods2, radius2, width2, coordinate_type2) = outer_curve\n        if coordinate_type2 == \"polar\":\n            curve2 = CurveTransforms.tight_remap_polar_to_polar(curve2, (radius2 - width2, radius2), (theta1, theta1 + (theta2-theta1)/periods2))\n            curve2 = CurveTransforms.polar_to_cartesian(curve2)\n        else:\n            curve2 = np.vstack((-curve2[:, 0], curve2[:, 1])).T\n            curve2 = CurveTransforms.tight_map_cartesian_to_polar(curve2, (radius2 - width2, radius2), (theta1, theta1 + (theta2-theta1)/periods2))\n        curve2 = CurveTransforms.polar_to_cartesian(curve2)\n        curve2 = np.flip(np.vstack([CurveT",
        "ransforms.rotate_single(curve2, i*(theta2-theta1)/periods2, inplace=False) for i in range(0, periods2)]), 0",
        ")\n        if left_side and right_side:\n            outline_curves = [np.vstack((curve1, curve2, np.array([[curve1[0, 0], curve1[0, 1]]])))]\n        elif right_side:\n            outline_curves = [np.vstack((curve1, curve2))]\n        elif left_side:\n            outline_curves = [np.vstack((curve2, curve1))]\n        else:\n            outline_curves = [curve1, curve2]\n        curve = np.vstack((curve1, curve2))\n        (image, extent, path) = ImageSlicer.sample_from_curve(image, curve, dpu)\n        return image, extent, path, outline_curves"
    ],
    [
        "def custom_ring_arc(image, dpu=1000.0, inner_curve: (np.ndarray, int, float, float, str) = (np.array([[0.0, 0.0]]), 1, 0.5, 0.05, \"cartesian\"),\n                        outer_curve: (np.ndarray, int, float, str) = (np.array([[0.0, 0.0]]), 1, 0.8, 0.05, \"cartesian\"), theta1=0.0, theta2=np.pi/6,\n                        left_side=False, right_side=False) -> (np.ndarray, (float, float, float, float), Path, List[np.ndarray]):\n        if inner_curve is None:\n            curve1 = np.array([[0, 0]])\n        else:\n            (curve1, periods1, radius1, width1, coordinate_type1) = inner_curve\n            if coordinate_type1 == \"polar\":\n                curve1 = CurveTransforms.tight_remap_polar_to_polar(curve1, (radius1, radius1+width1), (theta1, theta1 + (theta2-theta1)/periods1))\n                curve1 = CurveTransforms.polar_to_cartesian(curve1)\n            else:\n                curve1 = np.vstack((-curve1[:, 0], curve1[:, 1])).T\n                curve1 = CurveTransforms.tight_map_cartesian_to_polar(curve1, (radius1, radius1+width1), (theta1, theta1 + (theta2-theta1)/periods1))\n            curve1 = CurveTransforms.polar_to_cartesian(curve1)\n            curve1 = np.vstack([CurveTransforms.rotate_single(curve1, i * (theta2 - theta1) / periods1, inplace=False) for i in range(0, periods1)])\n        (curve2, periods2, radius2, width2, coordinate_type2) = outer_curve\n        if coordinate_type2 == \"polar\":\n            curve2 = CurveTransforms.tight_remap_polar_to_polar(curve2, (radius2 - width2, radius2), (theta1, theta1 + (theta2-theta1)/periods2))\n            curve2 = CurveTransforms.polar_to_cartesian(curve2)\n        else:\n            curve2 = np.vstack((-curve2[:, 0], curve2[:, 1])).T\n            curve2 = CurveTransforms.tight_map_cartesian_to_polar(curve2, (radius2 - width2, radius2), (theta1, theta1 + (theta2-theta1)/periods2))\n        curve2 = CurveTransforms.polar_to_cartesian(curve2)\n        curve2 = np.flip(np.vstack([Curv",
        "eTransforms.rotate_single(curve2, i*(theta2-theta1)/periods2, inplace=False) for i in range(0, periods2)]",
        "), 0)\n        if left_side and right_side:\n            outline_curves = [np.vstack((curve1, curve2, np.array([[curve1[0, 0], curve1[0, 1]]])))]\n        elif right_side:\n            outline_curves = [np.vstack((curve1, curve2))]\n        elif left_side:\n            outline_curves = [np.vstack((curve2, curve1))]\n        else:\n            outline_curves = [curve1, curve2]\n        curve = np.vstack((curve1, curve2))\n        (image, extent, path) = ImageSlicer.sample_from_curve(image, curve, dpu)\n        return image, extent, path, outline_curves"
    ],
    [
        "def custom_ring_arc(image, dpu=1000.0, inner_curve: (np.ndarray, int, float, float, str) = (np.array([[0.0, 0.0]]), 1, 0.5, 0.05, \"cartesian\"),\n                        outer_curve: (np.ndarray, int, float, str) = (np.array([[0.0, 0.0]]), 1, 0.8, 0.05, \"cartesian\"), theta1=0.0, theta2=np.pi/6,\n                        left_side=False, right_side=False) -> (np.ndarray, (float, float, float, float), Path, List[np.ndarray]):\n        if inner_curve is None:\n            curve1 = np.array([[0, 0]])\n        else:\n            (curve1, periods1, radius1, width1, coordinate_type1) = inner_curve\n            if coordinate_type1 == \"polar\":\n                curve1 = CurveTransforms.tight_remap_polar_to_polar(curve1, (radius1, radius1+width1), (theta1, theta1 + (theta2-theta1)/periods1))\n                curve1 = CurveTransforms.polar_to_cartesian(curve1)\n            else:\n                curve1 = np.vstack((-curve1[:, 0], curve1[:, 1])).T\n                curve1 = CurveTransforms.tight_map_cartesian_to_polar(curve1, (radius1, radius1+width1), (theta1, theta1 + (theta2-theta1)/periods1))\n            curve1 = CurveTransforms.polar_to_cartesian(curve1)\n            curve1 = np.vstack([CurveTransforms.rotate_single(curve1, i * (theta2 - theta1) / periods1, inplace=False) for i in range(0, periods1)])\n        (curve2, periods2, radius2, width2, coordinate_type2) = outer_curve\n        if coordinate_type2 == \"polar\":\n            curve2 = CurveTransforms.tight_remap_polar_to_polar(curve2, (radius2 - width2, radius2), (theta1, theta1 + (theta2-theta1)/periods2))\n            curve2 = CurveTransforms.polar_to_cartesian(curve2)\n        else:\n            curve2 = np.vstack((-curve2[:, 0], curve2[:, 1])).T\n            curve2 = CurveTransforms.tight_map_cartesian_to_polar(curve2, (radius2 - width2, radius2), (theta1, theta1 + (theta2-theta1)/periods2))\n        curve2 = CurveTransforms.polar_to_cartesian(curve2)\n        curve2 = np.flip(np.vstack([CurveTransforms.rotate_single(curve2, ",
        "i*(theta2-theta1)/periods2",
        ") for i in range(0, periods2)]), 0)\n        if left_side and right_side:\n            outline_curves = [np.vstack((curve1, curve2, np.array([[curve1[0, 0], curve1[0, 1]]])))]\n        elif right_side:\n            outline_curves = [np.vstack((curve1, curve2))]\n        elif left_side:\n            outline_curves = [np.vstack((curve2, curve1))]\n        else:\n            outline_curves = [curve1, curve2]\n        curve = np.vstack((curve1, curve2))\n        (image, extent, path) = ImageSlicer.sample_from_curve(image, curve, dpu)\n        return image, extent, path, outline_curves"
    ],
    [
        "def custom_ring_arc(image, dpu=1000.0, inner_curve: (np.ndarray, int, float, float, str) = (np.array([[0.0, 0.0]]), 1, 0.5, 0.05, \"cartesian\"),\n                        outer_curve: (np.ndarray, int, float, str) = (np.array([[0.0, 0.0]]), 1, 0.8, 0.05, \"cartesian\"), theta1=0.0, theta2=np.pi/6,\n                        left_side=False, right_side=False) -> (np.ndarray, (float, float, float, float), Path, List[np.ndarray]):\n        if inner_curve is None:\n            curve1 = np.array([[0, 0]])\n        else:\n            (curve1, periods1, radius1, width1, coordinate_type1) = inner_curve\n            if coordinate_type1 == \"polar\":\n                curve1 = CurveTransforms.tight_remap_polar_to_polar(curve1, (radius1, radius1+width1), (theta1, theta1 + (theta2-theta1)/periods1))\n                curve1 = CurveTransforms.polar_to_cartesian(curve1)\n            else:\n                curve1 = np.vstack((-curve1[:, 0], curve1[:, 1])).T\n                curve1 = CurveTransforms.tight_map_cartesian_to_polar(curve1, (radius1, radius1+width1), (theta1, theta1 + (theta2-theta1)/periods1))\n            curve1 = CurveTransforms.polar_to_cartesian(curve1)\n            curve1 = np.vstack([CurveTransforms.rotate_single(curve1, i * (theta2 - theta1) / periods1, inplace=False) for i in range(0, periods1)])\n        (curve2, periods2, radius2, width2, coordinate_type2) = outer_curve\n        if coordinate_type2 == \"polar\":\n            curve2 = CurveTransforms.tight_remap_polar_to_polar(curve2, (radius2 - width2, radius2), (theta1, theta1 + (theta2-theta1)/periods2))\n            curve2 = CurveTransforms.polar_to_cartesian(curve2)\n        else:\n            curve2 = np.vstack((-curve2[:, 0], curve2[:, 1])).T\n            curve2 = CurveTransforms.tight_map_cartesian_to_polar(curve2, (radius2 - width2, radius2), (theta1, theta1 + (theta2-theta1)/periods2))\n        curve2 = CurveTransforms.polar_to_cartesian(curve2)\n        curve2 = np.flip(np.vstack([CurveTransforms.rotate_single(curve2, i*(theta2-theta1)/periods2, inplace=False) for i in range(0, pe",
        "riods2",
        ")]), 0)\n        if left_side and right_side:\n            outline_curves = [np.vstack((curve1, curve2, np.array([[curve1[0, 0], curve1[0, 1]]])))]\n        elif right_side:\n            outline_curves = [np.vstack((curve1, curve2))]\n        elif left_side:\n            outline_curves = [np.vstack((curve2, curve1))]\n        else:\n            outline_curves = [curve1, curve2]\n        curve = np.vstack((curve1, curve2))\n        (image, extent, path) = ImageSlicer.sample_from_curve(image, curve, dpu)\n        return image, extent, path, outline_curves"
    ],
    [
        "def custom_ring_arc(image, dpu=1000.0, inner_curve: (np.ndarray, int, float, float, str) = (np.array([[0.0, 0.0]]), 1, 0.5, 0.05, \"cartesian\"),\n                        outer_curve: (np.ndarray, int, float, str) = (np.array([[0.0, 0.0]]), 1, 0.8, 0.05, \"cartesian\"), theta1=0.0, theta2=np.pi/6,\n                        left_side=False, right_side=False) -> (np.ndarray, (float, float, float, float), Path, List[np.ndarray]):\n        if inner_curve is None:\n            curve1 = np.array([[0, 0]])\n        else:\n            (curve1, periods1, radius1, width1, coordinate_type1) = inner_curve\n            if coordinate_type1 == \"polar\":\n                curve1 = CurveTransforms.tight_remap_polar_to_polar(curve1, (radius1, radius1+width1), (theta1, theta1 + (theta2-theta1)/periods1))\n                curve1 = CurveTransforms.polar_to_cartesian(curve1)\n            else:\n                curve1 = np.vstack((-curve1[:, 0], curve1[:, 1])).T\n                curve1 = CurveTransforms.tight_map_cartesian_to_polar(curve1, (radius1, radius1+width1), (theta1, theta1 + (theta2-theta1)/periods1))\n            curve1 = CurveTransforms.polar_to_cartesian(curve1)\n            curve1 = np.vstack([CurveTransforms.rotate_single(curve1, i * (theta2 - theta1) / periods1, inplace=False) for i in range(0, periods1)])\n        (curve2, periods2, radius2, width2, coordinate_type2) = outer_curve\n        if coordinate_type2 == \"polar\":\n            curve2 = CurveTransforms.tight_remap_polar_to_polar(curve2, (radius2 - width2, radius2), (theta1, theta1 + (theta2-theta1)/periods2))\n            curve2 = CurveTransforms.polar_to_cartesian(curve2)\n        else:\n            curve2 = np.vstack((-curve2[:, 0], curve2[:, 1])).T\n            curve2 = CurveTransforms.tight_map_cartesian_to_polar(curve2, (radius2 - width2, radius2), (theta1, theta1 + (theta2-theta1)/periods2))\n        curve2 = CurveTransforms.polar_to_cartesian(curve2)\n        curve2 = np.flip(np.vstack([CurveTransforms.rotate_single(curve2, i*(theta2-theta1)/periods2, inplace=False) for i in range(0, periods2)]), 0)\n        if left_side and right_side:\n            outline_curves = [np.vstack((curve1,",
        " curve2, np.array([[curve1[0, 0], curve1[0, 1]]]))",
        ")]\n        elif right_side:\n            outline_curves = [np.vstack((curve1, curve2))]\n        elif left_side:\n            outline_curves = [np.vstack((curve2, curve1))]\n        else:\n            outline_curves = [curve1, curve2]\n        curve = np.vstack((curve1, curve2))\n        (image, extent, path) = ImageSlicer.sample_from_curve(image, curve, dpu)\n        return image, extent, path, outline_curves"
    ],
    [
        "def custom_ring_arc(image, dpu=1000.0, inner_curve: (np.ndarray, int, float, float, str) = (np.array([[0.0, 0.0]]), 1, 0.5, 0.05, \"cartesian\"),\n                        outer_curve: (np.ndarray, int, float, str) = (np.array([[0.0, 0.0]]), 1, 0.8, 0.05, \"cartesian\"), theta1=0.0, theta2=np.pi/6,\n                        left_side=False, right_side=False) -> (np.ndarray, (float, float, float, float), Path, List[np.ndarray]):\n        if inner_curve is None:\n            curve1 = np.array([[0, 0]])\n        else:\n            (curve1, periods1, radius1, width1, coordinate_type1) = inner_curve\n            if coordinate_type1 == \"polar\":\n                curve1 = CurveTransforms.tight_remap_polar_to_polar(curve1, (radius1, radius1+width1), (theta1, theta1 + (theta2-theta1)/periods1))\n                curve1 = CurveTransforms.polar_to_cartesian(curve1)\n            else:\n                curve1 = np.vstack((-curve1[:, 0], curve1[:, 1])).T\n                curve1 = CurveTransforms.tight_map_cartesian_to_polar(curve1, (radius1, radius1+width1), (theta1, theta1 + (theta2-theta1)/periods1))\n            curve1 = CurveTransforms.polar_to_cartesian(curve1)\n            curve1 = np.vstack([CurveTransforms.rotate_single(curve1, i * (theta2 - theta1) / periods1, inplace=False) for i in range(0, periods1)])\n        (curve2, periods2, radius2, width2, coordinate_type2) = outer_curve\n        if coordinate_type2 == \"polar\":\n            curve2 = CurveTransforms.tight_remap_polar_to_polar(curve2, (radius2 - width2, radius2), (theta1, theta1 + (theta2-theta1)/periods2))\n            curve2 = CurveTransforms.polar_to_cartesian(curve2)\n        else:\n            curve2 = np.vstack((-curve2[:, 0], curve2[:, 1])).T\n            curve2 = CurveTransforms.tight_map_cartesian_to_polar(curve2, (radius2 - width2, radius2), (theta1, theta1 + (theta2-theta1)/periods2))\n        curve2 = CurveTransforms.polar_to_cartesian(curve2)\n        curve2 = np.flip(np.vstack([CurveTransforms.rotate_single(curve2, i*(theta2-theta1)/periods2, inplace=False) for i in range(0, periods2)]), 0)\n        if left_side and right_side:\n            outline_curves = [np.vstack((curve1, curve2, np.array([[curve1[0, 0],",
        " curve1[0, 1]]]",
        ")))]\n        elif right_side:\n            outline_curves = [np.vstack((curve1, curve2))]\n        elif left_side:\n            outline_curves = [np.vstack((curve2, curve1))]\n        else:\n            outline_curves = [curve1, curve2]\n        curve = np.vstack((curve1, curve2))\n        (image, extent, path) = ImageSlicer.sample_from_curve(image, curve, dpu)\n        return image, extent, path, outline_curves"
    ],
    [
        "def custom_ring_arc(image, dpu=1000.0, inner_curve: (np.ndarray, int, float, float, str) = (np.array([[0.0, 0.0]]), 1, 0.5, 0.05, \"cartesian\"),\n                        outer_curve: (np.ndarray, int, float, str) = (np.array([[0.0, 0.0]]), 1, 0.8, 0.05, \"cartesian\"), theta1=0.0, theta2=np.pi/6,\n                        left_side=False, right_side=False) -> (np.ndarray, (float, float, float, float), Path, List[np.ndarray]):\n        if inner_curve is None:\n            curve1 = np.array([[0, 0]])\n        else:\n            (curve1, periods1, radius1, width1, coordinate_type1) = inner_curve\n            if coordinate_type1 == \"polar\":\n                curve1 = CurveTransforms.tight_remap_polar_to_polar(curve1, (radius1, radius1+width1), (theta1, theta1 + (theta2-theta1)/periods1))\n                curve1 = CurveTransforms.polar_to_cartesian(curve1)\n            else:\n                curve1 = np.vstack((-curve1[:, 0], curve1[:, 1])).T\n                curve1 = CurveTransforms.tight_map_cartesian_to_polar(curve1, (radius1, radius1+width1), (theta1, theta1 + (theta2-theta1)/periods1))\n            curve1 = CurveTransforms.polar_to_cartesian(curve1)\n            curve1 = np.vstack([CurveTransforms.rotate_single(curve1, i * (theta2 - theta1) / periods1, inplace=False) for i in range(0, periods1)])\n        (curve2, periods2, radius2, width2, coordinate_type2) = outer_curve\n        if coordinate_type2 == \"polar\":\n            curve2 = CurveTransforms.tight_remap_polar_to_polar(curve2, (radius2 - width2, radius2), (theta1, theta1 + (theta2-theta1)/periods2))\n            curve2 = CurveTransforms.polar_to_cartesian(curve2)\n        else:\n            curve2 = np.vstack((-curve2[:, 0], curve2[:, 1])).T\n            curve2 = CurveTransforms.tight_map_cartesian_to_polar(curve2, (radius2 - width2, radius2), (theta1, theta1 + (theta2-theta1)/periods2))\n        curve2 = CurveTransforms.polar_to_cartesian(curve2)\n        curve2 = np.flip(np.vstack([CurveTransforms.rotate_single(curve2, i*(theta2-theta1)/periods2, inplace=False) for i in range(0, periods2)]), 0)\n        if left_side and right_side:\n            outline_curves = [np.vstack((curve1, curve2, np.array([[curve1[0, 0], curve1[0, 1]]])))]\n        elif right_side:\n            outline_curves = [np.vstack((curv",
        "e1, curve2)",
        ")]\n        elif left_side:\n            outline_curves = [np.vstack((curve2, curve1))]\n        else:\n            outline_curves = [curve1, curve2]\n        curve = np.vstack((curve1, curve2))\n        (image, extent, path) = ImageSlicer.sample_from_curve(image, curve, dpu)\n        return image, extent, path, outline_curves"
    ],
    [
        "def custom_ring_arc(image, dpu=1000.0, inner_curve: (np.ndarray, int, float, float, str) = (np.array([[0.0, 0.0]]), 1, 0.5, 0.05, \"cartesian\"),\n                        outer_curve: (np.ndarray, int, float, str) = (np.array([[0.0, 0.0]]), 1, 0.8, 0.05, \"cartesian\"), theta1=0.0, theta2=np.pi/6,\n                        left_side=False, right_side=False) -> (np.ndarray, (float, float, float, float), Path, List[np.ndarray]):\n        if inner_curve is None:\n            curve1 = np.array([[0, 0]])\n        else:\n            (curve1, periods1, radius1, width1, coordinate_type1) = inner_curve\n            if coordinate_type1 == \"polar\":\n                curve1 = CurveTransforms.tight_remap_polar_to_polar(curve1, (radius1, radius1+width1), (theta1, theta1 + (theta2-theta1)/periods1))\n                curve1 = CurveTransforms.polar_to_cartesian(curve1)\n            else:\n                curve1 = np.vstack((-curve1[:, 0], curve1[:, 1])).T\n                curve1 = CurveTransforms.tight_map_cartesian_to_polar(curve1, (radius1, radius1+width1), (theta1, theta1 + (theta2-theta1)/periods1))\n            curve1 = CurveTransforms.polar_to_cartesian(curve1)\n            curve1 = np.vstack([CurveTransforms.rotate_single(curve1, i * (theta2 - theta1) / periods1, inplace=False) for i in range(0, periods1)])\n        (curve2, periods2, radius2, width2, coordinate_type2) = outer_curve\n        if coordinate_type2 == \"polar\":\n            curve2 = CurveTransforms.tight_remap_polar_to_polar(curve2, (radius2 - width2, radius2), (theta1, theta1 + (theta2-theta1)/periods2))\n            curve2 = CurveTransforms.polar_to_cartesian(curve2)\n        else:\n            curve2 = np.vstack((-curve2[:, 0], curve2[:, 1])).T\n            curve2 = CurveTransforms.tight_map_cartesian_to_polar(curve2, (radius2 - width2, radius2), (theta1, theta1 + (theta2-theta1)/periods2))\n        curve2 = CurveTransforms.polar_to_cartesian(curve2)\n        curve2 = np.flip(np.vstack([CurveTransforms.rotate_single(curve2, i*(theta2-theta1)/periods2, inplace=False) for i in range(0, periods2)]), 0)\n        if left_side and right_side:\n            outline_curves = [np.vstack((curve1, curve2, np.array([[curve1[0, 0], curve1[0, 1]]])))]\n        elif right_side:\n            outline_curves = [np.vstack((curve1, curve2))]\n        elif left_side:\n            outline_curves = [np.vstack((curv",
        "e2, curve1)",
        ")]\n        else:\n            outline_curves = [curve1, curve2]\n        curve = np.vstack((curve1, curve2))\n        (image, extent, path) = ImageSlicer.sample_from_curve(image, curve, dpu)\n        return image, extent, path, outline_curves"
    ],
    [
        "def custom_ring_arc(image, dpu=1000.0, inner_curve: (np.ndarray, int, float, float, str) = (np.array([[0.0, 0.0]]), 1, 0.5, 0.05, \"cartesian\"),\n                        outer_curve: (np.ndarray, int, float, str) = (np.array([[0.0, 0.0]]), 1, 0.8, 0.05, \"cartesian\"), theta1=0.0, theta2=np.pi/6,\n                        left_side=False, right_side=False) -> (np.ndarray, (float, float, float, float), Path, List[np.ndarray]):\n        if inner_curve is None:\n            curve1 = np.array([[0, 0]])\n        else:\n            (curve1, periods1, radius1, width1, coordinate_type1) = inner_curve\n            if coordinate_type1 == \"polar\":\n                curve1 = CurveTransforms.tight_remap_polar_to_polar(curve1, (radius1, radius1+width1), (theta1, theta1 + (theta2-theta1)/periods1))\n                curve1 = CurveTransforms.polar_to_cartesian(curve1)\n            else:\n                curve1 = np.vstack((-curve1[:, 0], curve1[:, 1])).T\n                curve1 = CurveTransforms.tight_map_cartesian_to_polar(curve1, (radius1, radius1+width1), (theta1, theta1 + (theta2-theta1)/periods1))\n            curve1 = CurveTransforms.polar_to_cartesian(curve1)\n            curve1 = np.vstack([CurveTransforms.rotate_single(curve1, i * (theta2 - theta1) / periods1, inplace=False) for i in range(0, periods1)])\n        (curve2, periods2, radius2, width2, coordinate_type2) = outer_curve\n        if coordinate_type2 == \"polar\":\n            curve2 = CurveTransforms.tight_remap_polar_to_polar(curve2, (radius2 - width2, radius2), (theta1, theta1 + (theta2-theta1)/periods2))\n            curve2 = CurveTransforms.polar_to_cartesian(curve2)\n        else:\n            curve2 = np.vstack((-curve2[:, 0], curve2[:, 1])).T\n            curve2 = CurveTransforms.tight_map_cartesian_to_polar(curve2, (radius2 - width2, radius2), (theta1, theta1 + (theta2-theta1)/periods2))\n        curve2 = CurveTransforms.polar_to_cartesian(curve2)\n        curve2 = np.flip(np.vstack([CurveTransforms.rotate_single(curve2, i*(theta2-theta1)/periods2, inplace=False) for i in range(0, periods2)]), 0)\n        if left_side and right_side:\n            outline_curves = [np.vstack((curve1, curve2, np.array([[curve1[0, 0], curve1[0, 1]]])))]\n        elif right_side:\n            outline_curves = [np.vstack((curve1, curve2))]\n        elif left_side:\n            outline_curves = [np.vstack((curve2, curve1))]\n        else:\n            outline_curves = [curve1, curve2]\n        curve = np.vstack((curv",
        "e1, curve2)",
        ")\n        (image, extent, path) = ImageSlicer.sample_from_curve(image, curve, dpu)\n        return image, extent, path, outline_curves"
    ],
    [
        "def custom_ring_arc(image, dpu=1000.0, inner_curve: (np.ndarray, int, float, float, str) = (np.array([[0.0, 0.0]]), 1, 0.5, 0.05, \"cartesian\"),\n                        outer_curve: (np.ndarray, int, float, str) = (np.array([[0.0, 0.0]]), 1, 0.8, 0.05, \"cartesian\"), theta1=0.0, theta2=np.pi/6,\n                        left_side=False, right_side=False) -> (np.ndarray, (float, float, float, float), Path, List[np.ndarray]):\n        if inner_curve is None:\n            curve1 = np.array([[0, 0]])\n        else:\n            (curve1, periods1, radius1, width1, coordinate_type1) = inner_curve\n            if coordinate_type1 == \"polar\":\n                curve1 = CurveTransforms.tight_remap_polar_to_polar(curve1, (radius1, radius1+width1), (theta1, theta1 + (theta2-theta1)/periods1))\n                curve1 = CurveTransforms.polar_to_cartesian(curve1)\n            else:\n                curve1 = np.vstack((-curve1[:, 0], curve1[:, 1])).T\n                curve1 = CurveTransforms.tight_map_cartesian_to_polar(curve1, (radius1, radius1+width1), (theta1, theta1 + (theta2-theta1)/periods1))\n            curve1 = CurveTransforms.polar_to_cartesian(curve1)\n            curve1 = np.vstack([CurveTransforms.rotate_single(curve1, i * (theta2 - theta1) / periods1, inplace=False) for i in range(0, periods1)])\n        (curve2, periods2, radius2, width2, coordinate_type2) = outer_curve\n        if coordinate_type2 == \"polar\":\n            curve2 = CurveTransforms.tight_remap_polar_to_polar(curve2, (radius2 - width2, radius2), (theta1, theta1 + (theta2-theta1)/periods2))\n            curve2 = CurveTransforms.polar_to_cartesian(curve2)\n        else:\n            curve2 = np.vstack((-curve2[:, 0], curve2[:, 1])).T\n            curve2 = CurveTransforms.tight_map_cartesian_to_polar(curve2, (radius2 - width2, radius2), (theta1, theta1 + (theta2-theta1)/periods2))\n        curve2 = CurveTransforms.polar_to_cartesian(curve2)\n        curve2 = np.flip(np.vstack([CurveTransforms.rotate_single(curve2, i*(theta2-theta1)/periods2, inplace=False) for i in range(0, periods2)]), 0)\n        if left_side and right_side:\n            outline_curves = [np.vstack((curve1, curve2, np.array([[curve1[0, 0], curve1[0, 1]]])))]\n        elif right_side:\n            outline_curves = [np.vstack((curve1, curve2))]\n        elif left_side:\n            outline_curves = [np.vstack((curve2, curve1))]\n        else:\n            outline_curves = [curve1, curve2]\n        curve = np.vstack((curve1, curve2))\n        (image, extent, path) = ImageSlicer.sample_from_curve(image, c",
        "urve, dpu",
        ")\n        return image, extent, path, outline_curves"
    ],
    [
        "def random_ring_arc(image, dpu=2000.0, grid_size=(5, 5), step_size=(1, 1), inner_radius=0.5, outer_radius=0.8, width=0.1, theta1=0.0, theta2=np.pi/6,\n                        left_side=False, right_side=False, interpolation=\"spline\") -> (np.ndarray, (float, float, float, float), Path, List[np.ndarray]):\n        curve1 = CurveGenerator.random_edge(grid_size, step_si",
        "ze, interpolation",
        ")\n        curve2 = CurveGenerator.random_edge(grid_size, step_size, interpolation)\n        inner_curve = (curve1, 1, inner_radius, width, \"cartesian\")\n        outer_curve = (curve2, 1, outer_radius, width, \"cartesian\")\n        (image, extent, path, outline_curves) = ImageSlicer.custom_ring_arc(image, dpu, inner_curve, outer_curve, theta1, theta2, left_side, right_side)\n        return image, extent, path, outline_curves"
    ],
    [
        "def random_ring_arc(image, dpu=2000.0, grid_size=(5, 5), step_size=(1, 1), inner_radius=0.5, outer_radius=0.8, width=0.1, theta1=0.0, theta2=np.pi/6,\n                        left_side=False, right_side=False, interpolation=\"spline\") -> (np.ndarray, (float, float, float, float), Path, List[np.ndarray]):\n        curve1 = CurveGenerator.random_edge(grid_size, step_size, interpolation)\n        curve2 = CurveGenerator.random_edge(grid_size, ",
        "step_size, interpolation",
        ")\n        inner_curve = (curve1, 1, inner_radius, width, \"cartesian\")\n        outer_curve = (curve2, 1, outer_radius, width, \"cartesian\")\n        (image, extent, path, outline_curves) = ImageSlicer.custom_ring_arc(image, dpu, inner_curve, outer_curve, theta1, theta2, left_side, right_side)\n        return image, extent, path, outline_curves"
    ],
    [
        "def random_ring_arc(image, dpu=2000.0, grid_size=(5, 5), step_size=(1, 1), inner_radius=0.5, outer_radius=0.8, width=0.1, theta1=0.0, theta2=np.pi/6,\n                        left_side=False, right_side=False, interpolation=\"spline\") -> (np.ndarray, (float, float, float, float), Path, List[np.ndarray]):\n        curve1 = CurveGenerator.random_edge(grid_size, step_size, interpolation)\n        curve2 = CurveGenerator.random_edge(grid_size, step_size, interpolation)\n        inner_curve = (curve1, 1, inner_radius, width, \"cartesian\")\n        outer_curve = (curve2, 1, outer_radius, width, \"cartesian\")\n        (image, extent, path, outline_curves) = ImageSlicer.custom_ring_arc(image, dpu, inne",
        "r_curve, outer_curve, theta1, theta2, left_side, right_side",
        ")\n        return image, extent, path, outline_curves"
    ],
    [
        "def regular_polygon_ring_arc(image, dpu=2000.0, sides=1, inner_radius=0.5, outer_radius=0.8, theta1=0.0, theta2=np.pi/6, left_side=False, right_side=False):\n        curve = np.array((np.linspace(0,",
        " 1, sides+1), np.zeros(sides+1))",
        ").T\n        inner_curve = (curve, 1, inner_radius, 0, \"cartesian\")\n        outer_curve = (curve, 1, outer_radius, 0, \"cartesian\")\n        (image, extent, path, outline_curves) = ImageSlicer.custom_ring_arc(image, dpu, inner_curve, outer_curve,\n                                                                            theta1, theta2, left_side, right_side)\n        return image, extent, path, outline_curves"
    ],
    [
        "def regular_polygon_ring_arc(image, dpu=2000.0, sides=1, inner_radius=0.5, outer_radius=0.8, theta1=0.0, theta2=np.pi/6, left_side=False, right_side=False):\n        curve = np.array((np.linspace(0, 1, ",
        "sides+1",
        "), np.zeros(sides+1))).T\n        inner_curve = (curve, 1, inner_radius, 0, \"cartesian\")\n        outer_curve = (curve, 1, outer_radius, 0, \"cartesian\")\n        (image, extent, path, outline_curves) = ImageSlicer.custom_ring_arc(image, dpu, inner_curve, outer_curve,\n                                                                            theta1, theta2, left_side, right_side)\n        return image, extent, path, outline_curves"
    ],
    [
        "def regular_polygon_ring_arc(image, dpu=2000.0, sides=1, inner_radius=0.5, outer_radius=0.8, theta1=0.0, theta2=np.pi/6, left_side=False, right_side=False):\n        curve = np.array((np.linspace(0, 1, sides+1), np.zeros(sides+1))).T\n        inner_curve = (curve, 1, inner_radius, 0, \"cartesian\")\n        outer_curve = (curve, 1, outer_radius, 0, \"cartesian\")\n        (image, extent, path, outline_curves) = ImageSlicer.custom_ring_arc(image, dpu, inner_curve, outer_curve",
        ", theta1, theta2, left_side, right_side",
        ")\n        return image, extent, path, outline_curves"
    ],
    [
        "def leaf(image, dpu=1000.0, width=0.1, height=0.2, half=False):\n        curve = CurveGenerator.leaf(np.linsp",
        "ace(0, 1, 100), width, height, half",
        ")\n        outline_curves = [curve]\n        (image, extent, path) = ImageSlicer.sample_from_curve(image, curve, dpu)\n        return image, extent, path, outline_curves"
    ],
    [
        "def leaf(image, dpu=1000.0, width=0.1, height=0.2, half=False):\n        curve = CurveGenerator.leaf(np.linspace(0, 1, 100), width, height, half)\n        outline_curves = [curve]\n        (image, extent, path) = ImageSlicer.sample_from_curve(image",
        ", curve, dpu",
        ")\n        return image, extent, path, outline_curves"
    ],
    [
        "def filled_center_leaf(image, dpu=1000.0, width=0.1, height=0.2,  half=True):\n        curve = CurveGenerator.leaf(np.lin",
        "space(0.5, 1, 50), width, height, half",
        ")\n        curve = np.vstack(([0, 0], curve))\n        outline_curves = [curve]\n        (image, extent, path) = ImageSlicer.sample_from_curve(image, curve, dpu)\n        return image, extent, path, outline_curves"
    ],
    [
        "def filled_center_leaf(image, dpu=1000.0, width=0.1, height=0.2,  half=True):\n        curve = CurveGenerator.leaf(np.linspace(0.5, 1",
        ", 50",
        "), width, height, half)\n        curve = np.vstack(([0, 0], curve))\n        outline_curves = [curve]\n        (image, extent, path) = ImageSlicer.sample_from_curve(image, curve, dpu)\n        return image, extent, path, outline_curves"
    ],
    [
        "def filled_center_leaf(image, dpu=1000.0, width=0.1, height=0.2,  half=True):\n        curve = CurveGenerator.leaf(np.linspace(0.5, 1, 50), width, height, half)\n        curve = np.vstack(([0, 0],",
        " curve)",
        ")\n        outline_curves = [curve]\n        (image, extent, path) = ImageSlicer.sample_from_curve(image, curve, dpu)\n        return image, extent, path, outline_curves"
    ],
    [
        "def filled_center_leaf(image, dpu=1000.0, width=0.1, height=0.2,  half=True):\n        curve = CurveGenerator.leaf(np.linspace(0.5, 1, 50), width, height, half)\n        curve = np.vstack(([0, 0], curve))\n        outline_curves = [curve]\n        (image, extent, path) = ImageSlicer.sample_from_curve(image",
        ", curve, dpu",
        ")\n        return image, extent, path, outline_curves"
    ],
    [
        "def custom_rect_bounded(image, curve, dpu=1000.0, x_bounds=(-0.3, 0.3), y_bounds=(-0.3, 0.3), sample_rotation=0.0):\n        curve = CurveTransforms.fit_c2c(curve, x_bo",
        "unds + y_bounds",
        ")\n        transform = Affine2D().rotate(sample_rotation)\n        curve = transform.transform(curve)\n        outline_curves = [curve]\n        (image, extent, path) = ImageSlicer.sample_from_curve(image, curve, dpu)\n        return image, extent, path, outline_curves"
    ],
    [
        "def custom_rect_bounded(image, curve, dpu=1000.0, x_bounds=(-0.3, 0.3), y_bounds=(-0.3, 0.3), sample_rotation=0.0):\n        curve = CurveTransforms.fit_c2c(curve, x_bounds + y_bounds)\n        transform = Affine2D().rotate(sample_r",
        "otation",
        ")\n        curve = transform.transform(curve)\n        outline_curves = [curve]\n        (image, extent, path) = ImageSlicer.sample_from_curve(image, curve, dpu)\n        return image, extent, path, outline_curves"
    ],
    [
        "def custom_rect_bounded(image, curve, dpu=1000.0, x_bounds=(-0.3, 0.3), y_bounds=(-0.3, 0.3), sample_rotation=0.0):\n        curve = CurveTransforms.fit_c2c(curve, x_bounds + y_bounds)\n        transform = Affine2D().rotate(sample_rotation)\n        curve = transform.transform(curve)\n        outline_curves = [curve]\n        (image, extent, path) = ImageSlicer.sample_from_curve(image",
        ", curve, dpu",
        ")\n        return image, extent, path, outline_curves"
    ],
    [
        "def plot_persistent(self, ax: \"Axes\", transform, z_order, outline_thickness=0.5, debug_colors=False):\n        if debug_colors:\n            outline_color = ImageSample.outline_colors[ImageSample.current_outline]\n        else:\n            outline_color = [0.0, 0.0, 0.0]\n        for i in range(len(self.Pe",
        "rsistentClipPaths)",
        "):\n            im = ax.imshow(self.Image, extent=self.Extent, origin=\"upper\", cmap=\"gray\", clip_on=True, interpolation=\"bicubic\",\n                           zorder=z_order, transform=self.PersistentTransforms[i] + transform + ax.transData)\n            im.set_clip_path(self.PersistentClipPaths[i], self.PersistentTransforms[i] + transform + ax.transData)\n            for curve in self.LocalOutlineCurves:\n                ax.plot(curve[:, 0], curve[:, 1], color=outline_color, solid_capstyle='round', transform=self.PersistentTransforms[i] + transform + ax.transData, zorder=z_order, linewidth=outline_thickness)"
    ],
    [
        "def plot_persistent(self, ax: \"Axes\", transform, z_order, outline_thickness=0.5, debug_colors=False):\n        if debug_colors:\n            outline_color = ImageSample.outline_colors[ImageSample.current_outline]\n        else:\n            outline_color = [0.0, 0.0, 0.0]\n        for i in range(len(self.",
        "PersistentClipPaths",
        ")):\n            im = ax.imshow(self.Image, extent=self.Extent, origin=\"upper\", cmap=\"gray\", clip_on=True, interpolation=\"bicubic\",\n                           zorder=z_order, transform=self.PersistentTransforms[i] + transform + ax.transData)\n            im.set_clip_path(self.PersistentClipPaths[i], self.PersistentTransforms[i] + transform + ax.transData)\n            for curve in self.LocalOutlineCurves:\n                ax.plot(curve[:, 0], curve[:, 1], color=outline_color, solid_capstyle='round', transform=self.PersistentTransforms[i] + transform + ax.transData, zorder=z_order, linewidth=outline_thickness)"
    ],
    [
        "def plot_persistent(self, ax: \"Axes\", transform, z_order, outline_thickness=0.5, debug_colors=False):\n        if debug_colors:\n            outline_color = ImageSample.outline_colors[ImageSample.current_outline]\n        else:\n            outline_color = [0.0, 0.0, 0.0]\n        for i in range(len(self.PersistentClipPaths)):\n            im = ax.imshow(self.",
        "Image",
        ")\n            im.set_clip_path(self.PersistentClipPaths[i], self.PersistentTransforms[i] + transform + ax.transData)\n            for curve in self.LocalOutlineCurves:\n                ax.plot(curve[:, 0], curve[:, 1], color=outline_color, solid_capstyle='round', transform=self.PersistentTransforms[i] + transform + ax.transData, zorder=z_order, linewidth=outline_thickness)"
    ],
    [
        "def plot_persistent(self, ax: \"Axes\", transform, z_order, outline_thickness=0.5, debug_colors=False):\n        if debug_colors:\n            outline_color = ImageSample.outline_colors[ImageSample.current_outline]\n        else:\n            outline_color = [0.0, 0.0, 0.0]\n        for i in range(len(self.PersistentClipPaths)):\n            im = ax.imshow(self.Image, extent=self.Extent, origin=\"upper\", cmap=\"gray\", clip_on=True, interpolation=\"bicubic\",\n                           zorder=z_order, transform=self.PersistentTransforms[i] + transform + ax.transData)\n            im.set_clip_path(self.PersistentClipPaths[",
        "i], self.PersistentTransforms[i] + transform + ax.transData",
        ")\n            for curve in self.LocalOutlineCurves:\n                ax.plot(curve[:, 0], curve[:, 1], color=outline_color, solid_capstyle='round', transform=self.PersistentTransforms[i] + transform + ax.transData, zorder=z_order, linewidth=outline_thickness)"
    ],
    [
        "def plot(self, ax: \"Axes\", z_order=1, outline_thickness=0.5, debug_colors=False):\n        z_order += 0.001\n        for curve in self.AdditionalCurves:\n            ax.plot(curve[:, ",
        "0], curve[:, 1]",
        ")\n        if len(self.AdditiveTransforms) == 0:\n            self.plot_persistent(ax, Affine2D(), z_order, outline_thickness, debug_colors)\n        else:\n            for transform in self.AdditiveTransforms:\n                self.plot_persistent(ax, transform, z_order, outline_thickness, debug_colors)\n                z_order += 0.001\n        ImageSample.current_outline = (ImageSample.current_outline+1) % 20"
    ],
    [
        "def plot(self, ax: \"Axes\", z_order=1, outline_thickness=0.5, debug_colors=False):\n        z_order += 0.001\n        for curve in self.AdditionalCurves:\n            ax.plot(curve[:, 0], curve[:, 1], color=\"k\", solid_capstyle='round', zorder=z_order, transform=ax.transData, linewidth=outline_thickness)\n        if len(self.Addi",
        "tiveTransforms",
        ") == 0:\n            self.plot_persistent(ax, Affine2D(), z_order, outline_thickness, debug_colors)\n        else:\n            for transform in self.AdditiveTransforms:\n                self.plot_persistent(ax, transform, z_order, outline_thickness, debug_colors)\n                z_order += 0.001\n        ImageSample.current_outline = (ImageSample.current_outline+1) % 20"
    ],
    [
        "def plot(self, ax: \"Axes\", z_order=1, outline_thickness=0.5, debug_colors=False):\n        z_order += 0.001\n        for curve in self.AdditionalCurves:\n            ax.plot(curve[:, 0], curve[:, 1], color=\"k\", solid_capstyle='round', zorder=z_order, transform=ax.transData, linewidth=outline_thickness)\n        if len(self.AdditiveTransforms) == 0:\n            self.plot_persistent(ax, Affine2D(), z_",
        "order, outline_thickness, debug_colors",
        ")\n        else:\n            for transform in self.AdditiveTransforms:\n                self.plot_persistent(ax, transform, z_order, outline_thickness, debug_colors)\n                z_order += 0.001\n        ImageSample.current_outline = (ImageSample.current_outline+1) % 20"
    ],
    [
        "def plot(self, ax: \"Axes\", z_order=1, outline_thickness=0.5, debug_colors=False):\n        z_order += 0.001\n        for curve in self.AdditionalCurves:\n            ax.plot(curve[:, 0], curve[:, 1], color=\"k\", solid_capstyle='round', zorder=z_order, transform=ax.transData, linewidth=outline_thickness)\n        if len(self.AdditiveTransforms) == 0:\n            self.plot_persistent(ax, Affine2D(), z_order, outline_thickness, debug_colors)\n        else:\n            for transform in self.AdditiveTransforms:\n                self.plot_persistent(ax, transform, z_or",
        "der, outline_thickness, debug_colors",
        ")\n                z_order += 0.001\n        ImageSample.current_outline = (ImageSample.current_outline+1) % 20"
    ],
    [
        "def rotational_repeat(repetitions: int = None, delta_angle: float = None, rotation_offset=0.0, use_flip=True, flip_angle=0.0, reverse_rotation=False):\n        if repetitions is None and delta_angle is None:\n            repetitions = 1\n            angle = None\n        elif repetitions is None:\n            repetitions = int(np.tru",
        "nc(2 * np.pi / delta_angle)",
        ")\n            angle = None\n        elif delta_angle is None:\n            repetitions = np.maximum(1, repetitions)\n            angle = None\n        else:\n            repetitions = np.maximum(1, repetitions)\n            angle = delta_angle\n        if angle is None:\n            angle = 2 * np.pi / repetitions\n        if reverse_rotation:\n            angle = -angle\n        transforms = []\n        for i in range(repetitions):\n            if i % 2 == 0 or not use_flip:\n                trans_data = Affine2D().rotate(i * angle + rotation_offset)\n            else:\n                trans_data = Affine2D().rotate(-flip_angle).scale(1, -1).rotate(i * angle + flip_angle + rotation_offset)\n            transforms.append(trans_data)\n        return transforms"
    ],
    [
        "def rotational_repeat(repetitions: int = None, delta_angle: float = None, rotation_offset=0.0, use_flip=True, flip_angle=0.0, reverse_rotation=False):\n        if repetitions is None and delta_angle is None:\n            repetitions = 1\n            angle = None\n        elif repetitions is None:\n            repetitions = int(np.trunc(2 * np.",
        "pi / delta_angle",
        "))\n            angle = None\n        elif delta_angle is None:\n            repetitions = np.maximum(1, repetitions)\n            angle = None\n        else:\n            repetitions = np.maximum(1, repetitions)\n            angle = delta_angle\n        if angle is None:\n            angle = 2 * np.pi / repetitions\n        if reverse_rotation:\n            angle = -angle\n        transforms = []\n        for i in range(repetitions):\n            if i % 2 == 0 or not use_flip:\n                trans_data = Affine2D().rotate(i * angle + rotation_offset)\n            else:\n                trans_data = Affine2D().rotate(-flip_angle).scale(1, -1).rotate(i * angle + flip_angle + rotation_offset)\n            transforms.append(trans_data)\n        return transforms"
    ],
    [
        "def rotational_repeat(repetitions: int = None, delta_angle: float = None, rotation_offset=0.0, use_flip=True, flip_angle=0.0, reverse_rotation=False):\n        if repetitions is None and delta_angle is None:\n            repetitions = 1\n            angle = None\n        elif repetitions is None:\n            repetitions = int(np.trunc(2 * np.pi / delta_angle))\n            angle = None\n        elif delta_angle is None:\n            repetitions = np.maximum(1, re",
        "petitions",
        ")\n            angle = None\n        else:\n            repetitions = np.maximum(1, repetitions)\n            angle = delta_angle\n        if angle is None:\n            angle = 2 * np.pi / repetitions\n        if reverse_rotation:\n            angle = -angle\n        transforms = []\n        for i in range(repetitions):\n            if i % 2 == 0 or not use_flip:\n                trans_data = Affine2D().rotate(i * angle + rotation_offset)\n            else:\n                trans_data = Affine2D().rotate(-flip_angle).scale(1, -1).rotate(i * angle + flip_angle + rotation_offset)\n            transforms.append(trans_data)\n        return transforms"
    ],
    [
        "def rotational_repeat(repetitions: int = None, delta_angle: float = None, rotation_offset=0.0, use_flip=True, flip_angle=0.0, reverse_rotation=False):\n        if repetitions is None and delta_angle is None:\n            repetitions = 1\n            angle = None\n        elif repetitions is None:\n            repetitions = int(np.trunc(2 * np.pi / delta_angle))\n            angle = None\n        elif delta_angle is None:\n            repetitions = np.maximum(1, repetitions)\n            angle = None\n        else:\n            repetitions = np.maximum(1, rep",
        "etitions",
        ")\n            angle = delta_angle\n        if angle is None:\n            angle = 2 * np.pi / repetitions\n        if reverse_rotation:\n            angle = -angle\n        transforms = []\n        for i in range(repetitions):\n            if i % 2 == 0 or not use_flip:\n                trans_data = Affine2D().rotate(i * angle + rotation_offset)\n            else:\n                trans_data = Affine2D().rotate(-flip_angle).scale(1, -1).rotate(i * angle + flip_angle + rotation_offset)\n            transforms.append(trans_data)\n        return transforms"
    ],
    [
        "def rotational_repeat(repetitions: int = None, delta_angle: float = None, rotation_offset=0.0, use_flip=True, flip_angle=0.0, reverse_rotation=False):\n        if repetitions is None and delta_angle is None:\n            repetitions = 1\n            angle = None\n        elif repetitions is None:\n            repetitions = int(np.trunc(2 * np.pi / delta_angle))\n            angle = None\n        elif delta_angle is None:\n            repetitions = np.maximum(1, repetitions)\n            angle = None\n        else:\n            repetitions = np.maximum(1, repetitions)\n            angle = delta_angle\n        if angle is None:\n            angle = 2 * np.pi / repetitions\n        if reverse_rotation:\n            angle = -angle\n        transforms = []\n        for i in range(repet",
        "itions",
        "):\n            if i % 2 == 0 or not use_flip:\n                trans_data = Affine2D().rotate(i * angle + rotation_offset)\n            else:\n                trans_data = Affine2D().rotate(-flip_angle).scale(1, -1).rotate(i * angle + flip_angle + rotation_offset)\n            transforms.append(trans_data)\n        return transforms"
    ],
    [
        "def rotational_repeat(repetitions: int = None, delta_angle: float = None, rotation_offset=0.0, use_flip=True, flip_angle=0.0, reverse_rotation=False):\n        if repetitions is None and delta_angle is None:\n            repetitions = 1\n            angle = None\n        elif repetitions is None:\n            repetitions = int(np.trunc(2 * np.pi / delta_angle))\n            angle = None\n        elif delta_angle is None:\n            repetitions = np.maximum(1, repetitions)\n            angle = None\n        else:\n            repetitions = np.maximum(1, repetitions)\n            angle = delta_angle\n        if angle is None:\n            angle = 2 * np.pi / repetitions\n        if reverse_rotation:\n            angle = -angle\n        transforms = []\n        for i in range(repetitions):\n            if i % 2 == 0 or not use_flip:\n                trans_data = Affine2D().rotate(i * angl",
        "e + rotation_offset",
        ")\n            else:\n                trans_data = Affine2D().rotate(-flip_angle).scale(1, -1).rotate(i * angle + flip_angle + rotation_offset)\n            transforms.append(trans_data)\n        return transforms"
    ],
    [
        "def rotational_repeat(repetitions: int = None, delta_angle: float = None, rotation_offset=0.0, use_flip=True, flip_angle=0.0, reverse_rotation=False):\n        if repetitions is None and delta_angle is None:\n            repetitions = 1\n            angle = None\n        elif repetitions is None:\n            repetitions = int(np.trunc(2 * np.pi / delta_angle))\n            angle = None\n        elif delta_angle is None:\n            repetitions = np.maximum(1, repetitions)\n            angle = None\n        else:\n            repetitions = np.maximum(1, repetitions)\n            angle = delta_angle\n        if angle is None:\n            angle = 2 * np.pi / repetitions\n        if reverse_rotation:\n            angle = -angle\n        transforms = []\n        for i in range(repetitions):\n            if i % 2 == 0 or not use_flip:\n                trans_data = Affine2D().rotate(i * angle + rotation_offset)\n            else:\n                trans_data = Affine2D().rotate(-flip_angle).scale(1, -1).rotate(i * angle +",
        " flip_angle + rotation_offset",
        ")\n            transforms.append(trans_data)\n        return transforms"
    ],
    [
        "def rotational_repeat(repetitions: int = None, delta_angle: float = None, rotation_offset=0.0, use_flip=True, flip_angle=0.0, reverse_rotation=False):\n        if repetitions is None and delta_angle is None:\n            repetitions = 1\n            angle = None\n        elif repetitions is None:\n            repetitions = int(np.trunc(2 * np.pi / delta_angle))\n            angle = None\n        elif delta_angle is None:\n            repetitions = np.maximum(1, repetitions)\n            angle = None\n        else:\n            repetitions = np.maximum(1, repetitions)\n            angle = delta_angle\n        if angle is None:\n            angle = 2 * np.pi / repetitions\n        if reverse_rotation:\n            angle = -angle\n        transforms = []\n        for i in range(repetitions):\n            if i % 2 == 0 or not use_flip:\n                trans_data = Affine2D().rotate(i * angle + rotation_offset)\n            else:\n                trans_data = Affine2D().rotate(-flip_",
        "angle",
        ").scale(1, -1).rotate(i * angle + flip_angle + rotation_offset)\n            transforms.append(trans_data)\n        return transforms"
    ],
    [
        "def rotational_repeat(repetitions: int = None, delta_angle: float = None, rotation_offset=0.0, use_flip=True, flip_angle=0.0, reverse_rotation=False):\n        if repetitions is None and delta_angle is None:\n            repetitions = 1\n            angle = None\n        elif repetitions is None:\n            repetitions = int(np.trunc(2 * np.pi / delta_angle))\n            angle = None\n        elif delta_angle is None:\n            repetitions = np.maximum(1, repetitions)\n            angle = None\n        else:\n            repetitions = np.maximum(1, repetitions)\n            angle = delta_angle\n        if angle is None:\n            angle = 2 * np.pi / repetitions\n        if reverse_rotation:\n            angle = -angle\n        transforms = []\n        for i in range(repetitions):\n            if i % 2 == 0 or not use_flip:\n                trans_data = Affine2D().rotate(i * angle + rotation_offset)\n            else:\n                trans_data = Affine2D().rotate(-flip_angle).scale(1, -1).rotate(i * angle + flip_angle + rotation_offset)\n            transforms.append(trans",
        "_data",
        ")\n        return transforms"
    ],
    [
        "def circular_placement(radius=0.5, repetitions: int = None, delta_angle: float = None, local_rotation_offset=0.0,\n                           global_rotation_offset=0.0, use_flip=False, flip_angle=0.0, reverse_rotation=False):\n        if repetitions is None and delta_angle is None:\n            repetitions = 1\n            angle = None\n        elif repetitions is None:\n            repetitions = np.trunc(2 * np.pi /",
        " delta_angle",
        ")\n            angle = None\n        elif delta_angle is None:\n            repetitions = np.maximum(1, repetitions)\n            angle = None\n        else:\n            repetitions = np.maximum(1, repetitions)\n            angle = delta_angle\n        if angle is None:\n            angle = 2 * np.pi / repetitions\n        if reverse_rotation:\n            angle = -angle\n        transforms = []\n        for i in range(repetitions):\n            if i % 2 == 0 or not use_flip:\n                trans_data = Affine2D().rotate(local_rotation_offset).translate(radius, 0).rotate(i * angle + global_rotation_offset)\n            else:\n                trans_data = Affine2D().rotate(-flip_angle).scale(1, -1).rotate(flip_angle + local_rotation_offset).translate(radius, 0).rotate(i * angle + global_rotation_offset)\n            transforms.append(trans_data)\n        return transforms"
    ],
    [
        "def circular_placement(radius=0.5, repetitions: int = None, delta_angle: float = None, local_rotation_offset=0.0,\n                           global_rotation_offset=0.0, use_flip=False, flip_angle=0.0, reverse_rotation=False):\n        if repetitions is None and delta_angle is None:\n            repetitions = 1\n            angle = None\n        elif repetitions is None:\n            repetitions = np.trunc(2 * np.pi / delta_angle)\n            angle = None\n        elif delta_angle is None:\n            repetitions = np.maximum(1, rep",
        "etitions",
        ")\n            angle = None\n        else:\n            repetitions = np.maximum(1, repetitions)\n            angle = delta_angle\n        if angle is None:\n            angle = 2 * np.pi / repetitions\n        if reverse_rotation:\n            angle = -angle\n        transforms = []\n        for i in range(repetitions):\n            if i % 2 == 0 or not use_flip:\n                trans_data = Affine2D().rotate(local_rotation_offset).translate(radius, 0).rotate(i * angle + global_rotation_offset)\n            else:\n                trans_data = Affine2D().rotate(-flip_angle).scale(1, -1).rotate(flip_angle + local_rotation_offset).translate(radius, 0).rotate(i * angle + global_rotation_offset)\n            transforms.append(trans_data)\n        return transforms"
    ],
    [
        "def circular_placement(radius=0.5, repetitions: int = None, delta_angle: float = None, local_rotation_offset=0.0,\n                           global_rotation_offset=0.0, use_flip=False, flip_angle=0.0, reverse_rotation=False):\n        if repetitions is None and delta_angle is None:\n            repetitions = 1\n            angle = None\n        elif repetitions is None:\n            repetitions = np.trunc(2 * np.pi / delta_angle)\n            angle = None\n        elif delta_angle is None:\n            repetitions = np.maximum(1, repetitions)\n            angle = None\n        else:\n            repetitions = np.maximum(1, rep",
        "etitions",
        ")\n            angle = delta_angle\n        if angle is None:\n            angle = 2 * np.pi / repetitions\n        if reverse_rotation:\n            angle = -angle\n        transforms = []\n        for i in range(repetitions):\n            if i % 2 == 0 or not use_flip:\n                trans_data = Affine2D().rotate(local_rotation_offset).translate(radius, 0).rotate(i * angle + global_rotation_offset)\n            else:\n                trans_data = Affine2D().rotate(-flip_angle).scale(1, -1).rotate(flip_angle + local_rotation_offset).translate(radius, 0).rotate(i * angle + global_rotation_offset)\n            transforms.append(trans_data)\n        return transforms"
    ],
    [
        "def circular_placement(radius=0.5, repetitions: int = None, delta_angle: float = None, local_rotation_offset=0.0,\n                           global_rotation_offset=0.0, use_flip=False, flip_angle=0.0, reverse_rotation=False):\n        if repetitions is None and delta_angle is None:\n            repetitions = 1\n            angle = None\n        elif repetitions is None:\n            repetitions = np.trunc(2 * np.pi / delta_angle)\n            angle = None\n        elif delta_angle is None:\n            repetitions = np.maximum(1, repetitions)\n            angle = None\n        else:\n            repetitions = np.maximum(1, repetitions)\n            angle = delta_angle\n        if angle is None:\n            angle = 2 * np.pi / repetitions\n        if reverse_rotation:\n            angle = -angle\n        transforms = []\n        for i in range(repeti",
        "tions",
        "):\n            if i % 2 == 0 or not use_flip:\n                trans_data = Affine2D().rotate(local_rotation_offset).translate(radius, 0).rotate(i * angle + global_rotation_offset)\n            else:\n                trans_data = Affine2D().rotate(-flip_angle).scale(1, -1).rotate(flip_angle + local_rotation_offset).translate(radius, 0).rotate(i * angle + global_rotation_offset)\n            transforms.append(trans_data)\n        return transforms"
    ],
    [
        "def circular_placement(radius=0.5, repetitions: int = None, delta_angle: float = None, local_rotation_offset=0.0,\n                           global_rotation_offset=0.0, use_flip=False, flip_angle=0.0, reverse_rotation=False):\n        if repetitions is None and delta_angle is None:\n            repetitions = 1\n            angle = None\n        elif repetitions is None:\n            repetitions = np.trunc(2 * np.pi / delta_angle)\n            angle = None\n        elif delta_angle is None:\n            repetitions = np.maximum(1, repetitions)\n            angle = None\n        else:\n            repetitions = np.maximum(1, repetitions)\n            angle = delta_angle\n        if angle is None:\n            angle = 2 * np.pi / repetitions\n        if reverse_rotation:\n            angle = -angle\n        transforms = []\n        for i in range(repetitions):\n            if i % 2 == 0 or not use_flip:\n                trans_data = Affine2D().rotate(local_rotation_offset).translate(radius, 0).rotate(i * ang",
        "le + global_rotation_offset",
        ")\n            else:\n                trans_data = Affine2D().rotate(-flip_angle).scale(1, -1).rotate(flip_angle + local_rotation_offset).translate(radius, 0).rotate(i * angle + global_rotation_offset)\n            transforms.append(trans_data)\n        return transforms"
    ],
    [
        "def circular_placement(radius=0.5, repetitions: int = None, delta_angle: float = None, local_rotation_offset=0.0,\n                           global_rotation_offset=0.0, use_flip=False, flip_angle=0.0, reverse_rotation=False):\n        if repetitions is None and delta_angle is None:\n            repetitions = 1\n            angle = None\n        elif repetitions is None:\n            repetitions = np.trunc(2 * np.pi / delta_angle)\n            angle = None\n        elif delta_angle is None:\n            repetitions = np.maximum(1, repetitions)\n            angle = None\n        else:\n            repetitions = np.maximum(1, repetitions)\n            angle = delta_angle\n        if angle is None:\n            angle = 2 * np.pi / repetitions\n        if reverse_rotation:\n            angle = -angle\n        transforms = []\n        for i in range(repetitions):\n            if i % 2 == 0 or not use_flip:\n                trans_data = Affine2D().rotate(local_ro",
        "tation_offset",
        ").translate(radius, 0).rotate(i * angle + global_rotation_offset)\n            else:\n                trans_data = Affine2D().rotate(-flip_angle).scale(1, -1).rotate(flip_angle + local_rotation_offset).translate(radius, 0).rotate(i * angle + global_rotation_offset)\n            transforms.append(trans_data)\n        return transforms"
    ],
    [
        "def circular_placement(radius=0.5, repetitions: int = None, delta_angle: float = None, local_rotation_offset=0.0,\n                           global_rotation_offset=0.0, use_flip=False, flip_angle=0.0, reverse_rotation=False):\n        if repetitions is None and delta_angle is None:\n            repetitions = 1\n            angle = None\n        elif repetitions is None:\n            repetitions = np.trunc(2 * np.pi / delta_angle)\n            angle = None\n        elif delta_angle is None:\n            repetitions = np.maximum(1, repetitions)\n            angle = None\n        else:\n            repetitions = np.maximum(1, repetitions)\n            angle = delta_angle\n        if angle is None:\n            angle = 2 * np.pi / repetitions\n        if reverse_rotation:\n            angle = -angle\n        transforms = []\n        for i in range(repetitions):\n            if i % 2 == 0 or not use_flip:\n                trans_data = Affine2D().rotate(local_rotation_offset).translate(radius, 0).rotate(i * angle + global_rotation_offset)\n            else:\n                trans_data = Affine2D().rotate(-flip_angle).scale(1, -1).rotate(flip_angle + local_rotation_offset).translate(radius, 0).rotate(i * angle + globa",
        "l_rotation_offset",
        ")\n            transforms.append(trans_data)\n        return transforms"
    ],
    [
        "def circular_placement(radius=0.5, repetitions: int = None, delta_angle: float = None, local_rotation_offset=0.0,\n                           global_rotation_offset=0.0, use_flip=False, flip_angle=0.0, reverse_rotation=False):\n        if repetitions is None and delta_angle is None:\n            repetitions = 1\n            angle = None\n        elif repetitions is None:\n            repetitions = np.trunc(2 * np.pi / delta_angle)\n            angle = None\n        elif delta_angle is None:\n            repetitions = np.maximum(1, repetitions)\n            angle = None\n        else:\n            repetitions = np.maximum(1, repetitions)\n            angle = delta_angle\n        if angle is None:\n            angle = 2 * np.pi / repetitions\n        if reverse_rotation:\n            angle = -angle\n        transforms = []\n        for i in range(repetitions):\n            if i % 2 == 0 or not use_flip:\n                trans_data = Affine2D().rotate(local_rotation_offset).translate(radius, 0).rotate(i * angle + global_rotation_offset)\n            else:\n                trans_data = Affine2D().rotate(-flip_angle).scale(1, -1).rotate(flip_angle + loca",
        "l_rotation_offset",
        ").translate(radius, 0).rotate(i * angle + global_rotation_offset)\n            transforms.append(trans_data)\n        return transforms"
    ],
    [
        "def circular_placement(radius=0.5, repetitions: int = None, delta_angle: float = None, local_rotation_offset=0.0,\n                           global_rotation_offset=0.0, use_flip=False, flip_angle=0.0, reverse_rotation=False):\n        if repetitions is None and delta_angle is None:\n            repetitions = 1\n            angle = None\n        elif repetitions is None:\n            repetitions = np.trunc(2 * np.pi / delta_angle)\n            angle = None\n        elif delta_angle is None:\n            repetitions = np.maximum(1, repetitions)\n            angle = None\n        else:\n            repetitions = np.maximum(1, repetitions)\n            angle = delta_angle\n        if angle is None:\n            angle = 2 * np.pi / repetitions\n        if reverse_rotation:\n            angle = -angle\n        transforms = []\n        for i in range(repetitions):\n            if i % 2 == 0 or not use_flip:\n                trans_data = Affine2D().rotate(local_rotation_offset).translate(radius, 0).rotate(i * angle + global_rotation_offset)\n            else:\n                trans_data = Affine2D().rotate(-flip_",
        "angle",
        ").scale(1, -1).rotate(flip_angle + local_rotation_offset).translate(radius, 0).rotate(i * angle + global_rotation_offset)\n            transforms.append(trans_data)\n        return transforms"
    ],
    [
        "def circular_placement(radius=0.5, repetitions: int = None, delta_angle: float = None, local_rotation_offset=0.0,\n                           global_rotation_offset=0.0, use_flip=False, flip_angle=0.0, reverse_rotation=False):\n        if repetitions is None and delta_angle is None:\n            repetitions = 1\n            angle = None\n        elif repetitions is None:\n            repetitions = np.trunc(2 * np.pi / delta_angle)\n            angle = None\n        elif delta_angle is None:\n            repetitions = np.maximum(1, repetitions)\n            angle = None\n        else:\n            repetitions = np.maximum(1, repetitions)\n            angle = delta_angle\n        if angle is None:\n            angle = 2 * np.pi / repetitions\n        if reverse_rotation:\n            angle = -angle\n        transforms = []\n        for i in range(repetitions):\n            if i % 2 == 0 or not use_flip:\n                trans_data = Affine2D().rotate(local_rotation_offset).translate(radius, 0).rotate(i * angle + global_rotation_offset)\n            else:\n                trans_data = Affine2D().rotate(-flip_angle).scale(1, -1).rotate(flip_angle + local_rotation_offset).translate(radius, 0).rotate(i * angle + global_rotation_offset)\n            transforms.append(trans_",
        "data",
        ")\n        return transforms"
    ],
    [
        "def mirror_persistent(image_sample: ImageSample, mirror_angle=0.0):\n        transform = Affine2D().rotate(-mirror_angle).scale(1, -1).rotate(mirror_",
        "angle",
        ")\n        new_persistent_transforms = []\n        new_persistent_paths = []\n        for i in range(len(image_sample.PersistentTransforms)):\n            new_persistent_transforms.append(image_sample.PersistentTransforms[i] + transform)\n            new_persistent_paths.append(image_sample.PersistentClipPaths[i])\n        image_sample.PersistentClipPaths.extend(new_persistent_paths)\n        image_sample.PersistentTransforms.extend(new_persistent_transforms)"
    ],
    [
        "def mirror_persistent(image_sample: ImageSample, mirror_angle=0.0):\n        transform = Affine2D().rotate(-mirror",
        "_angle",
        ").scale(1, -1).rotate(mirror_angle)\n        new_persistent_transforms = []\n        new_persistent_paths = []\n        for i in range(len(image_sample.PersistentTransforms)):\n            new_persistent_transforms.append(image_sample.PersistentTransforms[i] + transform)\n            new_persistent_paths.append(image_sample.PersistentClipPaths[i])\n        image_sample.PersistentClipPaths.extend(new_persistent_paths)\n        image_sample.PersistentTransforms.extend(new_persistent_transforms)"
    ],
    [
        "def mirror_persistent(image_sample: ImageSample, mirror_angle=0.0):\n        transform = Affine2D().rotate(-mirror_angle).scale(1, -1).rotate(mirror_angle)\n        new_persistent_transforms = []\n        new_persistent_paths = []\n        for i in range(len(image_sample",
        ".PersistentTransforms)",
        "):\n            new_persistent_transforms.append(image_sample.PersistentTransforms[i] + transform)\n            new_persistent_paths.append(image_sample.PersistentClipPaths[i])\n        image_sample.PersistentClipPaths.extend(new_persistent_paths)\n        image_sample.PersistentTransforms.extend(new_persistent_transforms)"
    ],
    [
        "def mirror_persistent(image_sample: ImageSample, mirror_angle=0.0):\n        transform = Affine2D().rotate(-mirror_angle).scale(1, -1).rotate(mirror_angle)\n        new_persistent_transforms = []\n        new_persistent_paths = []\n        for i in range(len(image",
        "_sample.PersistentTransforms",
        ")):\n            new_persistent_transforms.append(image_sample.PersistentTransforms[i] + transform)\n            new_persistent_paths.append(image_sample.PersistentClipPaths[i])\n        image_sample.PersistentClipPaths.extend(new_persistent_paths)\n        image_sample.PersistentTransforms.extend(new_persistent_transforms)"
    ],
    [
        "def mirror_persistent(image_sample: ImageSample, mirror_angle=0.0):\n        transform = Affine2D().rotate(-mirror_angle).scale(1, -1).rotate(mirror_angle)\n        new_persistent_transforms = []\n        new_persistent_paths = []\n        for i in range(len(image_sample.PersistentTransforms)):\n            new_persistent_transforms.append(image_sam",
        "ple.PersistentTransforms[i] + transform",
        ")\n            new_persistent_paths.append(image_sample.PersistentClipPaths[i])\n        image_sample.PersistentClipPaths.extend(new_persistent_paths)\n        image_sample.PersistentTransforms.extend(new_persistent_transforms)"
    ],
    [
        "def mirror_persistent(image_sample: ImageSample, mirror_angle=0.0):\n        transform = Affine2D().rotate(-mirror_angle).scale(1, -1).rotate(mirror_angle)\n        new_persistent_transforms = []\n        new_persistent_paths = []\n        for i in range(len(image_sample.PersistentTransforms)):\n            new_persistent_transforms.append(image_sample.PersistentTransforms[i] + transform)\n            new_persistent_paths.append(image",
        "_sample.PersistentClipPaths[i]",
        ")\n        image_sample.PersistentClipPaths.extend(new_persistent_paths)\n        image_sample.PersistentTransforms.extend(new_persistent_transforms)"
    ],
    [
        "def mirror_persistent(image_sample: ImageSample, mirror_angle=0.0):\n        transform = Affine2D().rotate(-mirror_angle).scale(1, -1).rotate(mirror_angle)\n        new_persistent_transforms = []\n        new_persistent_paths = []\n        for i in range(len(image_sample.PersistentTransforms)):\n            new_persistent_transforms.append(image_sample.PersistentTransforms[i] + transform)\n            new_persistent_paths.append(image_sample.PersistentClipPaths[i])\n        image_sample.PersistentClipPaths.extend(new_per",
        "sistent_paths",
        ")\n        image_sample.PersistentTransforms.extend(new_persistent_transforms)"
    ],
    [
        "def rotational_repeat_additive(image_sample: ImageSample, repetitions: int = None, delta_angle: float = None,\n                                   rotation_offset=0.0, use_flip=True, flip_angle=0.0, reverse_rotation=False):\n        additive_transforms = TransformsGenerator.rotational_repeat(repetitions, delta_angle,",
        " rotation_offset, use_flip, flip_angle, reverse_rotation",
        ")\n        image_sample.AdditiveTransforms = additive_transforms"
    ],
    [
        "def circular_placement_additive(image_sample: ImageSample, radius=0.5, repetitions: int = None, delta_angle: float = None, local_rotation_offset=0.0,\n                                    global_rotation_offset=0.0, use_flip=False, flip_angle=0.0, reverse_rotation=False, calculate_overlap=False):\n        additive_transforms = TransformsGenerator.circular_placement(radius, repetitions, delta_an",
        "gle, local_rotation_offset, global_rotation_offset, use_flip, flip_angle, reverse_rotation",
        ")\n        image_sample.AdditiveTransforms = additive_transforms\n        if calculate_overlap:\n            (new_persistent_paths, new_persistent_transforms, outline_curves) = paths_self_overlap(image_sample.PersistentClipPaths, image_sample.PersistentTransforms,\n                                                                                                   additive_transforms[0], additive_transforms[1])\n            image_sample.PersistentTransforms = new_persistent_transforms\n            image_sample.PersistentClipPaths = new_persistent_paths\n            image_sample.set_custom_outline_curves(outline_curves)"
    ],
    [
        "def circular_placement_additive(image_sample: ImageSample, radius=0.5, repetitions: int = None, delta_angle: float = None, local_rotation_offset=0.0,\n                                    global_rotation_offset=0.0, use_flip=False, flip_angle=0.0, reverse_rotation=False, calculate_overlap=False):\n        additive_transforms = TransformsGenerator.circular_placement(radius, repetitions, delta_angle, local_rotation_offset,\n                                                                     global_rotation_offset, use_flip, flip_angle, reverse_rotation)\n        image_sample.AdditiveTransforms = additive_transforms\n        if calculate_overlap:\n            (new_persistent_paths, new_persistent_transforms, outline_curves) = paths_self_overlap(image_sample.Persisten",
        "tClipPaths, image_sample.PersistentTransforms, additive_transforms[0], additive_transforms[1]",
        ")\n            image_sample.PersistentTransforms = new_persistent_transforms\n            image_sample.PersistentClipPaths = new_persistent_paths\n            image_sample.set_custom_outline_curves(outline_curves)"
    ],
    [
        "def ring(image, dpu=1000.0, segments=8, inner_radius=0.5, outer_radius=0.8, sample_rotation=0.0) -> ImageSample:\n        (image_sliced, extent, path, outline_curves) = ImageSlicer.ring_arc(image, dpu,",
        " inner_radius, outer_radius, sample_rotation, sample_rotation + np.pi / segments",
        ")\n        image_sample = ImageSample(image_sliced, extent, path, outline_curves)\n        ImageSampleTransformer.rotational_repeat_additive(image_sample, 2*segments, None, rotation_offset=-sample_rotation,\n                                                          use_flip=True, flip_angle=(2*sample_rotation+np.pi/segments)/2)\n        return image_sample"
    ],
    [
        "def ring(image, dpu=1000.0, segments=8, inner_radius=0.5, outer_radius=0.8, sample_rotation=0.0) -> ImageSample:\n        (image_sliced, extent, path, outline_curves) = ImageSlicer.ring_arc(image, dpu, inner_radius, outer_radius, sample_rotation, sample_rotation + np.pi / segments)\n        image_sample = ImageSample(image_sliced, e",
        "xtent, path, outline_curves",
        ")\n        ImageSampleTransformer.rotational_repeat_additive(image_sample, 2*segments, None, rotation_offset=-sample_rotation,\n                                                          use_flip=True, flip_angle=(2*sample_rotation+np.pi/segments)/2)\n        return image_sample"
    ],
    [
        "def ring(image, dpu=1000.0, segments=8, inner_radius=0.5, outer_radius=0.8, sample_rotation=0.0) -> ImageSample:\n        (image_sliced, extent, path, outline_curves) = ImageSlicer.ring_arc(image, dpu, inner_radius, outer_radius, sample_rotation, sample_rotation + np.pi / segments)\n        image_sample = ImageSample(image_sliced, extent, path, outline_curves)\n        ImageSampleTransformer.rotational_repeat_additive(image_",
        "sample, 2*segments, None",
        ")\n        return image_sample"
    ],
    [
        "def serrated_ring(image, dpu=1000.0, segments=8, teeth_per_segment=3, aligned=True, teeth_width=0.05, inner_radius=0.5,\n                      outer_radius=0.8, sample_rotation=0.0) -> ImageSample:\n        (image_sliced, extent, path, outline_curves) = ImageSlicer.serrated_ring_arc(image, dpu, teeth_per_segment, aligned, teeth_width",
        ", inner_radius, outer_radius, sample_rotation, sample_rotation + np.pi / segments",
        ")\n        image_sample = ImageSample(image_sliced, extent, path, outline_curves)\n        ImageSampleTransformer.rotational_repeat_additive(image_sample, 2*segments, None, rotation_offset=-sample_rotation,\n                                                          use_flip=True, flip_angle=(2*sample_rotation+np.pi/segments)/2)\n        return image_sample"
    ],
    [
        "def serrated_ring(image, dpu=1000.0, segments=8, teeth_per_segment=3, aligned=True, teeth_width=0.05, inner_radius=0.5,\n                      outer_radius=0.8, sample_rotation=0.0) -> ImageSample:\n        (image_sliced, extent, path, outline_curves) = ImageSlicer.serrated_ring_arc(image, dpu, teeth_per_segment, aligned,\n                                                                                     teeth_width, inner_radius, outer_radius, sample_rotation, sample_rotation + np.pi / segments)\n        image_sample = ImageSample(image_sliced, ",
        "extent, path, outline_curves",
        ")\n        ImageSampleTransformer.rotational_repeat_additive(image_sample, 2*segments, None, rotation_offset=-sample_rotation,\n                                                          use_flip=True, flip_angle=(2*sample_rotation+np.pi/segments)/2)\n        return image_sample"
    ],
    [
        "def serrated_ring(image, dpu=1000.0, segments=8, teeth_per_segment=3, aligned=True, teeth_width=0.05, inner_radius=0.5,\n                      outer_radius=0.8, sample_rotation=0.0) -> ImageSample:\n        (image_sliced, extent, path, outline_curves) = ImageSlicer.serrated_ring_arc(image, dpu, teeth_per_segment, aligned,\n                                                                                     teeth_width, inner_radius, outer_radius, sample_rotation, sample_rotation + np.pi / segments)\n        image_sample = ImageSample(image_sliced, extent, path, outline_curves)\n        ImageSampleTransformer.rotational_repeat_additive(image_sample",
        ", 2*segments, None",
        ")\n        return image_sample"
    ],
    [
        "def sine_wave_ring(image, dpu=1000.0, segments=8, periods_per_segment=3, period_offset=0.25, inner_radius=0.5,\n                       outer_radius=0.8, amplitude=0.1, sample_rotation=0.0) -> ImageSample:\n        (image_sliced, extent, path, outline_curves) = ImageSlicer.sine_wave_ring_arc(image, dp",
        "u, periods_per_segment, period_offset, inner_radius, outer_radius, amplitude, sample_rotation, sample_rotation + np.pi / segments",
        ")\n        image_sample = ImageSample(image_sliced, extent, path, outline_curves)\n        ImageSampleTransformer.rotational_repeat_additive(image_sample, 2 * segments, None, rotation_offset=-sample_rotation, use_flip=True, flip_angle=(2 * sample_rotation + np.pi / segments) / 2)\n        return image_sample"
    ],
    [
        "def sine_wave_ring(image, dpu=1000.0, segments=8, periods_per_segment=3, period_offset=0.25, inner_radius=0.5,\n                       outer_radius=0.8, amplitude=0.1, sample_rotation=0.0) -> ImageSample:\n        (image_sliced, extent, path, outline_curves) = ImageSlicer.sine_wave_ring_arc(image, dpu, periods_per_segment,\n                                                                                      period_offset, inner_radius, outer_radius, amplitude, sample_rotation, sample_rotation + np.pi / segments)\n        image_sample = ImageSample(image_slic",
        "ed, extent, path, outline_curves",
        ")\n        ImageSampleTransformer.rotational_repeat_additive(image_sample, 2 * segments, None, rotation_offset=-sample_rotation, use_flip=True, flip_angle=(2 * sample_rotation + np.pi / segments) / 2)\n        return image_sample"
    ],
    [
        "def sine_wave_ring(image, dpu=1000.0, segments=8, periods_per_segment=3, period_offset=0.25, inner_radius=0.5,\n                       outer_radius=0.8, amplitude=0.1, sample_rotation=0.0) -> ImageSample:\n        (image_sliced, extent, path, outline_curves) = ImageSlicer.sine_wave_ring_arc(image, dpu, periods_per_segment,\n                                                                                      period_offset, inner_radius, outer_radius, amplitude, sample_rotation, sample_rotation + np.pi / segments)\n        image_sample = ImageSample(image_sliced, extent, path, outline_curves)\n        ImageSampleTransformer.rotational_repeat_additive(image_sample",
        ", 2 * segments, None",
        ")\n        return image_sample"
    ],
    [
        "def test_ring(image, dpu=1000.0, segments=8, inner_radius=0.5, outer_radius=0.8, width=0.05, sample_rotation=0.0) -> ImageSample:\n        inner_curve = (CurveGenerator.bezier(np.array([[0, 0",
        "], [0, 1], [1, 1], [1, 2]])",
        "), 1, inner_radius, width, \"cartesian\")\n        outer_curve = (CurveGenerator.bezier(np.array([[0, 0], [0, 1], [1, 1], [1, 2]])), 1, outer_radius, width, \"cartesian\")\n        (image_sliced, extent, path, outline_curves) = ImageSlicer.custom_ring_arc(image, dpu, inner_curve, outer_curve, sample_rotation,\n                                                                                   sample_rotation + np.pi / segments, True)\n        image_sample = ImageSample(image_sliced, extent, path, outline_curves)\n        ImageSampleTransformer.rotational_repeat_additive(image_sample, 2 * segments, None,\n                                                          rotation_offset=-sample_rotation, use_flip=True,\n                                                          flip_angle=(2 * sample_rotation + np.pi / segments) / 2)\n        return image_sample"
    ],
    [
        "def test_ring(image, dpu=1000.0, segments=8, inner_radius=0.5, outer_radius=0.8, width=0.05, sample_rotation=0.0) -> ImageSample:\n        inner_curve = (CurveGenerator.bezier(np.array([[0, 0], [0, 1],",
        " [1, 1], [1, 2]]",
        ")), 1, inner_radius, width, \"cartesian\")\n        outer_curve = (CurveGenerator.bezier(np.array([[0, 0], [0, 1], [1, 1], [1, 2]])), 1, outer_radius, width, \"cartesian\")\n        (image_sliced, extent, path, outline_curves) = ImageSlicer.custom_ring_arc(image, dpu, inner_curve, outer_curve, sample_rotation,\n                                                                                   sample_rotation + np.pi / segments, True)\n        image_sample = ImageSample(image_sliced, extent, path, outline_curves)\n        ImageSampleTransformer.rotational_repeat_additive(image_sample, 2 * segments, None,\n                                                          rotation_offset=-sample_rotation, use_flip=True,\n                                                          flip_angle=(2 * sample_rotation + np.pi / segments) / 2)\n        return image_sample"
    ],
    [
        "def test_ring(image, dpu=1000.0, segments=8, inner_radius=0.5, outer_radius=0.8, width=0.05, sample_rotation=0.0) -> ImageSample:\n        inner_curve = (CurveGenerator.bezier(np.array([[0, 0], [0, 1], [1, 1], [1, 2]])), 1, inner_radius, width, \"cartesian\")\n        outer_curve = (CurveGenerator.bezier(np.array([[0, 0]",
        ", [0, 1], [1, 1], [1, 2]])",
        "), 1, outer_radius, width, \"cartesian\")\n        (image_sliced, extent, path, outline_curves) = ImageSlicer.custom_ring_arc(image, dpu, inner_curve, outer_curve, sample_rotation,\n                                                                                   sample_rotation + np.pi / segments, True)\n        image_sample = ImageSample(image_sliced, extent, path, outline_curves)\n        ImageSampleTransformer.rotational_repeat_additive(image_sample, 2 * segments, None,\n                                                          rotation_offset=-sample_rotation, use_flip=True,\n                                                          flip_angle=(2 * sample_rotation + np.pi / segments) / 2)\n        return image_sample"
    ],
    [
        "def test_ring(image, dpu=1000.0, segments=8, inner_radius=0.5, outer_radius=0.8, width=0.05, sample_rotation=0.0) -> ImageSample:\n        inner_curve = (CurveGenerator.bezier(np.array([[0, 0], [0, 1], [1, 1], [1, 2]])), 1, inner_radius, width, \"cartesian\")\n        outer_curve = (CurveGenerator.bezier(np.array([[0, 0], [",
        "0, 1], [1, 1], [1, 2]]",
        ")), 1, outer_radius, width, \"cartesian\")\n        (image_sliced, extent, path, outline_curves) = ImageSlicer.custom_ring_arc(image, dpu, inner_curve, outer_curve, sample_rotation,\n                                                                                   sample_rotation + np.pi / segments, True)\n        image_sample = ImageSample(image_sliced, extent, path, outline_curves)\n        ImageSampleTransformer.rotational_repeat_additive(image_sample, 2 * segments, None,\n                                                          rotation_offset=-sample_rotation, use_flip=True,\n                                                          flip_angle=(2 * sample_rotation + np.pi / segments) / 2)\n        return image_sample"
    ],
    [
        "def test_ring(image, dpu=1000.0, segments=8, inner_radius=0.5, outer_radius=0.8, width=0.05, sample_rotation=0.0) -> ImageSample:\n        inner_curve = (CurveGenerator.bezier(np.array([[0, 0], [0, 1], [1, 1], [1, 2]])), 1, inner_radius, width, \"cartesian\")\n        outer_curve = (CurveGenerator.bezier(np.array([[0, 0], [0, 1], [1, 1], [1, 2]])), 1, outer_radius, width, \"cartesian\")\n        (image_sliced, extent, path, outline_curves) = ImageSlicer.custom_ring_arc(image, dpu, inner_curve, outer_curve, s",
        "ample_rotation, sample_rotation + np.pi / segments, True",
        ")\n        image_sample = ImageSample(image_sliced, extent, path, outline_curves)\n        ImageSampleTransformer.rotational_repeat_additive(image_sample, 2 * segments, None,\n                                                          rotation_offset=-sample_rotation, use_flip=True,\n                                                          flip_angle=(2 * sample_rotation + np.pi / segments) / 2)\n        return image_sample"
    ],
    [
        "def test_ring(image, dpu=1000.0, segments=8, inner_radius=0.5, outer_radius=0.8, width=0.05, sample_rotation=0.0) -> ImageSample:\n        inner_curve = (CurveGenerator.bezier(np.array([[0, 0], [0, 1], [1, 1], [1, 2]])), 1, inner_radius, width, \"cartesian\")\n        outer_curve = (CurveGenerator.bezier(np.array([[0, 0], [0, 1], [1, 1], [1, 2]])), 1, outer_radius, width, \"cartesian\")\n        (image_sliced, extent, path, outline_curves) = ImageSlicer.custom_ring_arc(image, dpu, inner_curve, outer_curve, sample_rotation,\n                                                                                   sample_rotation + np.pi / segments, True)\n        image_sample = ImageSample(image_sliced,",
        " extent, path, outline_curves",
        ")\n        ImageSampleTransformer.rotational_repeat_additive(image_sample, 2 * segments, None,\n                                                          rotation_offset=-sample_rotation, use_flip=True,\n                                                          flip_angle=(2 * sample_rotation + np.pi / segments) / 2)\n        return image_sample"
    ],
    [
        "def test_ring(image, dpu=1000.0, segments=8, inner_radius=0.5, outer_radius=0.8, width=0.05, sample_rotation=0.0) -> ImageSample:\n        inner_curve = (CurveGenerator.bezier(np.array([[0, 0], [0, 1], [1, 1], [1, 2]])), 1, inner_radius, width, \"cartesian\")\n        outer_curve = (CurveGenerator.bezier(np.array([[0, 0], [0, 1], [1, 1], [1, 2]])), 1, outer_radius, width, \"cartesian\")\n        (image_sliced, extent, path, outline_curves) = ImageSlicer.custom_ring_arc(image, dpu, inner_curve, outer_curve, sample_rotation,\n                                                                                   sample_rotation + np.pi / segments, True)\n        image_sample = ImageSample(image_sliced, extent, path, outline_curves)\n        ImageSampleTransformer.rotational_repeat_additive(image_sample,",
        " 2 * segments, None",
        ")\n        return image_sample"
    ],
    [
        "def pit_ring(image, dpu=1000.0, segments=8, pits_per_segment=1, inner_radius=0.5, outer_radius=0.8, width=0.8, depth=0.4, gap=0.2, sample_rotation=0.0,\n                   global_rotation=0.0, half=False, left_edge=False, right_edge=False) -> ImageSample:\n        outer_curve = (CurveGenerator.pit(100, width, g",
        "ap, pits_per_segment",
        "), 1, outer_radius, depth, \"cartesian\")\n        inner_curve = (CurveTransforms.scale_single(CurveGenerator.pit(100, width, gap, pits_per_segment), (1, -1)), 1, inner_radius, depth, \"cartesian\")\n        (image_sliced, extent, path, outline_curves) = ImageSlicer.custom_ring_arc(image, dpu, inner_curve, outer_curve, sample_rotation,\n                                                                                   sample_rotation + np.pi / segments, left_edge, right_edge)\n        image_sample = ImageSample(image_sliced, extent, path, outline_curves)\n        ImageSampleTransformer.rotational_repeat_additive(image_sample, 2 * segments, None,\n                                                          rotation_offset=-sample_rotation+global_rotation, use_flip=True,\n                                                          flip_angle=(2 * sample_rotation + np.pi / segments) / 2)\n        return image_sample"
    ],
    [
        "def pit_ring(image, dpu=1000.0, segments=8, pits_per_segment=1, inner_radius=0.5, outer_radius=0.8, width=0.8, depth=0.4, gap=0.2, sample_rotation=0.0,\n                   global_rotation=0.0, half=False, left_edge=False, right_edge=False) -> ImageSample:\n        outer_curve = (CurveGenerator.pit(100, width, gap, pits_per_segment), 1, outer_radius, depth, \"cartesian\")\n        inner_curve = (CurveTransforms.scale_single(CurveGenerator.pit(100",
        ", width, gap, pits_per_segment), (1, -1)",
        "), 1, inner_radius, depth, \"cartesian\")\n        (image_sliced, extent, path, outline_curves) = ImageSlicer.custom_ring_arc(image, dpu, inner_curve, outer_curve, sample_rotation,\n                                                                                   sample_rotation + np.pi / segments, left_edge, right_edge)\n        image_sample = ImageSample(image_sliced, extent, path, outline_curves)\n        ImageSampleTransformer.rotational_repeat_additive(image_sample, 2 * segments, None,\n                                                          rotation_offset=-sample_rotation+global_rotation, use_flip=True,\n                                                          flip_angle=(2 * sample_rotation + np.pi / segments) / 2)\n        return image_sample"
    ],
    [
        "def pit_ring(image, dpu=1000.0, segments=8, pits_per_segment=1, inner_radius=0.5, outer_radius=0.8, width=0.8, depth=0.4, gap=0.2, sample_rotation=0.0,\n                   global_rotation=0.0, half=False, left_edge=False, right_edge=False) -> ImageSample:\n        outer_curve = (CurveGenerator.pit(100, width, gap, pits_per_segment), 1, outer_radius, depth, \"cartesian\")\n        inner_curve = (CurveTransforms.scale_single(CurveGenerator.pit(100, width",
        ", gap, pits_per_segment",
        "), (1, -1)), 1, inner_radius, depth, \"cartesian\")\n        (image_sliced, extent, path, outline_curves) = ImageSlicer.custom_ring_arc(image, dpu, inner_curve, outer_curve, sample_rotation,\n                                                                                   sample_rotation + np.pi / segments, left_edge, right_edge)\n        image_sample = ImageSample(image_sliced, extent, path, outline_curves)\n        ImageSampleTransformer.rotational_repeat_additive(image_sample, 2 * segments, None,\n                                                          rotation_offset=-sample_rotation+global_rotation, use_flip=True,\n                                                          flip_angle=(2 * sample_rotation + np.pi / segments) / 2)\n        return image_sample"
    ],
    [
        "def pit_ring(image, dpu=1000.0, segments=8, pits_per_segment=1, inner_radius=0.5, outer_radius=0.8, width=0.8, depth=0.4, gap=0.2, sample_rotation=0.0,\n                   global_rotation=0.0, half=False, left_edge=False, right_edge=False) -> ImageSample:\n        outer_curve = (CurveGenerator.pit(100, width, gap, pits_per_segment), 1, outer_radius, depth, \"cartesian\")\n        inner_curve = (CurveTransforms.scale_single(CurveGenerator.pit(100, width, gap, pits_per_segment), (1, -1)), 1, inner_radius, depth, \"cartesian\")\n        (image_sliced, extent, path, outline_curves) = ImageSlicer.custom_ring_arc(image, d",
        "pu, inner_curve, outer_curve, sample_rotation, sample_rotation + np.pi / segments, left_edge, right_edge",
        ")\n        image_sample = ImageSample(image_sliced, extent, path, outline_curves)\n        ImageSampleTransformer.rotational_repeat_additive(image_sample, 2 * segments, None,\n                                                          rotation_offset=-sample_rotation+global_rotation, use_flip=True,\n                                                          flip_angle=(2 * sample_rotation + np.pi / segments) / 2)\n        return image_sample"
    ],
    [
        "def pit_ring(image, dpu=1000.0, segments=8, pits_per_segment=1, inner_radius=0.5, outer_radius=0.8, width=0.8, depth=0.4, gap=0.2, sample_rotation=0.0,\n                   global_rotation=0.0, half=False, left_edge=False, right_edge=False) -> ImageSample:\n        outer_curve = (CurveGenerator.pit(100, width, gap, pits_per_segment), 1, outer_radius, depth, \"cartesian\")\n        inner_curve = (CurveTransforms.scale_single(CurveGenerator.pit(100, width, gap, pits_per_segment), (1, -1)), 1, inner_radius, depth, \"cartesian\")\n        (image_sliced, extent, path, outline_curves) = ImageSlicer.custom_ring_arc(image, dpu, inner_curve, outer_curve, sample_rotation,\n                                                                                   sample_rotation + np.pi / segments, left_edge, right_edge)\n        image_sample = ImageSample(image_slice",
        "d, extent, path, outline_curves",
        ")\n        ImageSampleTransformer.rotational_repeat_additive(image_sample, 2 * segments, None,\n                                                          rotation_offset=-sample_rotation+global_rotation, use_flip=True,\n                                                          flip_angle=(2 * sample_rotation + np.pi / segments) / 2)\n        return image_sample"
    ],
    [
        "def pit_ring(image, dpu=1000.0, segments=8, pits_per_segment=1, inner_radius=0.5, outer_radius=0.8, width=0.8, depth=0.4, gap=0.2, sample_rotation=0.0,\n                   global_rotation=0.0, half=False, left_edge=False, right_edge=False) -> ImageSample:\n        outer_curve = (CurveGenerator.pit(100, width, gap, pits_per_segment), 1, outer_radius, depth, \"cartesian\")\n        inner_curve = (CurveTransforms.scale_single(CurveGenerator.pit(100, width, gap, pits_per_segment), (1, -1)), 1, inner_radius, depth, \"cartesian\")\n        (image_sliced, extent, path, outline_curves) = ImageSlicer.custom_ring_arc(image, dpu, inner_curve, outer_curve, sample_rotation,\n                                                                                   sample_rotation + np.pi / segments, left_edge, right_edge)\n        image_sample = ImageSample(image_sliced, extent, path, outline_curves)\n        ImageSampleTransformer.rotational_repeat_additive(image_sample, 2 *",
        " segments, None",
        ")\n        return image_sample"
    ],
    [
        "def ring_type1(image, dpu=1000.0, segments=8, inner_radius=0.5, outer_radius=0.8, edge_width=0.05, sample_rotation=0.0,\n                   global_rotation=0.0, half=False, left_edge=False, right_edge=False) -> ImageSample:\n        inner_curve = (CurveGenerator.edge_type1(half=half), 1, inner_radius, edge_width, \"cartesian\")\n        outer_curve = (CurveGenerator.edge_type1(half=half), 1, outer_radius, edge_width, \"cartesian\")\n        (image_sliced, extent, path, outline_curves) = ImageSlicer.custom_ring_arc(image, dpu, inner_curve, out",
        "er_curve, sample_rotation, sample_rotation + np.pi / segments, left_edge, right_edge",
        ")\n        image_sample = ImageSample(image_sliced, extent, path, outline_curves)\n        ImageSampleTransformer.rotational_repeat_additive(image_sample, 2 * segments, None,\n                                                          rotation_offset=-sample_rotation+global_rotation, use_flip=True,\n                                                          flip_angle=(2 * sample_rotation + np.pi / segments) / 2)\n        return image_sample"
    ],
    [
        "def ring_type1(image, dpu=1000.0, segments=8, inner_radius=0.5, outer_radius=0.8, edge_width=0.05, sample_rotation=0.0,\n                   global_rotation=0.0, half=False, left_edge=False, right_edge=False) -> ImageSample:\n        inner_curve = (CurveGenerator.edge_type1(half=half), 1, inner_radius, edge_width, \"cartesian\")\n        outer_curve = (CurveGenerator.edge_type1(half=half), 1, outer_radius, edge_width, \"cartesian\")\n        (image_sliced, extent, path, outline_curves) = ImageSlicer.custom_ring_arc(image, dpu, inner_curve, outer_curve, sample_rotation,\n                                                                                   sample_rotation + np.pi / segments, left_edge, right_edge)\n        image_sample = ImageSample(image_sliced, exte",
        "nt, path, outline_curves",
        ")\n        ImageSampleTransformer.rotational_repeat_additive(image_sample, 2 * segments, None,\n                                                          rotation_offset=-sample_rotation+global_rotation, use_flip=True,\n                                                          flip_angle=(2 * sample_rotation + np.pi / segments) / 2)\n        return image_sample"
    ],
    [
        "def ring_type1(image, dpu=1000.0, segments=8, inner_radius=0.5, outer_radius=0.8, edge_width=0.05, sample_rotation=0.0,\n                   global_rotation=0.0, half=False, left_edge=False, right_edge=False) -> ImageSample:\n        inner_curve = (CurveGenerator.edge_type1(half=half), 1, inner_radius, edge_width, \"cartesian\")\n        outer_curve = (CurveGenerator.edge_type1(half=half), 1, outer_radius, edge_width, \"cartesian\")\n        (image_sliced, extent, path, outline_curves) = ImageSlicer.custom_ring_arc(image, dpu, inner_curve, outer_curve, sample_rotation,\n                                                                                   sample_rotation + np.pi / segments, left_edge, right_edge)\n        image_sample = ImageSample(image_sliced, extent, path, outline_curves)\n        ImageSampleTransformer.rotational_repeat_additive(image_samp",
        "le, 2 * segments, None",
        ")\n        return image_sample"
    ],
    [
        "def leaf_circle(image, dpu=1000.0, repetitions=50, radius=0.7, leaf_width=0.1, leaf_height=0.2, leaf_rotation=np.pi/6):\n        circle = CurveGenerator.regular_polygon(1000, ",
        "radius",
        ")\n        (image_sliced, extent, path, outline_curves) = ImageSlicer.leaf(image, dpu, leaf_width, leaf_height, False)\n        image_sample = ImageSample(image_sliced, extent, path, outline_curves)\n        image_sample.add_additional_curve(circle)\n        ImageSampleTransformer.circular_placement_additive(image_sample, radius, repetitions, None, leaf_rotation, 0, True, np.pi/2-leaf_rotation, True, False)\n        return image_sample"
    ],
    [
        "def leaf_circle(image, dpu=1000.0, repetitions=50, radius=0.7, leaf_width=0.1, leaf_height=0.2, leaf_rotation=np.pi/6):\n        circle = CurveGenerator.regular_polygon(1000, radius)\n        (image_sliced, extent, path, outline_curves) = ImageSlicer.leaf(image, dp",
        "u, leaf_width, leaf_height, False",
        ")\n        image_sample = ImageSample(image_sliced, extent, path, outline_curves)\n        image_sample.add_additional_curve(circle)\n        ImageSampleTransformer.circular_placement_additive(image_sample, radius, repetitions, None, leaf_rotation, 0, True, np.pi/2-leaf_rotation, True, False)\n        return image_sample"
    ],
    [
        "def leaf_circle(image, dpu=1000.0, repetitions=50, radius=0.7, leaf_width=0.1, leaf_height=0.2, leaf_rotation=np.pi/6):\n        circle = CurveGenerator.regular_polygon(1000, radius)\n        (image_sliced, extent, path, outline_curves) = ImageSlicer.leaf(image, dpu, leaf_width, leaf_height, False)\n        image_sample = ImageSample(image_sliced,",
        " extent, path, outline_curves",
        ")\n        image_sample.add_additional_curve(circle)\n        ImageSampleTransformer.circular_placement_additive(image_sample, radius, repetitions, None, leaf_rotation, 0, True, np.pi/2-leaf_rotation, True, False)\n        return image_sample"
    ],
    [
        "def leaf_circle(image, dpu=1000.0, repetitions=50, radius=0.7, leaf_width=0.1, leaf_height=0.2, leaf_rotation=np.pi/6):\n        circle = CurveGenerator.regular_polygon(1000, radius)\n        (image_sliced, extent, path, outline_curves) = ImageSlicer.leaf(image, dpu, leaf_width, leaf_height, False)\n        image_sample = ImageSample(image_sliced, extent, path, outline_curves)\n        image_sample.add_additional_curve(circle)\n        ImageSampleTransformer.circular_placement_additive(image_sample, ",
        "radius, repetitions, None, leaf_rotation, 0, True, np.pi/2-leaf_rotation, True, False",
        ")\n        return image_sample"
    ],
    [
        "def leaf_center(image, dpu=1000.0, segments=8, radius=0.4, height=0.2, sample_rotation=0.0, global_rotation=0.0, left_edge=True, right_edge=False, leaf_type=\"sharp\"):\n        if leaf_type == \"sharp\":\n            leaf = CurveGenerator.bezier(np.array([[-1, 0], [-",
        "1, 1], [0, 1], [0, 2]])",
        ")\n        else:\n            leaf = CurveGenerator.bezier(np.array([[-1, 0], [-1, 1], [0, 2]]))\n        (image_sliced, extent, path, outline_curves) = ImageSlicer.custom_ring_arc(image, dpu, None, (leaf, 1, radius, height, \"cartesian\"),\n                                                                                    sample_rotation, sample_rotation+np.pi/segments, left_edge, right_edge)\n        image_sample = ImageSample(image_sliced, extent, path, outline_curves)\n        ImageSampleTransformer.rotational_repeat_additive(image_sample, 2 * segments, None,\n                                                          rotation_offset=-sample_rotation + global_rotation, use_flip=True,\n                                                          flip_angle=(2 * sample_rotation + np.pi / segments) / 2)\n        return image_sample"
    ],
    [
        "def leaf_center(image, dpu=1000.0, segments=8, radius=0.4, height=0.2, sample_rotation=0.0, global_rotation=0.0, left_edge=True, right_edge=False, leaf_type=\"sharp\"):\n        if leaf_type == \"sharp\":\n            leaf = CurveGenerator.bezier(np.array([[-1, 0], ",
        "[-1, 1], [0, 1], [0, 2]]",
        "))\n        else:\n            leaf = CurveGenerator.bezier(np.array([[-1, 0], [-1, 1], [0, 2]]))\n        (image_sliced, extent, path, outline_curves) = ImageSlicer.custom_ring_arc(image, dpu, None, (leaf, 1, radius, height, \"cartesian\"),\n                                                                                    sample_rotation, sample_rotation+np.pi/segments, left_edge, right_edge)\n        image_sample = ImageSample(image_sliced, extent, path, outline_curves)\n        ImageSampleTransformer.rotational_repeat_additive(image_sample, 2 * segments, None,\n                                                          rotation_offset=-sample_rotation + global_rotation, use_flip=True,\n                                                          flip_angle=(2 * sample_rotation + np.pi / segments) / 2)\n        return image_sample"
    ],
    [
        "def leaf_center(image, dpu=1000.0, segments=8, radius=0.4, height=0.2, sample_rotation=0.0, global_rotation=0.0, left_edge=True, right_edge=False, leaf_type=\"sharp\"):\n        if leaf_type == \"sharp\":\n            leaf = CurveGenerator.bezier(np.array([[-1, 0], [-1, 1], [0, 1], [0, 2]]))\n        else:\n            leaf = CurveGenerator.bezier(np.array([[-1,",
        " 0], [-1, 1], [0, 2]])",
        ")\n        (image_sliced, extent, path, outline_curves) = ImageSlicer.custom_ring_arc(image, dpu, None, (leaf, 1, radius, height, \"cartesian\"),\n                                                                                    sample_rotation, sample_rotation+np.pi/segments, left_edge, right_edge)\n        image_sample = ImageSample(image_sliced, extent, path, outline_curves)\n        ImageSampleTransformer.rotational_repeat_additive(image_sample, 2 * segments, None,\n                                                          rotation_offset=-sample_rotation + global_rotation, use_flip=True,\n                                                          flip_angle=(2 * sample_rotation + np.pi / segments) / 2)\n        return image_sample"
    ],
    [
        "def leaf_center(image, dpu=1000.0, segments=8, radius=0.4, height=0.2, sample_rotation=0.0, global_rotation=0.0, left_edge=True, right_edge=False, leaf_type=\"sharp\"):\n        if leaf_type == \"sharp\":\n            leaf = CurveGenerator.bezier(np.array([[-1, 0], [-1, 1], [0, 1], [0, 2]]))\n        else:\n            leaf = CurveGenerator.bezier(np.array([[-1, 0], ",
        "[-1, 1], [0, 2]]",
        "))\n        (image_sliced, extent, path, outline_curves) = ImageSlicer.custom_ring_arc(image, dpu, None, (leaf, 1, radius, height, \"cartesian\"),\n                                                                                    sample_rotation, sample_rotation+np.pi/segments, left_edge, right_edge)\n        image_sample = ImageSample(image_sliced, extent, path, outline_curves)\n        ImageSampleTransformer.rotational_repeat_additive(image_sample, 2 * segments, None,\n                                                          rotation_offset=-sample_rotation + global_rotation, use_flip=True,\n                                                          flip_angle=(2 * sample_rotation + np.pi / segments) / 2)\n        return image_sample"
    ],
    [
        "def leaf_center(image, dpu=1000.0, segments=8, radius=0.4, height=0.2, sample_rotation=0.0, global_rotation=0.0, left_edge=True, right_edge=False, leaf_type=\"sharp\"):\n        if leaf_type == \"sharp\":\n            leaf = CurveGenerator.bezier(np.array([[-1, 0], [-1, 1], [0, 1], [0, 2]]))\n        else:\n            leaf = CurveGenerator.bezier(np.array([[-1, 0], [-1, 1], [0, 2]]))\n        (image_sliced, extent, path, outline_curves) = ImageSlicer.custom_ring_arc(image, dpu, None, (leaf,",
        " 1, radius, height, \"cartesian\"), sample_rotation, sample_rotation+np.pi/segments, left_edge, right_edge",
        ")\n        image_sample = ImageSample(image_sliced, extent, path, outline_curves)\n        ImageSampleTransformer.rotational_repeat_additive(image_sample, 2 * segments, None,\n                                                          rotation_offset=-sample_rotation + global_rotation, use_flip=True,\n                                                          flip_angle=(2 * sample_rotation + np.pi / segments) / 2)\n        return image_sample"
    ],
    [
        "def leaf_center(image, dpu=1000.0, segments=8, radius=0.4, height=0.2, sample_rotation=0.0, global_rotation=0.0, left_edge=True, right_edge=False, leaf_type=\"sharp\"):\n        if leaf_type == \"sharp\":\n            leaf = CurveGenerator.bezier(np.array([[-1, 0], [-1, 1], [0, 1], [0, 2]]))\n        else:\n            leaf = CurveGenerator.bezier(np.array([[-1, 0], [-1, 1], [0, 2]]))\n        (image_sliced, extent, path, outline_curves) = ImageSlicer.custom_ring_arc(image, dpu, None, (leaf, 1, radius, height, \"cartesian\"),\n                                                                                    sample_rotation, sample_rotation+np.pi/segments, left_edge, right_edge)\n        image_sample = ImageSample(image_sliced, e",
        "xtent, path, outline_curves",
        ")\n        ImageSampleTransformer.rotational_repeat_additive(image_sample, 2 * segments, None,\n                                                          rotation_offset=-sample_rotation + global_rotation, use_flip=True,\n                                                          flip_angle=(2 * sample_rotation + np.pi / segments) / 2)\n        return image_sample"
    ],
    [
        "def leaf_center(image, dpu=1000.0, segments=8, radius=0.4, height=0.2, sample_rotation=0.0, global_rotation=0.0, left_edge=True, right_edge=False, leaf_type=\"sharp\"):\n        if leaf_type == \"sharp\":\n            leaf = CurveGenerator.bezier(np.array([[-1, 0], [-1, 1], [0, 1], [0, 2]]))\n        else:\n            leaf = CurveGenerator.bezier(np.array([[-1, 0], [-1, 1], [0, 2]]))\n        (image_sliced, extent, path, outline_curves) = ImageSlicer.custom_ring_arc(image, dpu, None, (leaf, 1, radius, height, \"cartesian\"),\n                                                                                    sample_rotation, sample_rotation+np.pi/segments, left_edge, right_edge)\n        image_sample = ImageSample(image_sliced, extent, path, outline_curves)\n        ImageSampleTransformer.rotational_repeat_additive(image_sample,",
        " 2 * segments, None",
        ")\n        return image_sample"
    ],
    [
        "def random_edge_ring(image, dpu=1000.0, segments=8, grid_size=(5, 3), inner_radius=0.5, outer_radius=0.8, width=0.1,\n                         sample_rotation=0.0, global_rotation=0.0, left_edge=False, right_edge=False, interpolation=\"spline\"):\n        (image_sliced, extent, path, outline_curves) = ImageSlicer.random_ring_arc(image, dpu, grid_size, (1, 1), inner_radius, outer_rad",
        "ius, width, sample_rotation, sample_rotation+np.pi/segments, left_edge, right_edge, interpolation",
        ")\n        image_sample = ImageSample(image_sliced, extent, path, outline_curves)\n        ImageSampleTransformer.rotational_repeat_additive(image_sample, 2 * segments, None,\n                                                          rotation_offset=-sample_rotation+global_rotation, use_flip=True,\n                                                          flip_angle=(2 * sample_rotation + np.pi / segments) / 2)\n        return image_sample"
    ],
    [
        "def random_edge_ring(image, dpu=1000.0, segments=8, grid_size=(5, 3), inner_radius=0.5, outer_radius=0.8, width=0.1,\n                         sample_rotation=0.0, global_rotation=0.0, left_edge=False, right_edge=False, interpolation=\"spline\"):\n        (image_sliced, extent, path, outline_curves) = ImageSlicer.random_ring_arc(image, dpu, grid_size, (1, 1), inner_radius, outer_radius, width,\n                                                                                   sample_rotation, sample_rotation+np.pi/segments, left_edge, right_edge, interpolation)\n        image_sample = ImageSample(image_sliced, extent",
        ", path, outline_curves",
        ")\n        ImageSampleTransformer.rotational_repeat_additive(image_sample, 2 * segments, None,\n                                                          rotation_offset=-sample_rotation+global_rotation, use_flip=True,\n                                                          flip_angle=(2 * sample_rotation + np.pi / segments) / 2)\n        return image_sample"
    ],
    [
        "def random_edge_ring(image, dpu=1000.0, segments=8, grid_size=(5, 3), inner_radius=0.5, outer_radius=0.8, width=0.1,\n                         sample_rotation=0.0, global_rotation=0.0, left_edge=False, right_edge=False, interpolation=\"spline\"):\n        (image_sliced, extent, path, outline_curves) = ImageSlicer.random_ring_arc(image, dpu, grid_size, (1, 1), inner_radius, outer_radius, width,\n                                                                                   sample_rotation, sample_rotation+np.pi/segments, left_edge, right_edge, interpolation)\n        image_sample = ImageSample(image_sliced, extent, path, outline_curves)\n        ImageSampleTransformer.rotational_repeat_additive(image_sample, 2 ",
        "* segments, None",
        ")\n        return image_sample"
    ],
    [
        "def regular_polygon_ring(image, dpu=1000.0, segments=8, sides_per_segment=1, inner_radius=0.5, outer_radius=0.8, sample_rotation=0.0, global_rotation=0.0, left_edge=False, right_edge=False):\n        (image_sliced, extent, path, outline_curves) = ImageSlicer.regular_polygon_ring_arc(image, dpu, sid",
        "es_per_segment, inner_radius, outer_radius, sample_rotation, sample_rotation+np.pi/segments, left_edge, right_edge",
        ")\n        image_sample = ImageSample(image_sliced, extent, path, outline_curves)\n        ImageSampleTransformer.rotational_repeat_additive(image_sample, 2 * segments, None,\n                                                          rotation_offset=-sample_rotation + global_rotation,\n                                                          use_flip=True,\n                                                          flip_angle=(2 * sample_rotation + np.pi / segments) / 2)\n        return image_sample"
    ],
    [
        "def regular_polygon_ring(image, dpu=1000.0, segments=8, sides_per_segment=1, inner_radius=0.5, outer_radius=0.8, sample_rotation=0.0, global_rotation=0.0, left_edge=False, right_edge=False):\n        (image_sliced, extent, path, outline_curves) = ImageSlicer.regular_polygon_ring_arc(image, dpu, sides_per_segment, inner_radius, outer_radius,\n                                                                                            sample_rotation, sample_rotation+np.pi/segments, left_edge, right_edge)\n        image_sample = ImageSample(image_sliced, exte",
        "nt, path, outline_curves",
        ")\n        ImageSampleTransformer.rotational_repeat_additive(image_sample, 2 * segments, None,\n                                                          rotation_offset=-sample_rotation + global_rotation,\n                                                          use_flip=True,\n                                                          flip_angle=(2 * sample_rotation + np.pi / segments) / 2)\n        return image_sample"
    ],
    [
        "def regular_polygon_ring(image, dpu=1000.0, segments=8, sides_per_segment=1, inner_radius=0.5, outer_radius=0.8, sample_rotation=0.0, global_rotation=0.0, left_edge=False, right_edge=False):\n        (image_sliced, extent, path, outline_curves) = ImageSlicer.regular_polygon_ring_arc(image, dpu, sides_per_segment, inner_radius, outer_radius,\n                                                                                            sample_rotation, sample_rotation+np.pi/segments, left_edge, right_edge)\n        image_sample = ImageSample(image_sliced, extent, path, outline_curves)\n        ImageSampleTransformer.rotational_repeat_additive(image_sam",
        "ple, 2 * segments, None",
        ")\n        return image_sample"
    ],
    [
        "def leaf_placement(image, dpu=1000.0, segments=8 , inner_radius=0.5, outer_radius=0.8, width=0.2, sample_rotation=0.0, global_rotation=0.0):\n        (image_sliced, extent, path, outline_curves) = ImageSlicer.leaf(image, dpu, width, outer_",
        "radius-inner_radius, True",
        ")\n        image_sample = ImageSample(image_sliced, extent, path, outline_curves)\n        ImageSampleTransformer.mirror_persistent(image_sample, np.pi/2)\n        ImageSampleTransformer.circular_placement_additive(image_sample, inner_radius, segments, None, -np.pi/2, global_rotation)\n        return image_sample"
    ],
    [
        "def leaf_placement(image, dpu=1000.0, segments=8 , inner_radius=0.5, outer_radius=0.8, width=0.2, sample_rotation=0.0, global_rotation=0.0):\n        (image_sliced, extent, path, outline_curves) = ImageSlicer.leaf(image, dpu, width, outer_radius-inner_radius, True)\n        image_sample = ImageSample(image_sliced, exten",
        "t, path, outline_curves",
        ")\n        ImageSampleTransformer.mirror_persistent(image_sample, np.pi/2)\n        ImageSampleTransformer.circular_placement_additive(image_sample, inner_radius, segments, None, -np.pi/2, global_rotation)\n        return image_sample"
    ],
    [
        "def leaf_placement(image, dpu=1000.0, segments=8 , inner_radius=0.5, outer_radius=0.8, width=0.2, sample_rotation=0.0, global_rotation=0.0):\n        (image_sliced, extent, path, outline_curves) = ImageSlicer.leaf(image, dpu, width, outer_radius-inner_radius, True)\n        image_sample = ImageSample(image_sliced, extent, path, outline_curves)\n        ImageSampleTransformer.mirror_persistent(image",
        "_sample, np.pi/2",
        ")\n        ImageSampleTransformer.circular_placement_additive(image_sample, inner_radius, segments, None, -np.pi/2, global_rotation)\n        return image_sample"
    ],
    [
        "def leaf_placement(image, dpu=1000.0, segments=8 , inner_radius=0.5, outer_radius=0.8, width=0.2, sample_rotation=0.0, global_rotation=0.0):\n        (image_sliced, extent, path, outline_curves) = ImageSlicer.leaf(image, dpu, width, outer_radius-inner_radius, True)\n        image_sample = ImageSample(image_sliced, extent, path, outline_curves)\n        ImageSampleTransformer.mirror_persistent(image_sample, np.pi/2)\n        ImageSampleTransformer.circular_placement_additive(image_sample, inner_radius, ",
        "segments, None, -np.pi/2, global_rotation",
        ")\n        return image_sample"
    ],
    [
        "def evaluate_curve_bounds(curve):\n        x_bounds = (np.min(curve",
        "[0, :]",
        "), np.max(curve[0, :]))\n        y_bounds = (np.min(curve[1, :]), np.max(curve[1, :]))\n        (rho, theta) = CurveTransforms.cartesian_to_polar(curve[0, :], curve[1, :])\n        rho_bounds = (np.min(rho), np.max(rho))\n        theta_bounds = (np.min(theta), np.max(theta))\n        return x_bounds, y_bounds, rho_bounds, theta_bounds"
    ],
    [
        "def evaluate_curve_bounds(curve):\n        x_bounds = (np.min(curve[0, :]), np.max(curve",
        "[0, :]",
        "))\n        y_bounds = (np.min(curve[1, :]), np.max(curve[1, :]))\n        (rho, theta) = CurveTransforms.cartesian_to_polar(curve[0, :], curve[1, :])\n        rho_bounds = (np.min(rho), np.max(rho))\n        theta_bounds = (np.min(theta), np.max(theta))\n        return x_bounds, y_bounds, rho_bounds, theta_bounds"
    ],
    [
        "def evaluate_curve_bounds(curve):\n        x_bounds = (np.min(curve[0, :]), np.max(curve[0, :]))\n        y_bounds = (np.min(curve",
        "[1, :]",
        "), np.max(curve[1, :]))\n        (rho, theta) = CurveTransforms.cartesian_to_polar(curve[0, :], curve[1, :])\n        rho_bounds = (np.min(rho), np.max(rho))\n        theta_bounds = (np.min(theta), np.max(theta))\n        return x_bounds, y_bounds, rho_bounds, theta_bounds"
    ],
    [
        "def evaluate_curve_bounds(curve):\n        x_bounds = (np.min(curve[0, :]), np.max(curve[0, :]))\n        y_bounds = (np.min(curve[1, :]), np.max(curve",
        "[1, :]",
        "))\n        (rho, theta) = CurveTransforms.cartesian_to_polar(curve[0, :], curve[1, :])\n        rho_bounds = (np.min(rho), np.max(rho))\n        theta_bounds = (np.min(theta), np.max(theta))\n        return x_bounds, y_bounds, rho_bounds, theta_bounds"
    ],
    [
        "def evaluate_curve_bounds(curve):\n        x_bounds = (np.min(curve[0, :]), np.max(curve[0, :]))\n        y_bounds = (np.min(curve[1, :]), np.max(curve[1, :]))\n        (rho, theta) = CurveTransforms.cartesian_to_polar(curve[0, ",
        ":], curve[1, :]",
        ")\n        rho_bounds = (np.min(rho), np.max(rho))\n        theta_bounds = (np.min(theta), np.max(theta))\n        return x_bounds, y_bounds, rho_bounds, theta_bounds"
    ],
    [
        "def update_curve_bounds(self, bounds):\n        if self.X_bounds is None:\n            self.X_bounds = bounds[0]\n            self.Y_bounds = bounds[1]\n            self.Rho_bounds = bounds[2]\n            self.Theta_bounds = bounds[3]\n        else:\n            self.X_bounds = (np.minimum(self.X_b",
        "ounds[0], bounds[0][0]",
        "),\n                             np.maximum(self.X_bounds[1], bounds[0][1]))\n            self.Y_bounds = (np.minimum(self.Y_bounds[0], bounds[1][0]),\n                             np.maximum(self.Y_bounds[1], bounds[1][1]))\n            self.Rho_bounds = (np.minimum(self.Rho_bounds[0], bounds[2][0]),\n                               np.maximum(self.Rho_bounds[1], bounds[2][1]))\n            self.Theta_bounds = (np.minimum(self.Theta_bounds[0], bounds[3][0]),\n                                 np.maximum(self.Theta_bounds[1], bounds[3][1]))"
    ],
    [
        "def update_curve_bounds(self, bounds):\n        if self.X_bounds is None:\n            self.X_bounds = bounds[0]\n            self.Y_bounds = bounds[1]\n            self.Rho_bounds = bounds[2]\n            self.Theta_bounds = bounds[3]\n        else:\n            self.X_bounds = (np.minimum(self.X_bounds[0], bounds[0][0]),\n                             np.maximum(self.X_boun",
        "ds[1], bounds[0][1]",
        "))\n            self.Y_bounds = (np.minimum(self.Y_bounds[0], bounds[1][0]),\n                             np.maximum(self.Y_bounds[1], bounds[1][1]))\n            self.Rho_bounds = (np.minimum(self.Rho_bounds[0], bounds[2][0]),\n                               np.maximum(self.Rho_bounds[1], bounds[2][1]))\n            self.Theta_bounds = (np.minimum(self.Theta_bounds[0], bounds[3][0]),\n                                 np.maximum(self.Theta_bounds[1], bounds[3][1]))"
    ],
    [
        "def update_curve_bounds(self, bounds):\n        if self.X_bounds is None:\n            self.X_bounds = bounds[0]\n            self.Y_bounds = bounds[1]\n            self.Rho_bounds = bounds[2]\n            self.Theta_bounds = bounds[3]\n        else:\n            self.X_bounds = (np.minimum(self.X_bounds[0], bounds[0][0]),\n                             np.maximum(self.X_bounds[1], bounds[0][1]))\n            self.Y_bounds = (np.minimum(self.Y_bou",
        "nds[0], bounds[1][0]",
        "),\n                             np.maximum(self.Y_bounds[1], bounds[1][1]))\n            self.Rho_bounds = (np.minimum(self.Rho_bounds[0], bounds[2][0]),\n                               np.maximum(self.Rho_bounds[1], bounds[2][1]))\n            self.Theta_bounds = (np.minimum(self.Theta_bounds[0], bounds[3][0]),\n                                 np.maximum(self.Theta_bounds[1], bounds[3][1]))"
    ],
    [
        "def update_curve_bounds(self, bounds):\n        if self.X_bounds is None:\n            self.X_bounds = bounds[0]\n            self.Y_bounds = bounds[1]\n            self.Rho_bounds = bounds[2]\n            self.Theta_bounds = bounds[3]\n        else:\n            self.X_bounds = (np.minimum(self.X_bounds[0], bounds[0][0]),\n                             np.maximum(self.X_bounds[1], bounds[0][1]))\n            self.Y_bounds = (np.minimum(self.Y_bounds[0], bounds[1][0]),\n                             np.maximum(self.Y_bounds",
        "[1], bounds[1][1]",
        "))\n            self.Rho_bounds = (np.minimum(self.Rho_bounds[0], bounds[2][0]),\n                               np.maximum(self.Rho_bounds[1], bounds[2][1]))\n            self.Theta_bounds = (np.minimum(self.Theta_bounds[0], bounds[3][0]),\n                                 np.maximum(self.Theta_bounds[1], bounds[3][1]))"
    ],
    [
        "def update_curve_bounds(self, bounds):\n        if self.X_bounds is None:\n            self.X_bounds = bounds[0]\n            self.Y_bounds = bounds[1]\n            self.Rho_bounds = bounds[2]\n            self.Theta_bounds = bounds[3]\n        else:\n            self.X_bounds = (np.minimum(self.X_bounds[0], bounds[0][0]),\n                             np.maximum(self.X_bounds[1], bounds[0][1]))\n            self.Y_bounds = (np.minimum(self.Y_bounds[0], bounds[1][0]),\n                             np.maximum(self.Y_bounds[1], bounds[1][1]))\n            self.Rho_bounds = (np.minimum(self.Rho_b",
        "ounds[0], bounds[2][0]",
        "),\n                               np.maximum(self.Rho_bounds[1], bounds[2][1]))\n            self.Theta_bounds = (np.minimum(self.Theta_bounds[0], bounds[3][0]),\n                                 np.maximum(self.Theta_bounds[1], bounds[3][1]))"
    ],
    [
        "def update_curve_bounds(self, bounds):\n        if self.X_bounds is None:\n            self.X_bounds = bounds[0]\n            self.Y_bounds = bounds[1]\n            self.Rho_bounds = bounds[2]\n            self.Theta_bounds = bounds[3]\n        else:\n            self.X_bounds = (np.minimum(self.X_bounds[0], bounds[0][0]),\n                             np.maximum(self.X_bounds[1], bounds[0][1]))\n            self.Y_bounds = (np.minimum(self.Y_bounds[0], bounds[1][0]),\n                             np.maximum(self.Y_bounds[1], bounds[1][1]))\n            self.Rho_bounds = (np.minimum(self.Rho_bounds[0], bounds[2][0]),\n                               np.maximum(self.Rho_",
        "bounds[1], bounds[2][1]",
        "))\n            self.Theta_bounds = (np.minimum(self.Theta_bounds[0], bounds[3][0]),\n                                 np.maximum(self.Theta_bounds[1], bounds[3][1]))"
    ],
    [
        "def update_curve_bounds(self, bounds):\n        if self.X_bounds is None:\n            self.X_bounds = bounds[0]\n            self.Y_bounds = bounds[1]\n            self.Rho_bounds = bounds[2]\n            self.Theta_bounds = bounds[3]\n        else:\n            self.X_bounds = (np.minimum(self.X_bounds[0], bounds[0][0]),\n                             np.maximum(self.X_bounds[1], bounds[0][1]))\n            self.Y_bounds = (np.minimum(self.Y_bounds[0], bounds[1][0]),\n                             np.maximum(self.Y_bounds[1], bounds[1][1]))\n            self.Rho_bounds = (np.minimum(self.Rho_bounds[0], bounds[2][0]),\n                               np.maximum(self.Rho_bounds[1], bounds[2][1]))\n            self.Theta_bounds = (np.minimum(self.",
        "Theta_bounds[0], bounds[3][0]",
        "),\n                                 np.maximum(self.Theta_bounds[1], bounds[3][1]))"
    ],
    [
        "def append_figure(self, figure: \"Figure\"):\n        self.Curves.extend(figure.",
        "Curves",
        ")\n        self.PlotType.extend(figure.PlotType)\n        self.update_curve_bounds((figure.X_bounds, figure.Y_bounds, figure.Rho_bounds, figure.Theta_bounds))"
    ],
    [
        "def append_figure(self, figure: \"Figure\"):\n        self.Curves.extend(figure.Curves)\n        self.PlotType.extend(figure.P",
        "lotType",
        ")\n        self.update_curve_bounds((figure.X_bounds, figure.Y_bounds, figure.Rho_bounds, figure.Theta_bounds))"
    ],
    [
        "def __iadd__(self, figure: \"Figure\"):\n        if isinstance(figure",
        ", Figure",
        "):\n            self.append_figure(figure)\n        else:\n            raise TypeError(\"Operator += can only be used with instance of class Figure\")"
    ],
    [
        "def __add__(self, figure: \"Figure\"):\n        if isinstance(figure,",
        " Figure",
        "):\n            new_figure = Figure()\n            new_figure += self\n            new_figure += figure\n        else:\n            raise TypeError(\"Operator + can only be used with instance of class Figure\")\n        return new_figure"
    ],
    [
        "def __add__(self, figure: \"Figure\"):\n        if isinstance(figure, Figure):\n            new_figure = Figure()\n            new_figure += self\n            new_figure += figure\n        else:\n            raise TypeError(\"Operator + can only be used w",
        "ith instance of class Figure\"",
        ")\n        return new_figure"
    ],
    [
        "def plot(self, ax, image_outline_width=1.0):\n        for image in self.Images:\n            image.plot(ax, self.z_order, ",
        "image_outline_width",
        ")\n            Figure.z_order += 1\n        for i in range(len(self.Curves)):\n            if self.PlotType[i] == \"clear\":\n                ax.fill(self.Curves[i][:, 0], self.Curves[i][:, 1], color=\"w\", zorder=self.z_order)\n            elif self.PlotType[i] == \"fill\":\n                ax.fill(self.Curves[i][:, 0], self.Curves[i][:, 1], color=\"k\", zorder=self.z_order)\n            elif self.PlotType[i] > 0:\n                ax.plot(self.Curves[i][:, 0], self.Curves[i][:, 1], color=\"k\", solid_capstyle='round',\n                         linewidth=self.PlotType[i], zorder=self.z_order)\n            elif self.PlotType[i] < 0:\n                ax.fill(self.Curves[i][:, 0], self.Curves[i][:, 1], color=\"w\", zorder=self.z_order)\n                ax.plot(self.Curves[i][:, 0], self.Curves[i][:, 1], color=\"k\", solid_capstyle='round',\n                         linewidth=self.PlotType[i], zorder=self.z_order)\n        Figure.z_order += 1"
    ],
    [
        "def plot(self, ax, image_outline_width=1.0):\n        for image in self.Images:\n            image.plot(ax, self.z_order, image_outline_width)\n            Figure.z_order += 1\n        for i in range(len(self",
        ".Curves)",
        "):\n            if self.PlotType[i] == \"clear\":\n                ax.fill(self.Curves[i][:, 0], self.Curves[i][:, 1], color=\"w\", zorder=self.z_order)\n            elif self.PlotType[i] == \"fill\":\n                ax.fill(self.Curves[i][:, 0], self.Curves[i][:, 1], color=\"k\", zorder=self.z_order)\n            elif self.PlotType[i] > 0:\n                ax.plot(self.Curves[i][:, 0], self.Curves[i][:, 1], color=\"k\", solid_capstyle='round',\n                         linewidth=self.PlotType[i], zorder=self.z_order)\n            elif self.PlotType[i] < 0:\n                ax.fill(self.Curves[i][:, 0], self.Curves[i][:, 1], color=\"w\", zorder=self.z_order)\n                ax.plot(self.Curves[i][:, 0], self.Curves[i][:, 1], color=\"k\", solid_capstyle='round',\n                         linewidth=self.PlotType[i], zorder=self.z_order)\n        Figure.z_order += 1"
    ],
    [
        "def plot(self, ax, image_outline_width=1.0):\n        for image in self.Images:\n            image.plot(ax, self.z_order, image_outline_width)\n            Figure.z_order += 1\n        for i in range(len(self.",
        "Curves",
        ")):\n            if self.PlotType[i] == \"clear\":\n                ax.fill(self.Curves[i][:, 0], self.Curves[i][:, 1], color=\"w\", zorder=self.z_order)\n            elif self.PlotType[i] == \"fill\":\n                ax.fill(self.Curves[i][:, 0], self.Curves[i][:, 1], color=\"k\", zorder=self.z_order)\n            elif self.PlotType[i] > 0:\n                ax.plot(self.Curves[i][:, 0], self.Curves[i][:, 1], color=\"k\", solid_capstyle='round',\n                         linewidth=self.PlotType[i], zorder=self.z_order)\n            elif self.PlotType[i] < 0:\n                ax.fill(self.Curves[i][:, 0], self.Curves[i][:, 1], color=\"w\", zorder=self.z_order)\n                ax.plot(self.Curves[i][:, 0], self.Curves[i][:, 1], color=\"k\", solid_capstyle='round',\n                         linewidth=self.PlotType[i], zorder=self.z_order)\n        Figure.z_order += 1"
    ],
    [
        "def plot(self, ax, image_outline_width=1.0):\n        for image in self.Images:\n            image.plot(ax, self.z_order, image_outline_width)\n            Figure.z_order += 1\n        for i in range(len(self.Curves)):\n            if self.PlotType[i] == \"clear\":\n                ax.fill(self.Curves[i][:",
        ", 0], self.Curves[i][:, 1]",
        ")\n            elif self.PlotType[i] == \"fill\":\n                ax.fill(self.Curves[i][:, 0], self.Curves[i][:, 1], color=\"k\", zorder=self.z_order)\n            elif self.PlotType[i] > 0:\n                ax.plot(self.Curves[i][:, 0], self.Curves[i][:, 1], color=\"k\", solid_capstyle='round',\n                         linewidth=self.PlotType[i], zorder=self.z_order)\n            elif self.PlotType[i] < 0:\n                ax.fill(self.Curves[i][:, 0], self.Curves[i][:, 1], color=\"w\", zorder=self.z_order)\n                ax.plot(self.Curves[i][:, 0], self.Curves[i][:, 1], color=\"k\", solid_capstyle='round',\n                         linewidth=self.PlotType[i], zorder=self.z_order)\n        Figure.z_order += 1"
    ],
    [
        "def plot(self, ax, image_outline_width=1.0):\n        for image in self.Images:\n            image.plot(ax, self.z_order, image_outline_width)\n            Figure.z_order += 1\n        for i in range(len(self.Curves)):\n            if self.PlotType[i] == \"clear\":\n                ax.fill(self.Curves[i][:, 0], self.Curves[i][:, 1], color=\"w\", zorder=self.z_order)\n            elif self.PlotType[i] == \"fill\":\n                ax.fill(self.Curves[i",
        "][:, 0], self.Curves[i][:, 1]",
        ")\n            elif self.PlotType[i] > 0:\n                ax.plot(self.Curves[i][:, 0], self.Curves[i][:, 1], color=\"k\", solid_capstyle='round',\n                         linewidth=self.PlotType[i], zorder=self.z_order)\n            elif self.PlotType[i] < 0:\n                ax.fill(self.Curves[i][:, 0], self.Curves[i][:, 1], color=\"w\", zorder=self.z_order)\n                ax.plot(self.Curves[i][:, 0], self.Curves[i][:, 1], color=\"k\", solid_capstyle='round',\n                         linewidth=self.PlotType[i], zorder=self.z_order)\n        Figure.z_order += 1"
    ],
    [
        "def plot(self, ax, image_outline_width=1.0):\n        for image in self.Images:\n            image.plot(ax, self.z_order, image_outline_width)\n            Figure.z_order += 1\n        for i in range(len(self.Curves)):\n            if self.PlotType[i] == \"clear\":\n                ax.fill(self.Curves[i][:, 0], self.Curves[i][:, 1], color=\"w\", zorder=self.z_order)\n            elif self.PlotType[i] == \"fill\":\n                ax.fill(self.Curves[i][:, 0], self.Curves[i][:, 1], color=\"k\", zorder=self.z_order)\n            elif self.PlotType[i] > 0:\n                ax.plot(self.Curves",
        "[i][:, 0], self.Curves[i][:, 1]",
        ")\n            elif self.PlotType[i] < 0:\n                ax.fill(self.Curves[i][:, 0], self.Curves[i][:, 1], color=\"w\", zorder=self.z_order)\n                ax.plot(self.Curves[i][:, 0], self.Curves[i][:, 1], color=\"k\", solid_capstyle='round',\n                         linewidth=self.PlotType[i], zorder=self.z_order)\n        Figure.z_order += 1"
    ],
    [
        "def plot(self, ax, image_outline_width=1.0):\n        for image in self.Images:\n            image.plot(ax, self.z_order, image_outline_width)\n            Figure.z_order += 1\n        for i in range(len(self.Curves)):\n            if self.PlotType[i] == \"clear\":\n                ax.fill(self.Curves[i][:, 0], self.Curves[i][:, 1], color=\"w\", zorder=self.z_order)\n            elif self.PlotType[i] == \"fill\":\n                ax.fill(self.Curves[i][:, 0], self.Curves[i][:, 1], color=\"k\", zorder=self.z_order)\n            elif self.PlotType[i] > 0:\n                ax.plot(self.Curves[i][:, 0], self.Curves[i][:, 1], color=\"k\", solid_capstyle='round',\n                         linewidth=self.PlotType[i], zorder=self.z_order)\n            elif self.PlotType[i] < 0:\n                ax.fill(self.Curves[i",
        "][:, 0], self.Curves[i][:, 1]",
        ")\n                ax.plot(self.Curves[i][:, 0], self.Curves[i][:, 1], color=\"k\", solid_capstyle='round',\n                         linewidth=self.PlotType[i], zorder=self.z_order)\n        Figure.z_order += 1"
    ],
    [
        "def plot(self, ax, image_outline_width=1.0):\n        for image in self.Images:\n            image.plot(ax, self.z_order, image_outline_width)\n            Figure.z_order += 1\n        for i in range(len(self.Curves)):\n            if self.PlotType[i] == \"clear\":\n                ax.fill(self.Curves[i][:, 0], self.Curves[i][:, 1], color=\"w\", zorder=self.z_order)\n            elif self.PlotType[i] == \"fill\":\n                ax.fill(self.Curves[i][:, 0], self.Curves[i][:, 1], color=\"k\", zorder=self.z_order)\n            elif self.PlotType[i] > 0:\n                ax.plot(self.Curves[i][:, 0], self.Curves[i][:, 1], color=\"k\", solid_capstyle='round',\n                         linewidth=self.PlotType[i], zorder=self.z_order)\n            elif self.PlotType[i] < 0:\n                ax.fill(self.Curves[i][:, 0], self.Curves[i][:, 1], color=\"w\", zorder=self.z_order)\n                ax.plot(self.Curves[i][:,",
        " 0], self.Curves[i][:, 1]",
        ")\n        Figure.z_order += 1"
    ],
    [
        "def diamond_figure(x_bounds=(0.0, 1.0), y_bounds=(0.0, 1.0), subdivisions=(3, 3), line_width=1.0, fill=False):\n        x_delta = np.abs(x_bound",
        "s[0] - x_bounds[1]",
        ") / subdivisions[0]\n        y_delta = np.abs(y_bounds[0] - y_bounds[1]) / subdivisions[1]\n        base_diamond = CurveGenerator.polyline([0, x_delta/2, x_delta, x_delta/2, 0], [y_delta/2, y_delta, y_delta/2, 0, y_delta/2])\n        diamonds = [base_diamond]\n        print(diamonds)\n        Transformer.translation_repeat_curves(diamonds, subdivisions, (x_delta, y_delta))\n        Transformer.translate_curves(diamonds, x_bounds[0], y_bounds[0])\n        figure = Figure()\n        for curve in diamonds:\n            figure.add_curve(curve, line_width)\n        if fill and line_width:\n            for curve in diamonds:\n                figure.add_curve(curve, 0)\n        figure.evaluate_bounds()\n        return figure"
    ],
    [
        "def diamond_figure(x_bounds=(0.0, 1.0), y_bounds=(0.0, 1.0), subdivisions=(3, 3), line_width=1.0, fill=False):\n        x_delta = np.abs(x_bounds[0] - x_bounds[1]) / subdivisions[0]\n        y_delta = np.abs(y_bounds[0",
        "] - y_bounds[1]",
        ") / subdivisions[1]\n        base_diamond = CurveGenerator.polyline([0, x_delta/2, x_delta, x_delta/2, 0], [y_delta/2, y_delta, y_delta/2, 0, y_delta/2])\n        diamonds = [base_diamond]\n        print(diamonds)\n        Transformer.translation_repeat_curves(diamonds, subdivisions, (x_delta, y_delta))\n        Transformer.translate_curves(diamonds, x_bounds[0], y_bounds[0])\n        figure = Figure()\n        for curve in diamonds:\n            figure.add_curve(curve, line_width)\n        if fill and line_width:\n            for curve in diamonds:\n                figure.add_curve(curve, 0)\n        figure.evaluate_bounds()\n        return figure"
    ],
    [
        "def diamond_figure(x_bounds=(0.0, 1.0), y_bounds=(0.0, 1.0), subdivisions=(3, 3), line_width=1.0, fill=False):\n        x_delta = np.abs(x_bounds[0] - x_bounds[1]) / subdivisions[0]\n        y_delta = np.abs(y_bounds[0] - y_bounds[1]) / subdivisions[1]\n        base_diamond = CurveGenerator.polyline([0, x_delta/2, x_delta, x_delta/2, ",
        "0], [y_delta/2, y_delta, y_delta/2, 0, y_delta/2]",
        ")\n        diamonds = [base_diamond]\n        print(diamonds)\n        Transformer.translation_repeat_curves(diamonds, subdivisions, (x_delta, y_delta))\n        Transformer.translate_curves(diamonds, x_bounds[0], y_bounds[0])\n        figure = Figure()\n        for curve in diamonds:\n            figure.add_curve(curve, line_width)\n        if fill and line_width:\n            for curve in diamonds:\n                figure.add_curve(curve, 0)\n        figure.evaluate_bounds()\n        return figure"
    ],
    [
        "def diamond_figure(x_bounds=(0.0, 1.0), y_bounds=(0.0, 1.0), subdivisions=(3, 3), line_width=1.0, fill=False):\n        x_delta = np.abs(x_bounds[0] - x_bounds[1]) / subdivisions[0]\n        y_delta = np.abs(y_bounds[0] - y_bounds[1]) / subdivisions[1]\n        base_diamond = CurveGenerator.polyline([0, x_delta/2, x_delta, x_delta/2, 0], [y_delta/2, y_delta, y_delta/2, 0, y_delta/2])\n        diamonds = [base_diamond]\n        print(diamonds)\n        Transformer.translation_repeat_curves(diamonds, su",
        "bdivisions, (x_delta, y_delta)",
        ")\n        Transformer.translate_curves(diamonds, x_bounds[0], y_bounds[0])\n        figure = Figure()\n        for curve in diamonds:\n            figure.add_curve(curve, line_width)\n        if fill and line_width:\n            for curve in diamonds:\n                figure.add_curve(curve, 0)\n        figure.evaluate_bounds()\n        return figure"
    ],
    [
        "def diamond_figure(x_bounds=(0.0, 1.0), y_bounds=(0.0, 1.0), subdivisions=(3, 3), line_width=1.0, fill=False):\n        x_delta = np.abs(x_bounds[0] - x_bounds[1]) / subdivisions[0]\n        y_delta = np.abs(y_bounds[0] - y_bounds[1]) / subdivisions[1]\n        base_diamond = CurveGenerator.polyline([0, x_delta/2, x_delta, x_delta/2, 0], [y_delta/2, y_delta, y_delta/2, 0, y_delta/2])\n        diamonds = [base_diamond]\n        print(diamonds)\n        Transformer.translation_repeat_curves(diamonds, subdivisions, (x_delta, y_delta))\n        Transformer.translate_curves(diamonds, x_bounds",
        "[0], y_bounds[0]",
        ")\n        figure = Figure()\n        for curve in diamonds:\n            figure.add_curve(curve, line_width)\n        if fill and line_width:\n            for curve in diamonds:\n                figure.add_curve(curve, 0)\n        figure.evaluate_bounds()\n        return figure"
    ],
    [
        "def diamond_figure(x_bounds=(0.0, 1.0), y_bounds=(0.0, 1.0), subdivisions=(3, 3), line_width=1.0, fill=False):\n        x_delta = np.abs(x_bounds[0] - x_bounds[1]) / subdivisions[0]\n        y_delta = np.abs(y_bounds[0] - y_bounds[1]) / subdivisions[1]\n        base_diamond = CurveGenerator.polyline([0, x_delta/2, x_delta, x_delta/2, 0], [y_delta/2, y_delta, y_delta/2, 0, y_delta/2])\n        diamonds = [base_diamond]\n        print(diamonds)\n        Transformer.translation_repeat_curves(diamonds, subdivisions, (x_delta, y_delta))\n        Transformer.translate_curves(diamonds, x_bounds[0], y_bounds[0])\n        figure = Figure()\n        for curve in diamonds:\n            figure.add_curve(curve, ",
        "line_width",
        ")\n        if fill and line_width:\n            for curve in diamonds:\n                figure.add_curve(curve, 0)\n        figure.evaluate_bounds()\n        return figure"
    ],
    [
        "def rotate_curves(curves: \"list\", angle=0):\n        transform = Affine2D().rotate(angle)\n        for i in range(len(c",
        "urves)",
        "):\n            curves[i] = transform.transform(curves[i])"
    ],
    [
        "def rotate_figure(figure: \"Figure\", angle=0):\n        Transformer.rotate_curves(figure.Curv",
        "es, angle",
        ")\n        figure.evaluate_bounds()\n        return figure"
    ],
    [
        "def scale_curves(curves: \"list\", scale=1.0):\n        for i in range(len(c",
        "urves)",
        "):\n            curves[i] = scale*curves[i]"
    ],
    [
        "def scale_figure(figure: \"Figure\", scale=1.0):\n        Transformer.scale_curves(figure.Curv",
        "es, scale",
        ")\n        figure.evaluate_bounds()"
    ],
    [
        "def rotation_repeat_curves(curves: \"list\", number_of_segments=None, delta_angle=None, scale=1.0, reverse_rotation=False):\n        if number_of_segments is None and delta_angle is None:\n            repetitions = 1\n            angle = None\n        elif number_of_segments is None:\n            repetitions = np.trunc(2*np.",
        "pi/delta_angle",
        ")\n            angle = None\n        elif delta_angle is None:\n            repetitions = np.maximum(1, number_of_segments)\n            angle = None\n        else:\n            repetitions = np.maximum(1, number_of_segments)\n            angle = delta_angle\n        if angle is None:\n            angle = 2*np.pi/repetitions\n        if reverse_rotation:\n            angle = -angle\n        scale = np.array(scale)\n        if scale.size == 1:\n            scales = scale*np.ones(repetitions)\n        elif scale.size == 2:\n            scales = np.linspace(scale[0], scale[1], repetitions)\n        elif scale.size == repetitions:\n            scales = scale\n        else:\n            scales = np.ones(repetitions)\n        base_curves = copy.deepcopy(curves)\n        Transformer.scale_curves(curves, scales[0])\n        for i in range(1, repetitions):\n            new_curves = copy.deepcopy(base_curves)\n            Transformer.rotate_curves(new_curves, i*angle)\n            Transformer.scale_curves(new_curves, scales[i])\n            curves.extend(new_curves)"
    ],
    [
        "def rotation_repeat_curves(curves: \"list\", number_of_segments=None, delta_angle=None, scale=1.0, reverse_rotation=False):\n        if number_of_segments is None and delta_angle is None:\n            repetitions = 1\n            angle = None\n        elif number_of_segments is None:\n            repetitions = np.trunc(2*np.pi/delta_angle)\n            angle = None\n        elif delta_angle is None:\n            repetitions = np.maximum(1, nu",
        "mber_of_segments",
        ")\n            angle = None\n        else:\n            repetitions = np.maximum(1, number_of_segments)\n            angle = delta_angle\n        if angle is None:\n            angle = 2*np.pi/repetitions\n        if reverse_rotation:\n            angle = -angle\n        scale = np.array(scale)\n        if scale.size == 1:\n            scales = scale*np.ones(repetitions)\n        elif scale.size == 2:\n            scales = np.linspace(scale[0], scale[1], repetitions)\n        elif scale.size == repetitions:\n            scales = scale\n        else:\n            scales = np.ones(repetitions)\n        base_curves = copy.deepcopy(curves)\n        Transformer.scale_curves(curves, scales[0])\n        for i in range(1, repetitions):\n            new_curves = copy.deepcopy(base_curves)\n            Transformer.rotate_curves(new_curves, i*angle)\n            Transformer.scale_curves(new_curves, scales[i])\n            curves.extend(new_curves)"
    ],
    [
        "def rotation_repeat_curves(curves: \"list\", number_of_segments=None, delta_angle=None, scale=1.0, reverse_rotation=False):\n        if number_of_segments is None and delta_angle is None:\n            repetitions = 1\n            angle = None\n        elif number_of_segments is None:\n            repetitions = np.trunc(2*np.pi/delta_angle)\n            angle = None\n        elif delta_angle is None:\n            repetitions = np.maximum(1, number_of_segments)\n            angle = None\n        else:\n            repetitions = np.maximum(1, numb",
        "er_of_segments",
        ")\n            angle = delta_angle\n        if angle is None:\n            angle = 2*np.pi/repetitions\n        if reverse_rotation:\n            angle = -angle\n        scale = np.array(scale)\n        if scale.size == 1:\n            scales = scale*np.ones(repetitions)\n        elif scale.size == 2:\n            scales = np.linspace(scale[0], scale[1], repetitions)\n        elif scale.size == repetitions:\n            scales = scale\n        else:\n            scales = np.ones(repetitions)\n        base_curves = copy.deepcopy(curves)\n        Transformer.scale_curves(curves, scales[0])\n        for i in range(1, repetitions):\n            new_curves = copy.deepcopy(base_curves)\n            Transformer.rotate_curves(new_curves, i*angle)\n            Transformer.scale_curves(new_curves, scales[i])\n            curves.extend(new_curves)"
    ],
    [
        "def rotation_repeat_curves(curves: \"list\", number_of_segments=None, delta_angle=None, scale=1.0, reverse_rotation=False):\n        if number_of_segments is None and delta_angle is None:\n            repetitions = 1\n            angle = None\n        elif number_of_segments is None:\n            repetitions = np.trunc(2*np.pi/delta_angle)\n            angle = None\n        elif delta_angle is None:\n            repetitions = np.maximum(1, number_of_segments)\n            angle = None\n        else:\n            repetitions = np.maximum(1, number_of_segments)\n            angle = delta_angle\n        if angle is None:\n            angle = 2*np.pi/repetitions\n        if reverse_rotation:\n            angle = -angle\n        scale = np.array(scale)\n        if scale.size == 1:\n            scales = scale*np.ones(repet",
        "itions",
        ")\n        elif scale.size == 2:\n            scales = np.linspace(scale[0], scale[1], repetitions)\n        elif scale.size == repetitions:\n            scales = scale\n        else:\n            scales = np.ones(repetitions)\n        base_curves = copy.deepcopy(curves)\n        Transformer.scale_curves(curves, scales[0])\n        for i in range(1, repetitions):\n            new_curves = copy.deepcopy(base_curves)\n            Transformer.rotate_curves(new_curves, i*angle)\n            Transformer.scale_curves(new_curves, scales[i])\n            curves.extend(new_curves)"
    ],
    [
        "def rotation_repeat_curves(curves: \"list\", number_of_segments=None, delta_angle=None, scale=1.0, reverse_rotation=False):\n        if number_of_segments is None and delta_angle is None:\n            repetitions = 1\n            angle = None\n        elif number_of_segments is None:\n            repetitions = np.trunc(2*np.pi/delta_angle)\n            angle = None\n        elif delta_angle is None:\n            repetitions = np.maximum(1, number_of_segments)\n            angle = None\n        else:\n            repetitions = np.maximum(1, number_of_segments)\n            angle = delta_angle\n        if angle is None:\n            angle = 2*np.pi/repetitions\n        if reverse_rotation:\n            angle = -angle\n        scale = np.array(scale)\n        if scale.size == 1:\n            scales = scale*np.ones(repetitions)\n        elif scale.size == 2:\n            scales = np.linspace(scale[0], scale[",
        "1], repetitions",
        ")\n        elif scale.size == repetitions:\n            scales = scale\n        else:\n            scales = np.ones(repetitions)\n        base_curves = copy.deepcopy(curves)\n        Transformer.scale_curves(curves, scales[0])\n        for i in range(1, repetitions):\n            new_curves = copy.deepcopy(base_curves)\n            Transformer.rotate_curves(new_curves, i*angle)\n            Transformer.scale_curves(new_curves, scales[i])\n            curves.extend(new_curves)"
    ],
    [
        "def rotation_repeat_curves(curves: \"list\", number_of_segments=None, delta_angle=None, scale=1.0, reverse_rotation=False):\n        if number_of_segments is None and delta_angle is None:\n            repetitions = 1\n            angle = None\n        elif number_of_segments is None:\n            repetitions = np.trunc(2*np.pi/delta_angle)\n            angle = None\n        elif delta_angle is None:\n            repetitions = np.maximum(1, number_of_segments)\n            angle = None\n        else:\n            repetitions = np.maximum(1, number_of_segments)\n            angle = delta_angle\n        if angle is None:\n            angle = 2*np.pi/repetitions\n        if reverse_rotation:\n            angle = -angle\n        scale = np.array(scale)\n        if scale.size == 1:\n            scales = scale*np.ones(repetitions)\n        elif scale.size == 2:\n            scales = np.linspace(scale[0], scale[1], repetitions)\n        elif scale.size == repetitions:\n            scales = scale\n        else:\n            scales = np.ones(repeti",
        "tions",
        ")\n        base_curves = copy.deepcopy(curves)\n        Transformer.scale_curves(curves, scales[0])\n        for i in range(1, repetitions):\n            new_curves = copy.deepcopy(base_curves)\n            Transformer.rotate_curves(new_curves, i*angle)\n            Transformer.scale_curves(new_curves, scales[i])\n            curves.extend(new_curves)"
    ],
    [
        "def rotation_repeat_curves(curves: \"list\", number_of_segments=None, delta_angle=None, scale=1.0, reverse_rotation=False):\n        if number_of_segments is None and delta_angle is None:\n            repetitions = 1\n            angle = None\n        elif number_of_segments is None:\n            repetitions = np.trunc(2*np.pi/delta_angle)\n            angle = None\n        elif delta_angle is None:\n            repetitions = np.maximum(1, number_of_segments)\n            angle = None\n        else:\n            repetitions = np.maximum(1, number_of_segments)\n            angle = delta_angle\n        if angle is None:\n            angle = 2*np.pi/repetitions\n        if reverse_rotation:\n            angle = -angle\n        scale = np.array(scale)\n        if scale.size == 1:\n            scales = scale*np.ones(repetitions)\n        elif scale.size == 2:\n            scales = np.linspace(scale[0], scale[1], repetitions)\n        elif scale.size == repetitions:\n            scales = scale\n        else:\n            scales = np.ones(repetitions)\n        base_curves = copy.deepcopy(curves)\n        Transformer.scale_curves(curves, ",
        "scales[0]",
        ")\n        for i in range(1, repetitions):\n            new_curves = copy.deepcopy(base_curves)\n            Transformer.rotate_curves(new_curves, i*angle)\n            Transformer.scale_curves(new_curves, scales[i])\n            curves.extend(new_curves)"
    ],
    [
        "def rotation_repeat_curves(curves: \"list\", number_of_segments=None, delta_angle=None, scale=1.0, reverse_rotation=False):\n        if number_of_segments is None and delta_angle is None:\n            repetitions = 1\n            angle = None\n        elif number_of_segments is None:\n            repetitions = np.trunc(2*np.pi/delta_angle)\n            angle = None\n        elif delta_angle is None:\n            repetitions = np.maximum(1, number_of_segments)\n            angle = None\n        else:\n            repetitions = np.maximum(1, number_of_segments)\n            angle = delta_angle\n        if angle is None:\n            angle = 2*np.pi/repetitions\n        if reverse_rotation:\n            angle = -angle\n        scale = np.array(scale)\n        if scale.size == 1:\n            scales = scale*np.ones(repetitions)\n        elif scale.size == 2:\n            scales = np.linspace(scale[0], scale[1], repetitions)\n        elif scale.size == repetitions:\n            scales = scale\n        else:\n            scales = np.ones(repetitions)\n        base_curves = copy.deepcopy(curves)\n        Transformer.scale_curves(curves, scales[0])\n        for i in range(1, re",
        "petitions",
        "):\n            new_curves = copy.deepcopy(base_curves)\n            Transformer.rotate_curves(new_curves, i*angle)\n            Transformer.scale_curves(new_curves, scales[i])\n            curves.extend(new_curves)"
    ],
    [
        "def rotation_repeat_curves(curves: \"list\", number_of_segments=None, delta_angle=None, scale=1.0, reverse_rotation=False):\n        if number_of_segments is None and delta_angle is None:\n            repetitions = 1\n            angle = None\n        elif number_of_segments is None:\n            repetitions = np.trunc(2*np.pi/delta_angle)\n            angle = None\n        elif delta_angle is None:\n            repetitions = np.maximum(1, number_of_segments)\n            angle = None\n        else:\n            repetitions = np.maximum(1, number_of_segments)\n            angle = delta_angle\n        if angle is None:\n            angle = 2*np.pi/repetitions\n        if reverse_rotation:\n            angle = -angle\n        scale = np.array(scale)\n        if scale.size == 1:\n            scales = scale*np.ones(repetitions)\n        elif scale.size == 2:\n            scales = np.linspace(scale[0], scale[1], repetitions)\n        elif scale.size == repetitions:\n            scales = scale\n        else:\n            scales = np.ones(repetitions)\n        base_curves = copy.deepcopy(curves)\n        Transformer.scale_curves(curves, scales[0])\n        for i in range(1, repetitions):\n            new_curves = copy.deepcopy(base_",
        "curves",
        ")\n            Transformer.rotate_curves(new_curves, i*angle)\n            Transformer.scale_curves(new_curves, scales[i])\n            curves.extend(new_curves)"
    ],
    [
        "def rotation_repeat_curves(curves: \"list\", number_of_segments=None, delta_angle=None, scale=1.0, reverse_rotation=False):\n        if number_of_segments is None and delta_angle is None:\n            repetitions = 1\n            angle = None\n        elif number_of_segments is None:\n            repetitions = np.trunc(2*np.pi/delta_angle)\n            angle = None\n        elif delta_angle is None:\n            repetitions = np.maximum(1, number_of_segments)\n            angle = None\n        else:\n            repetitions = np.maximum(1, number_of_segments)\n            angle = delta_angle\n        if angle is None:\n            angle = 2*np.pi/repetitions\n        if reverse_rotation:\n            angle = -angle\n        scale = np.array(scale)\n        if scale.size == 1:\n            scales = scale*np.ones(repetitions)\n        elif scale.size == 2:\n            scales = np.linspace(scale[0], scale[1], repetitions)\n        elif scale.size == repetitions:\n            scales = scale\n        else:\n            scales = np.ones(repetitions)\n        base_curves = copy.deepcopy(curves)\n        Transformer.scale_curves(curves, scales[0])\n        for i in range(1, repetitions):\n            new_curves = copy.deepcopy(base_curves)\n            Transformer.rotate_curves(new_curve",
        "s, i*angle",
        ")\n            Transformer.scale_curves(new_curves, scales[i])\n            curves.extend(new_curves)"
    ],
    [
        "def rotation_repeat_curves(curves: \"list\", number_of_segments=None, delta_angle=None, scale=1.0, reverse_rotation=False):\n        if number_of_segments is None and delta_angle is None:\n            repetitions = 1\n            angle = None\n        elif number_of_segments is None:\n            repetitions = np.trunc(2*np.pi/delta_angle)\n            angle = None\n        elif delta_angle is None:\n            repetitions = np.maximum(1, number_of_segments)\n            angle = None\n        else:\n            repetitions = np.maximum(1, number_of_segments)\n            angle = delta_angle\n        if angle is None:\n            angle = 2*np.pi/repetitions\n        if reverse_rotation:\n            angle = -angle\n        scale = np.array(scale)\n        if scale.size == 1:\n            scales = scale*np.ones(repetitions)\n        elif scale.size == 2:\n            scales = np.linspace(scale[0], scale[1], repetitions)\n        elif scale.size == repetitions:\n            scales = scale\n        else:\n            scales = np.ones(repetitions)\n        base_curves = copy.deepcopy(curves)\n        Transformer.scale_curves(curves, scales[0])\n        for i in range(1, repetitions):\n            new_curves = copy.deepcopy(base_curves)\n            Transformer.rotate_curves(new_curves, i*angle)\n            Transformer.scale_curves(new_curves,",
        " scales[i]",
        ")\n            curves.extend(new_curves)"
    ],
    [
        "def rotation_repeat_figure(figure: \"Figure\", number_of_segments=None, delta_angle=None, scale=1.0):\n        Transformer.rotation_repeat_curves(figure.",
        "Curves",
        ")\n        figure.evaluate_bounds()"
    ],
    [
        "def flip_horizontal(curves):\n        for i in range(len(cu",
        "rves)",
        "):\n            curves[i][0, :] = -curves[i][0, :]"
    ],
    [
        "def flip_vertical(curves):\n        for i in range(len(cu",
        "rves)",
        "):\n            curves[i][1, :] = -curves[i][1, :]"
    ],
    [
        "def translate_curves(curves: \"list\", x=0.0, y=0.0):\n        for i in range(len(cu",
        "rves)",
        "):\n            curves[i][0, :] += x\n            curves[i][1, :] += y"
    ],
    [
        "def translation_repeat_curves(curves: \"list\", repetitions=(2, 2), step=(0.1, 0.1), scale=1.0):\n        x_repetitions = np.maximum(repet",
        "itions[0], 1",
        ")\n        y_repetitions = np.maximum(repetitions[1], 1)\n        base_curves = copy.deepcopy(curves)\n        for x in range(1, x_repetitions):\n            Transformer.translate_curves(base_curves, step[0], 0)\n            new_curves = copy.deepcopy(base_curves)\n            curves.extend(new_curves)\n        base_curves = copy.deepcopy(curves)\n        for y in range(1, y_repetitions):\n            Transformer.translate_curves(base_curves, 0, step[1])\n            new_curves = copy.deepcopy(base_curves)\n            curves.extend(new_curves)"
    ],
    [
        "def translation_repeat_curves(curves: \"list\", repetitions=(2, 2), step=(0.1, 0.1), scale=1.0):\n        x_repetitions = np.maximum(repetitions[0], 1)\n        y_repetitions = np.maximum(repet",
        "itions[1], 1",
        ")\n        base_curves = copy.deepcopy(curves)\n        for x in range(1, x_repetitions):\n            Transformer.translate_curves(base_curves, step[0], 0)\n            new_curves = copy.deepcopy(base_curves)\n            curves.extend(new_curves)\n        base_curves = copy.deepcopy(curves)\n        for y in range(1, y_repetitions):\n            Transformer.translate_curves(base_curves, 0, step[1])\n            new_curves = copy.deepcopy(base_curves)\n            curves.extend(new_curves)"
    ],
    [
        "def translation_repeat_curves(curves: \"list\", repetitions=(2, 2), step=(0.1, 0.1), scale=1.0):\n        x_repetitions = np.maximum(repetitions[0], 1)\n        y_repetitions = np.maximum(repetitions[1], 1)\n        base_curves = copy.deepcopy(curves)\n        for x in range(1, x_",
        "repetitions",
        "):\n            Transformer.translate_curves(base_curves, step[0], 0)\n            new_curves = copy.deepcopy(base_curves)\n            curves.extend(new_curves)\n        base_curves = copy.deepcopy(curves)\n        for y in range(1, y_repetitions):\n            Transformer.translate_curves(base_curves, 0, step[1])\n            new_curves = copy.deepcopy(base_curves)\n            curves.extend(new_curves)"
    ],
    [
        "def translation_repeat_curves(curves: \"list\", repetitions=(2, 2), step=(0.1, 0.1), scale=1.0):\n        x_repetitions = np.maximum(repetitions[0], 1)\n        y_repetitions = np.maximum(repetitions[1], 1)\n        base_curves = copy.deepcopy(curves)\n        for x in range(1, x_repetitions):\n            Transformer.translate_curves(base_c",
        "urves, step[0], 0",
        ")\n            new_curves = copy.deepcopy(base_curves)\n            curves.extend(new_curves)\n        base_curves = copy.deepcopy(curves)\n        for y in range(1, y_repetitions):\n            Transformer.translate_curves(base_curves, 0, step[1])\n            new_curves = copy.deepcopy(base_curves)\n            curves.extend(new_curves)"
    ],
    [
        "def translation_repeat_curves(curves: \"list\", repetitions=(2, 2), step=(0.1, 0.1), scale=1.0):\n        x_repetitions = np.maximum(repetitions[0], 1)\n        y_repetitions = np.maximum(repetitions[1], 1)\n        base_curves = copy.deepcopy(curves)\n        for x in range(1, x_repetitions):\n            Transformer.translate_curves(base_curves, step[0], 0)\n            new_curves = copy.deepcopy(base_",
        "curves",
        ")\n            curves.extend(new_curves)\n        base_curves = copy.deepcopy(curves)\n        for y in range(1, y_repetitions):\n            Transformer.translate_curves(base_curves, 0, step[1])\n            new_curves = copy.deepcopy(base_curves)\n            curves.extend(new_curves)"
    ],
    [
        "def translation_repeat_curves(curves: \"list\", repetitions=(2, 2), step=(0.1, 0.1), scale=1.0):\n        x_repetitions = np.maximum(repetitions[0], 1)\n        y_repetitions = np.maximum(repetitions[1], 1)\n        base_curves = copy.deepcopy(curves)\n        for x in range(1, x_repetitions):\n            Transformer.translate_curves(base_curves, step[0], 0)\n            new_curves = copy.deepcopy(base_curves)\n            curves.extend(new_c",
        "urves",
        ")\n        base_curves = copy.deepcopy(curves)\n        for y in range(1, y_repetitions):\n            Transformer.translate_curves(base_curves, 0, step[1])\n            new_curves = copy.deepcopy(base_curves)\n            curves.extend(new_curves)"
    ],
    [
        "def translation_repeat_curves(curves: \"list\", repetitions=(2, 2), step=(0.1, 0.1), scale=1.0):\n        x_repetitions = np.maximum(repetitions[0], 1)\n        y_repetitions = np.maximum(repetitions[1], 1)\n        base_curves = copy.deepcopy(curves)\n        for x in range(1, x_repetitions):\n            Transformer.translate_curves(base_curves, step[0], 0)\n            new_curves = copy.deepcopy(base_curves)\n            curves.extend(new_curves)\n        base_curves = copy.deepcopy(curves)\n        for y in range(1, y_re",
        "petitions",
        "):\n            Transformer.translate_curves(base_curves, 0, step[1])\n            new_curves = copy.deepcopy(base_curves)\n            curves.extend(new_curves)"
    ],
    [
        "def translation_repeat_curves(curves: \"list\", repetitions=(2, 2), step=(0.1, 0.1), scale=1.0):\n        x_repetitions = np.maximum(repetitions[0], 1)\n        y_repetitions = np.maximum(repetitions[1], 1)\n        base_curves = copy.deepcopy(curves)\n        for x in range(1, x_repetitions):\n            Transformer.translate_curves(base_curves, step[0], 0)\n            new_curves = copy.deepcopy(base_curves)\n            curves.extend(new_curves)\n        base_curves = copy.deepcopy(curves)\n        for y in range(1, y_repetitions):\n            Transformer.translate_curves(base_cu",
        "rves, 0, step[1]",
        ")\n            new_curves = copy.deepcopy(base_curves)\n            curves.extend(new_curves)"
    ],
    [
        "def translation_repeat_curves(curves: \"list\", repetitions=(2, 2), step=(0.1, 0.1), scale=1.0):\n        x_repetitions = np.maximum(repetitions[0], 1)\n        y_repetitions = np.maximum(repetitions[1], 1)\n        base_curves = copy.deepcopy(curves)\n        for x in range(1, x_repetitions):\n            Transformer.translate_curves(base_curves, step[0], 0)\n            new_curves = copy.deepcopy(base_curves)\n            curves.extend(new_curves)\n        base_curves = copy.deepcopy(curves)\n        for y in range(1, y_repetitions):\n            Transformer.translate_curves(base_curves, 0, step[1])\n            new_curves = copy.deepcopy(base_",
        "curves",
        ")\n            curves.extend(new_curves)"
    ],
    [
        "def reverse_curves(curves: \"list\"):\n        for i in range(len(c",
        "urves)",
        "):\n            Transformer.reverse_curve(curves[i])"
    ],
    [
        "def interpolate_curve(curve, samples=100, kind=\"cubic\"):\n        spline = interp1d(np.linspace(",
        "0, 1, curve.shape[1]), curve",
        ")\n        t_fine = np.linspace(0, 1, samples)\n        x_fine, y_fine = spline(t_fine)\n        curve.resize((2, samples), refcheck=False)\n        curve[:] = np.vstack((x_fine, y_fine))"
    ],
    [
        "def interpolate_curve(curve, samples=100, kind=\"cubic\"):\n        spline = interp1d(np.linspace(0, 1, cur",
        "ve.shape[1]",
        "), curve, kind=kind)\n        t_fine = np.linspace(0, 1, samples)\n        x_fine, y_fine = spline(t_fine)\n        curve.resize((2, samples), refcheck=False)\n        curve[:] = np.vstack((x_fine, y_fine))"
    ],
    [
        "def interpolate_curve(curve, samples=100, kind=\"cubic\"):\n        spline = interp1d(np.linspace(0, 1, curve.shape[1]), curve, kind=kind)\n        t_fine = np.linspace(0, 1, ",
        "samples",
        ")\n        x_fine, y_fine = spline(t_fine)\n        curve.resize((2, samples), refcheck=False)\n        curve[:] = np.vstack((x_fine, y_fine))"
    ],
    [
        "def interpolate_curve(curve, samples=100, kind=\"cubic\"):\n        spline = interp1d(np.linspace(0, 1, curve.shape[1]), curve, kind=kind)\n        t_fine = np.linspace(0, 1, samples)\n        x_fine, y_fine = spline(t_fine)\n        curve.resize((2, s",
        "amples)",
        ")\n        curve[:] = np.vstack((x_fine, y_fine))"
    ],
    [
        "def create_histogram(n, num_swaps, samples=1000):\n    initial_perm = np.random.permutation(n)\n    swap_counts = []\n    for _ in range(samples):\n        perm1 = np.random.permutation(n)\n        perm2 = np.random.permutation(n)\n        swap_count = min_swaps_to_transform(perm1, ",
        "perm2",
        ")\n        swap_counts.append(swap_count)\n    plt.hist(swap_counts, bins=range(max(swap_counts) + 2), edgecolor='black')\n    plt.xlabel(\"Minimal number of swaps to return to original permutation\")\n    plt.ylabel(\"Frequency\")\n    plt.title(f\"Histogram of minimal swaps for {num_swaps} random swaps on a {n}-element permutation\")\n    plt.show()"
    ],
    [
        "def create_histogram(n, num_swaps, samples=1000):\n    initial_perm = np.random.permutation(n)\n    swap_counts = []\n    for _ in range(samples):\n        perm1 = np.random.permutation(n)\n        perm2 = np.random.permutation(n)\n        swap_count = min_swaps_to_transform(perm1, perm2)\n        swap_counts.append(swap_c",
        "ount",
        ")\n    plt.hist(swap_counts, bins=range(max(swap_counts) + 2), edgecolor='black')\n    plt.xlabel(\"Minimal number of swaps to return to original permutation\")\n    plt.ylabel(\"Frequency\")\n    plt.title(f\"Histogram of minimal swaps for {num_swaps} random swaps on a {n}-element permutation\")\n    plt.show()"
    ],
    [
        "def create_histogram(n, num_swaps, samples=1000):\n    initial_perm = np.random.permutation(n)\n    swap_counts = []\n    for _ in range(samples):\n        perm1 = np.random.permutation(n)\n        perm2 = np.random.permutation(n)\n        swap_count = min_swaps_to_transform(perm1, perm2)\n        swap_counts.append(swap_count)\n    plt.hist(swap_c",
        "ounts",
        ")\n    plt.xlabel(\"Minimal number of swaps to return to original permutation\")\n    plt.ylabel(\"Frequency\")\n    plt.title(f\"Histogram of minimal swaps for {num_swaps} random swaps on a {n}-element permutation\")\n    plt.show()"
    ],
    [
        "def create_histogram(n, num_swaps, samples=1000):\n    initial_perm = np.random.permutation(n)\n    swap_counts = []\n    for _ in range(samples):\n        perm1 = np.random.permutation(n)\n        perm2 = np.random.permutation(n)\n        swap_count = min_swaps_to_transform(perm1, perm2)\n        swap_counts.append(swap_count)\n    plt.hist(swap_counts, bins=range(max(sw",
        "ap_counts) + 2",
        "), edgecolor='black')\n    plt.xlabel(\"Minimal number of swaps to return to original permutation\")\n    plt.ylabel(\"Frequency\")\n    plt.title(f\"Histogram of minimal swaps for {num_swaps} random swaps on a {n}-element permutation\")\n    plt.show()"
    ],
    [
        "def create_histogram(n, num_swaps, samples=1000):\n    initial_perm = np.random.permutation(n)\n    swap_counts = []\n    for _ in range(samples):\n        perm1 = np.random.permutation(n)\n        perm2 = np.random.permutation(n)\n        swap_count = min_swaps_to_transform(perm1, perm2)\n        swap_counts.append(swap_count)\n    plt.hist(swap_counts, bins=range(max(swap_",
        "counts",
        ") + 2), edgecolor='black')\n    plt.xlabel(\"Minimal number of swaps to return to original permutation\")\n    plt.ylabel(\"Frequency\")\n    plt.title(f\"Histogram of minimal swaps for {num_swaps} random swaps on a {n}-element permutation\")\n    plt.show()"
    ],
    [
        "def create_histogram(n, num_swaps, samples=1000):\n    initial_perm = np.random.permutation(n)\n    swap_counts = []\n    for _ in range(samples):\n        perm1 = np.random.permutation(n)\n        perm2 = np.random.permutation(n)\n        swap_count = min_swaps_to_transform(perm1, perm2)\n        swap_counts.append(swap_count)\n    plt.hist(swap_counts, bins=range(max(swap_counts) + 2), edgecolor='black')\n    plt.xlabel(\"Minimal numb",
        "er of swaps to return to original permutation\"",
        ")\n    plt.ylabel(\"Frequency\")\n    plt.title(f\"Histogram of minimal swaps for {num_swaps} random swaps on a {n}-element permutation\")\n    plt.show()"
    ],
    [
        "def create_histogram(n, num_swaps, samples=1000):\n    initial_perm = np.random.permutation(n)\n    swap_counts = []\n    for _ in range(samples):\n        perm1 = np.random.permutation(n)\n        perm2 = np.random.permutation(n)\n        swap_count = min_swaps_to_transform(perm1, perm2)\n        swap_counts.append(swap_count)\n    plt.hist(swap_counts, bins=range(max(swap_counts) + 2), edgecolor='black')\n    plt.xlabel(\"Minimal number of swaps to return to original permutation\")\n    plt.ylabel(\"Freq",
        "uency\"",
        ")\n    plt.title(f\"Histogram of minimal swaps for {num_swaps} random swaps on a {n}-element permutation\")\n    plt.show()"
    ],
    [
        "def create_histogram(n, num_swaps, samples=1000):\n    initial_perm = np.random.permutation(n)\n    swap_counts = []\n    for _ in range(samples):\n        perm1 = np.random.permutation(n)\n        perm2 = np.random.permutation(n)\n        swap_count = min_swaps_to_transform(perm1, perm2)\n        swap_counts.append(swap_count)\n    plt.hist(swap_counts, bins=range(max(swap_counts) + 2), edgecolor='black')\n    plt.xlabel(\"Minimal number of swaps to return to original permutation\")\n    plt.ylabel(\"Frequency\")\n    plt.title(f\"Histogram of minimal swaps",
        " for {num_swaps} random swaps on a {n}-element permutation\"",
        ")\n    plt.show()"
    ],
    [
        "def colorize_segments(segments):\n    num_segments = np.max(segments) + 1\n    colors = np.random.randint(0, 255, size=(num_segments, 3), dtype=np.uint8)\n    color_image = np.zeros((segme",
        "nts.shape[0], segments.shape[1], 3)",
        ")\n    for i in range(num_segments):\n        color_image[segments == i] = colors[i]\n    return color_image"
    ],
    [
        "def colorize_segments(segments):\n    num_segments = np.max(segments) + 1\n    colors = np.random.randint(0, 255, size=(num_segments, 3), dtype=np.uint8)\n    color_image = np.zeros((segments.shape[0], segments.shape[1], 3), dtype=np.uint8)\n    for i in range(num_se",
        "gments",
        "):\n        color_image[segments == i] = colors[i]\n    return color_image"
    ],
    [
        "def create_color_histogram(image, region_mask, n_bins=25):\n    region = image[region_mask]\n    size = region.shape[0]\n    hist_r, _ = np.histogram(region[",
        ":, 0]",
        ")\n    hist_b, _ = np.histogram(region[:, 1], range=(0.0, 1.0), bins=n_bins)\n    hist_g, _ = np.histogram(region[:, 2], range=(0.0, 1.0), bins=n_bins)\n    return np.concatenate((hist_r, hist_b, hist_g)) / size"
    ],
    [
        "def create_color_histogram(image, region_mask, n_bins=25):\n    region = image[region_mask]\n    size = region.shape[0]\n    hist_r, _ = np.histogram(region[:, 0], range=(0.0, 1.0), bins=n_bins)\n    hist_b, _ = np.histogram(region",
        "[:, 1]",
        ")\n    hist_g, _ = np.histogram(region[:, 2], range=(0.0, 1.0), bins=n_bins)\n    return np.concatenate((hist_r, hist_b, hist_g)) / size"
    ],
    [
        "def create_color_histogram(image, region_mask, n_bins=25):\n    region = image[region_mask]\n    size = region.shape[0]\n    hist_r, _ = np.histogram(region[:, 0], range=(0.0, 1.0), bins=n_bins)\n    hist_b, _ = np.histogram(region[:, 1], range=(0.0, 1.0), bins=n_bins)\n    hist_g, _ = np.histogram(region",
        "[:, 2]",
        ")\n    return np.concatenate((hist_r, hist_b, hist_g)) / size"
    ],
    [
        "def neighbouring_regions(segments_mask, region_mask):\n    mask = region_mask.astype(np.uint8)\n    kernel = np.array([[0, ",
        "1, 0], [1, 1, 1], [0, 1, 0]]",
        ")\n    mask_dilated = cv2.dilate(mask, kernel, iterations=1)\n    return np.unique(segments_mask[(mask_dilated - mask) == 1])"
    ],
    [
        "def neighbouring_regions(segments_mask, region_mask):\n    mask = region_mask.astype(np.uint8)\n    kernel = np.array([[0, 1, 0], [1, 1, 1], [0, 1, 0]], dtype=np.uint8)\n    mask_dilated = cv2.dilate(mask, ",
        "kernel",
        ")\n    return np.unique(segments_mask[(mask_dilated - mask) == 1])"
    ],
    [
        "def initialize_regions(image, mask):\n    regions = {}\n    image = image.astype(np.flo",
        "at32",
        ") / 255.0\n    for id in range(mask.max() + 1):\n        region_mask = mask == id\n        regions[id] = {\n            'mask': region_mask,\n            'neighbors': set(neighbouring_regions(mask, region_mask)),\n            'color_histogram': create_color_histogram(image, region_mask),\n            'size': region_mask.sum()\n        }\n    return regions"
    ],
    [
        "def initialize_regions(image, mask):\n    regions = {}\n    image = image.astype(np.float32) / 255.0\n    for id in range(mask.max",
        "() + 1",
        "):\n        region_mask = mask == id\n        regions[id] = {\n            'mask': region_mask,\n            'neighbors': set(neighbouring_regions(mask, region_mask)),\n            'color_histogram': create_color_histogram(image, region_mask),\n            'size': region_mask.sum()\n        }\n    return regions"
    ],
    [
        "def initialize_regions(image, mask):\n    regions = {}\n    image = image.astype(np.float32) / 255.0\n    for id in range(mask.max() + 1):\n        region_mask = mask == id\n        regions[id] = {\n            'mask': region_mask,\n            'neighbors': set(neighbouring_re",
        "gions(mask, region_mask)",
        "),\n            'color_histogram': create_color_histogram(image, region_mask),\n            'size': region_mask.sum()\n        }\n    return regions"
    ],
    [
        "def initialize_regions(image, mask):\n    regions = {}\n    image = image.astype(np.float32) / 255.0\n    for id in range(mask.max() + 1):\n        region_mask = mask == id\n        regions[id] = {\n            'mask': region_mask,\n            'neighbors': set(neighbouring_regions(mask, ",
        "region_mask",
        ")),\n            'color_histogram': create_color_histogram(image, region_mask),\n            'size': region_mask.sum()\n        }\n    return regions"
    ],
    [
        "def initialize_regions(image, mask):\n    regions = {}\n    image = image.astype(np.float32) / 255.0\n    for id in range(mask.max() + 1):\n        region_mask = mask == id\n        regions[id] = {\n            'mask': region_mask,\n            'neighbors': set(neighbouring_regions(mask, region_mask)),\n            'color_histogram': create_color_histogram(image, ",
        "region_mask",
        "),\n            'size': region_mask.sum()\n        }\n    return regions"
    ],
    [
        "def calculate_similarities(regions):\n    similarities = {}\n    for region_id, region in regions.items():\n        for neighbour_id in region['neighbors']:\n            if region_id < neighbour_id:\n                similarities[(region_id, neighbour_id)] = histogram_intersection(regio",
        "ns[region_id]['color_histogram'], regions[neighbour_id]['color_histogram']",
        ")\n    return similarities"
    ],
    [
        "def merge_regions(mask, regions, similarities, region1_id, region2_id):\n    new_id = min(region1_i",
        "d, region2_id",
        ")\n    region1_info = regions[region1_id]\n    region2_info = regions[region2_id]\n    for neighbour in region1_info['neighbors']:\n        if neighbour < region1_id:\n            del similarities[(neighbour, region1_id)]\n        else:\n            del similarities[(region1_id, neighbour)]\n    similarities[(region1_id, region2_id)] = 0\n    for neighbour in region2_info['neighbors']:\n        if neighbour < region2_id:\n            del similarities[(neighbour, region2_id)]\n        else:\n            del similarities[(region2_id, neighbour)]\n    new_mask = np.logical_or(region1_info['mask'], region2_info['mask'])\n    mask[new_mask] = new_id\n    new_region = {\n        'mask': new_mask,\n        'neighbors': region1_info['neighbors'].union(region2_info['neighbors']),\n        'color_histogram': merge_histograms(region1_info['color_histogram'],\n                                            region1_info['size'],\n                                            region2_info['color_histogram'],\n                                            region2_info['size']),\n        'size': region1_info['size'] + region2_info['size'],\n    }\n    new_region['neighbors'].discard(new_id)\n    new_region['neighbors'].discard(max(region1_id, region2_id))\n    for neighbour in new_region['neighbors']:\n        similarity = histogram_intersection(regions[neighbour]['color_histogram'], regions[new_id]['color_histogram'])\n        if neighbour < new_id:\n            similarities[(neighbour, new_id)] = similarity\n        else:\n            similarities[(new_id, neighbour)] = similarity\n    del regions[region1_id]\n    del regions[region2_id]\n    regions[new_id] = new_region\n    for neighbor in regions[new_id]['neighbors']:\n        regions[neighbor]['neighbors'].discard(max(region1_id, region2_id))\n        regions[neighbor]['neighbors'].add(new_id)"
    ],
    [
        "def merge_regions(mask, regions, similarities, region1_id, region2_id):\n    new_id = min(region1_id, region2_id)\n    region1_info = regions[region1_id]\n    region2_info = regions[region2_id]\n    for neighbour in region1_info['neighbors']:\n        if neighbour < region1_id:\n            del similarities[(neighbour, region1_id)]\n        else:\n            del similarities[(region1_id, neighbour)]\n    similarities[(region1_id, region2_id)] = 0\n    for neighbour in region2_info['neighbors']:\n        if neighbour < region2_id:\n            del similarities[(neighbour, region2_id)]\n        else:\n            del similarities[(region2_id, neighbour)]\n    new_mask = np.logical_or(region1_info['mask'",
        "], region2_info['mask']",
        ")\n    mask[new_mask] = new_id\n    new_region = {\n        'mask': new_mask,\n        'neighbors': region1_info['neighbors'].union(region2_info['neighbors']),\n        'color_histogram': merge_histograms(region1_info['color_histogram'],\n                                            region1_info['size'],\n                                            region2_info['color_histogram'],\n                                            region2_info['size']),\n        'size': region1_info['size'] + region2_info['size'],\n    }\n    new_region['neighbors'].discard(new_id)\n    new_region['neighbors'].discard(max(region1_id, region2_id))\n    for neighbour in new_region['neighbors']:\n        similarity = histogram_intersection(regions[neighbour]['color_histogram'], regions[new_id]['color_histogram'])\n        if neighbour < new_id:\n            similarities[(neighbour, new_id)] = similarity\n        else:\n            similarities[(new_id, neighbour)] = similarity\n    del regions[region1_id]\n    del regions[region2_id]\n    regions[new_id] = new_region\n    for neighbor in regions[new_id]['neighbors']:\n        regions[neighbor]['neighbors'].discard(max(region1_id, region2_id))\n        regions[neighbor]['neighbors'].add(new_id)"
    ],
    [
        "def merge_regions(mask, regions, similarities, region1_id, region2_id):\n    new_id = min(region1_id, region2_id)\n    region1_info = regions[region1_id]\n    region2_info = regions[region2_id]\n    for neighbour in region1_info['neighbors']:\n        if neighbour < region1_id:\n            del similarities[(neighbour, region1_id)]\n        else:\n            del similarities[(region1_id, neighbour)]\n    similarities[(region1_id, region2_id)] = 0\n    for neighbour in region2_info['neighbors']:\n        if neighbour < region2_id:\n            del similarities[(neighbour, region2_id)]\n        else:\n            del similarities[(region2_id, neighbour)]\n    new_mask = np.logical_or(region1_info['mask'], region2_info['mask'])\n    mask[new_mask] = new_id\n    new_region = {\n        'mask': new_mask,\n        'neighbors': region1_info['neighbors'].union(region2_inf",
        "o['neighbors']",
        "),\n        'color_histogram': merge_histograms(region1_info['color_histogram'],\n                                            region1_info['size'],\n                                            region2_info['color_histogram'],\n                                            region2_info['size']),\n        'size': region1_info['size'] + region2_info['size'],\n    }\n    new_region['neighbors'].discard(new_id)\n    new_region['neighbors'].discard(max(region1_id, region2_id))\n    for neighbour in new_region['neighbors']:\n        similarity = histogram_intersection(regions[neighbour]['color_histogram'], regions[new_id]['color_histogram'])\n        if neighbour < new_id:\n            similarities[(neighbour, new_id)] = similarity\n        else:\n            similarities[(new_id, neighbour)] = similarity\n    del regions[region1_id]\n    del regions[region2_id]\n    regions[new_id] = new_region\n    for neighbor in regions[new_id]['neighbors']:\n        regions[neighbor]['neighbors'].discard(max(region1_id, region2_id))\n        regions[neighbor]['neighbors'].add(new_id)"
    ],
    [
        "def merge_regions(mask, regions, similarities, region1_id, region2_id):\n    new_id = min(region1_id, region2_id)\n    region1_info = regions[region1_id]\n    region2_info = regions[region2_id]\n    for neighbour in region1_info['neighbors']:\n        if neighbour < region1_id:\n            del similarities[(neighbour, region1_id)]\n        else:\n            del similarities[(region1_id, neighbour)]\n    similarities[(region1_id, region2_id)] = 0\n    for neighbour in region2_info['neighbors']:\n        if neighbour < region2_id:\n            del similarities[(neighbour, region2_id)]\n        else:\n            del similarities[(region2_id, neighbour)]\n    new_mask = np.logical_or(region1_info['mask'], region2_info['mask'])\n    mask[new_mask] = new_id\n    new_region = {\n        'mask': new_mask,\n        'neighbors': region1_info['neighbors'].union(region2_info['neighbors']),\n        'color_histogram': merge_histograms(region1_info['color_histo",
        "gram'], region1_info['size'], region2_info['color_histogram'], region2_info['size']",
        "),\n        'size': region1_info['size'] + region2_info['size'],\n    }\n    new_region['neighbors'].discard(new_id)\n    new_region['neighbors'].discard(max(region1_id, region2_id))\n    for neighbour in new_region['neighbors']:\n        similarity = histogram_intersection(regions[neighbour]['color_histogram'], regions[new_id]['color_histogram'])\n        if neighbour < new_id:\n            similarities[(neighbour, new_id)] = similarity\n        else:\n            similarities[(new_id, neighbour)] = similarity\n    del regions[region1_id]\n    del regions[region2_id]\n    regions[new_id] = new_region\n    for neighbor in regions[new_id]['neighbors']:\n        regions[neighbor]['neighbors'].discard(max(region1_id, region2_id))\n        regions[neighbor]['neighbors'].add(new_id)"
    ],
    [
        "def merge_regions(mask, regions, similarities, region1_id, region2_id):\n    new_id = min(region1_id, region2_id)\n    region1_info = regions[region1_id]\n    region2_info = regions[region2_id]\n    for neighbour in region1_info['neighbors']:\n        if neighbour < region1_id:\n            del similarities[(neighbour, region1_id)]\n        else:\n            del similarities[(region1_id, neighbour)]\n    similarities[(region1_id, region2_id)] = 0\n    for neighbour in region2_info['neighbors']:\n        if neighbour < region2_id:\n            del similarities[(neighbour, region2_id)]\n        else:\n            del similarities[(region2_id, neighbour)]\n    new_mask = np.logical_or(region1_info['mask'], region2_info['mask'])\n    mask[new_mask] = new_id\n    new_region = {\n        'mask': new_mask,\n        'neighbors': region1_info['neighbors'].union(region2_info['neighbors']),\n        'color_histogram': merge_histograms(region1_info['color_histogram'],\n                                            region1_info['size'],\n                                            region2_info['color_histogram'],\n                                            region2_info['size']),\n        'size': region1_info['size'] + region2_info['size'],\n    }\n    new_region['neighbors'].discard(new_id)\n    new_region['neighbors'].discard(max(r",
        "egion1_id, region2_id)",
        ")\n    for neighbour in new_region['neighbors']:\n        similarity = histogram_intersection(regions[neighbour]['color_histogram'], regions[new_id]['color_histogram'])\n        if neighbour < new_id:\n            similarities[(neighbour, new_id)] = similarity\n        else:\n            similarities[(new_id, neighbour)] = similarity\n    del regions[region1_id]\n    del regions[region2_id]\n    regions[new_id] = new_region\n    for neighbor in regions[new_id]['neighbors']:\n        regions[neighbor]['neighbors'].discard(max(region1_id, region2_id))\n        regions[neighbor]['neighbors'].add(new_id)"
    ],
    [
        "def merge_regions(mask, regions, similarities, region1_id, region2_id):\n    new_id = min(region1_id, region2_id)\n    region1_info = regions[region1_id]\n    region2_info = regions[region2_id]\n    for neighbour in region1_info['neighbors']:\n        if neighbour < region1_id:\n            del similarities[(neighbour, region1_id)]\n        else:\n            del similarities[(region1_id, neighbour)]\n    similarities[(region1_id, region2_id)] = 0\n    for neighbour in region2_info['neighbors']:\n        if neighbour < region2_id:\n            del similarities[(neighbour, region2_id)]\n        else:\n            del similarities[(region2_id, neighbour)]\n    new_mask = np.logical_or(region1_info['mask'], region2_info['mask'])\n    mask[new_mask] = new_id\n    new_region = {\n        'mask': new_mask,\n        'neighbors': region1_info['neighbors'].union(region2_info['neighbors']),\n        'color_histogram': merge_histograms(region1_info['color_histogram'],\n                                            region1_info['size'],\n                                            region2_info['color_histogram'],\n                                            region2_info['size']),\n        'size': region1_info['size'] + region2_info['size'],\n    }\n    new_region['neighbors'].discard(new_id)\n    new_region['neighbors'].discard(max(region1_id",
        ", region2_id",
        "))\n    for neighbour in new_region['neighbors']:\n        similarity = histogram_intersection(regions[neighbour]['color_histogram'], regions[new_id]['color_histogram'])\n        if neighbour < new_id:\n            similarities[(neighbour, new_id)] = similarity\n        else:\n            similarities[(new_id, neighbour)] = similarity\n    del regions[region1_id]\n    del regions[region2_id]\n    regions[new_id] = new_region\n    for neighbor in regions[new_id]['neighbors']:\n        regions[neighbor]['neighbors'].discard(max(region1_id, region2_id))\n        regions[neighbor]['neighbors'].add(new_id)"
    ],
    [
        "def merge_regions(mask, regions, similarities, region1_id, region2_id):\n    new_id = min(region1_id, region2_id)\n    region1_info = regions[region1_id]\n    region2_info = regions[region2_id]\n    for neighbour in region1_info['neighbors']:\n        if neighbour < region1_id:\n            del similarities[(neighbour, region1_id)]\n        else:\n            del similarities[(region1_id, neighbour)]\n    similarities[(region1_id, region2_id)] = 0\n    for neighbour in region2_info['neighbors']:\n        if neighbour < region2_id:\n            del similarities[(neighbour, region2_id)]\n        else:\n            del similarities[(region2_id, neighbour)]\n    new_mask = np.logical_or(region1_info['mask'], region2_info['mask'])\n    mask[new_mask] = new_id\n    new_region = {\n        'mask': new_mask,\n        'neighbors': region1_info['neighbors'].union(region2_info['neighbors']),\n        'color_histogram': merge_histograms(region1_info['color_histogram'],\n                                            region1_info['size'],\n                                            region2_info['color_histogram'],\n                                            region2_info['size']),\n        'size': region1_info['size'] + region2_info['size'],\n    }\n    new_region['neighbors'].discard(new_id)\n    new_region['neighbors'].discard(max(region1_id, region2_id))\n    for neighbour in new_region['neighbors']:\n        similarity = histogram_intersection(regions[neighbour]['color_hi",
        "stogram'], regions[new_id]['color_histogram']",
        ")\n        if neighbour < new_id:\n            similarities[(neighbour, new_id)] = similarity\n        else:\n            similarities[(new_id, neighbour)] = similarity\n    del regions[region1_id]\n    del regions[region2_id]\n    regions[new_id] = new_region\n    for neighbor in regions[new_id]['neighbors']:\n        regions[neighbor]['neighbors'].discard(max(region1_id, region2_id))\n        regions[neighbor]['neighbors'].add(new_id)"
    ],
    [
        "def merge_regions(mask, regions, similarities, region1_id, region2_id):\n    new_id = min(region1_id, region2_id)\n    region1_info = regions[region1_id]\n    region2_info = regions[region2_id]\n    for neighbour in region1_info['neighbors']:\n        if neighbour < region1_id:\n            del similarities[(neighbour, region1_id)]\n        else:\n            del similarities[(region1_id, neighbour)]\n    similarities[(region1_id, region2_id)] = 0\n    for neighbour in region2_info['neighbors']:\n        if neighbour < region2_id:\n            del similarities[(neighbour, region2_id)]\n        else:\n            del similarities[(region2_id, neighbour)]\n    new_mask = np.logical_or(region1_info['mask'], region2_info['mask'])\n    mask[new_mask] = new_id\n    new_region = {\n        'mask': new_mask,\n        'neighbors': region1_info['neighbors'].union(region2_info['neighbors']),\n        'color_histogram': merge_histograms(region1_info['color_histogram'],\n                                            region1_info['size'],\n                                            region2_info['color_histogram'],\n                                            region2_info['size']),\n        'size': region1_info['size'] + region2_info['size'],\n    }\n    new_region['neighbors'].discard(new_id)\n    new_region['neighbors'].discard(max(region1_id, region2_id))\n    for neighbour in new_region['neighbors']:\n        similarity = histogram_intersection(regions[neighbour]['color_histogram'], regions[new_id]['color_histogram'])\n        if neighbour < new_id:\n            similarities[(neighbour, new_id)] = similarity\n        else:\n            similarities[(new_id, neighbour)] = similarity\n    del regions[region1_id]\n    del regions[region2_id]\n    regions[new_id] = new_region\n    for neighbor in regions[new_id]['neighbors']:\n        regions[neighbor]['neighbors'].discard(max(region1_",
        "id, region2_id)",
        ")\n        regions[neighbor]['neighbors'].add(new_id)"
    ],
    [
        "def merge_regions(mask, regions, similarities, region1_id, region2_id):\n    new_id = min(region1_id, region2_id)\n    region1_info = regions[region1_id]\n    region2_info = regions[region2_id]\n    for neighbour in region1_info['neighbors']:\n        if neighbour < region1_id:\n            del similarities[(neighbour, region1_id)]\n        else:\n            del similarities[(region1_id, neighbour)]\n    similarities[(region1_id, region2_id)] = 0\n    for neighbour in region2_info['neighbors']:\n        if neighbour < region2_id:\n            del similarities[(neighbour, region2_id)]\n        else:\n            del similarities[(region2_id, neighbour)]\n    new_mask = np.logical_or(region1_info['mask'], region2_info['mask'])\n    mask[new_mask] = new_id\n    new_region = {\n        'mask': new_mask,\n        'neighbors': region1_info['neighbors'].union(region2_info['neighbors']),\n        'color_histogram': merge_histograms(region1_info['color_histogram'],\n                                            region1_info['size'],\n                                            region2_info['color_histogram'],\n                                            region2_info['size']),\n        'size': region1_info['size'] + region2_info['size'],\n    }\n    new_region['neighbors'].discard(new_id)\n    new_region['neighbors'].discard(max(region1_id, region2_id))\n    for neighbour in new_region['neighbors']:\n        similarity = histogram_intersection(regions[neighbour]['color_histogram'], regions[new_id]['color_histogram'])\n        if neighbour < new_id:\n            similarities[(neighbour, new_id)] = similarity\n        else:\n            similarities[(new_id, neighbour)] = similarity\n    del regions[region1_id]\n    del regions[region2_id]\n    regions[new_id] = new_region\n    for neighbor in regions[new_id]['neighbors']:\n        regions[neighbor]['neighbors'].discard(max(region1",
        "_id, region2_id",
        "))\n        regions[neighbor]['neighbors'].add(new_id)"
    ],
    [
        "def strip_comments(code):\n    string_pattern = r\"(\\\"\\\"\\\".*?\\\"\\\"\\\"|'''.*?'''|\\\".*?\\\"|'.*?'|r\\\".*?\\\"|r'.*?')\"\n    comment_pattern = r\"#.*(?=\\n|$)\"\n    strings = {} \n    def string_replacer(match):\n        placeholder = f\"{{{{STR_{len(strings)}}}}}\"\n        strings[placeholder] = match.group(0)\n        return placeholder\n    code_without_strings = re.sub(string_p",
        "attern, string_replacer, code",
        ")\n    code_without_comments = re.sub(comment_pattern, \"\", code_without_strings)\n    for placeholder, original in strings.items():\n        code_without_comments = code_without_comments.replace(placeholder, original)\n    return code_without_comments"
    ],
    [
        "def strip_comments(code):\n    string_pattern = r\"(\\\"\\\"\\\".*?\\\"\\\"\\\"|'''.*?'''|\\\".*?\\\"|'.*?'|r\\\".*?\\\"|r'.*?')\"\n    comment_pattern = r\"#.*(?=\\n|$)\"\n    strings = {} \n    def string_replacer(match):\n        placeholder = f\"{{{{STR_{len(strings)}}}}}\"\n        strings[placeholder] = match.group(0)\n        return placeholder\n    code_without_strings = re.sub(string_pattern, string_replacer, code, flags=re.DOTALL)\n    code_without_comments = re.sub(comment_pattern, \"\",",
        " code_without_strings",
        ")\n    for placeholder, original in strings.items():\n        code_without_comments = code_without_comments.replace(placeholder, original)\n    return code_without_comments"
    ],
    [
        "def strip_comments(code):\n    string_pattern = r\"(\\\"\\\"\\\".*?\\\"\\\"\\\"|'''.*?'''|\\\".*?\\\"|'.*?'|r\\\".*?\\\"|r'.*?')\"\n    comment_pattern = r\"#.*(?=\\n|$)\"\n    strings = {} \n    def string_replacer(match):\n        placeholder = f\"{{{{STR_{len(strings)}}}}}\"\n        strings[placeholder] = match.group(0)\n        return placeholder\n    code_without_strings = re.sub(string_pattern, string_replacer, code, flags=re.DOTALL)\n    code_without_comments = re.sub(comment_pattern, \"\", code_without_strings)\n    for placeholder, original in strings.items():\n        code_without_comments = code_without_comments.replace(placeh",
        "older, original",
        ")\n    return code_without_comments"
    ],
    [
        "def strip_empty_lines(code):\n    lines = code.splitlines()\n    stripped_lines = [line for line in lines if line.strip()]\n    stripped_code = '\\n'.join(strippe",
        "d_lines",
        ")\n    return stripped_code"
    ],
    [
        "def visit_FunctionDef(self, node):\n        function_source = ast.get_source_segment(self.",
        "code, node",
        ")\n        self.functions.append(function_source)\n        self.generic_visit(node)"
    ],
    [
        "def visit_FunctionDef(self, node):\n        function_source = ast.get_source_segment(self.code, node)\n        self.functions.append(function",
        "_source",
        ")\n        self.generic_visit(node)"
    ],
    [
        "def visit_ClassDef(self, node):\n        class_source = ast.get_source_segment(self.co",
        "de, node",
        ")\n        self.classes.append(class_source)\n        self.generic_visit(node)"
    ],
    [
        "def visit_ClassDef(self, node):\n        class_source = ast.get_source_segment(self.code, node)\n        self.classes.append(class",
        "_source",
        ")\n        self.generic_visit(node)"
    ],
    [
        "def visit_Call(self, node):\n        func_name = None\n        if isinstance(node.fu",
        "nc, ast.Name",
        "):\n            func_name = node.func.id\n        elif isinstance(node.func, ast.Attribute):\n            parts = []\n            current = node.func\n            while isinstance(current, ast.Attribute):\n                parts.insert(0, current.attr)\n                current = current.value\n            if isinstance(current, ast.Name):\n                parts.insert(0, current.id)\n            func_name = \".\".join(parts)\n        args = [ast.get_source_segment(self.source_code, arg) for arg in node.args]\n        if func_name:\n            self.function_calls.append({\n                \"function\": func_name,\n                \"arguments\": args,\n                \"start_line\": node.lineno,\n                \"end_line\": node.end_lineno,\n                \"col_offset\": node.col_offset,\n                \"end_col_offset\": node.end_col_offset\n            })\n        self.generic_visit(node)"
    ],
    [
        "def visit_Call(self, node):\n        func_name = None\n        if isinstance(node.func, ast.Name):\n            func_name = node.func.id\n        elif isinstance(node.fu",
        "nc, ast.Attribute",
        "):\n            parts = []\n            current = node.func\n            while isinstance(current, ast.Attribute):\n                parts.insert(0, current.attr)\n                current = current.value\n            if isinstance(current, ast.Name):\n                parts.insert(0, current.id)\n            func_name = \".\".join(parts)\n        args = [ast.get_source_segment(self.source_code, arg) for arg in node.args]\n        if func_name:\n            self.function_calls.append({\n                \"function\": func_name,\n                \"arguments\": args,\n                \"start_line\": node.lineno,\n                \"end_line\": node.end_lineno,\n                \"col_offset\": node.col_offset,\n                \"end_col_offset\": node.end_col_offset\n            })\n        self.generic_visit(node)"
    ],
    [
        "def visit_Call(self, node):\n        func_name = None\n        if isinstance(node.func, ast.Name):\n            func_name = node.func.id\n        elif isinstance(node.func, ast.Attribute):\n            parts = []\n            current = node.func\n            while isinstance(curre",
        "nt, ast.Attribute",
        "):\n                parts.insert(0, current.attr)\n                current = current.value\n            if isinstance(current, ast.Name):\n                parts.insert(0, current.id)\n            func_name = \".\".join(parts)\n        args = [ast.get_source_segment(self.source_code, arg) for arg in node.args]\n        if func_name:\n            self.function_calls.append({\n                \"function\": func_name,\n                \"arguments\": args,\n                \"start_line\": node.lineno,\n                \"end_line\": node.end_lineno,\n                \"col_offset\": node.col_offset,\n                \"end_col_offset\": node.end_col_offset\n            })\n        self.generic_visit(node)"
    ],
    [
        "def visit_Call(self, node):\n        func_name = None\n        if isinstance(node.func, ast.Name):\n            func_name = node.func.id\n        elif isinstance(node.func, ast.Attribute):\n            parts = []\n            current = node.func\n            while isinstance(current, ast.Attribute):\n                parts.insert(0, cu",
        "rrent.attr",
        ")\n                current = current.value\n            if isinstance(current, ast.Name):\n                parts.insert(0, current.id)\n            func_name = \".\".join(parts)\n        args = [ast.get_source_segment(self.source_code, arg) for arg in node.args]\n        if func_name:\n            self.function_calls.append({\n                \"function\": func_name,\n                \"arguments\": args,\n                \"start_line\": node.lineno,\n                \"end_line\": node.end_lineno,\n                \"col_offset\": node.col_offset,\n                \"end_col_offset\": node.end_col_offset\n            })\n        self.generic_visit(node)"
    ],
    [
        "def visit_Call(self, node):\n        func_name = None\n        if isinstance(node.func, ast.Name):\n            func_name = node.func.id\n        elif isinstance(node.func, ast.Attribute):\n            parts = []\n            current = node.func\n            while isinstance(current, ast.Attribute):\n                parts.insert(0, current.attr)\n                current = current.value\n            if isinstance(current",
        ", ast.Name",
        "):\n                parts.insert(0, current.id)\n            func_name = \".\".join(parts)\n        args = [ast.get_source_segment(self.source_code, arg) for arg in node.args]\n        if func_name:\n            self.function_calls.append({\n                \"function\": func_name,\n                \"arguments\": args,\n                \"start_line\": node.lineno,\n                \"end_line\": node.end_lineno,\n                \"col_offset\": node.col_offset,\n                \"end_col_offset\": node.end_col_offset\n            })\n        self.generic_visit(node)"
    ],
    [
        "def visit_Call(self, node):\n        func_name = None\n        if isinstance(node.func, ast.Name):\n            func_name = node.func.id\n        elif isinstance(node.func, ast.Attribute):\n            parts = []\n            current = node.func\n            while isinstance(current, ast.Attribute):\n                parts.insert(0, current.attr)\n                current = current.value\n            if isinstance(current, ast.Name):\n                parts.insert(0, cur",
        "rent.id",
        ")\n            func_name = \".\".join(parts)\n        args = [ast.get_source_segment(self.source_code, arg) for arg in node.args]\n        if func_name:\n            self.function_calls.append({\n                \"function\": func_name,\n                \"arguments\": args,\n                \"start_line\": node.lineno,\n                \"end_line\": node.end_lineno,\n                \"col_offset\": node.col_offset,\n                \"end_col_offset\": node.end_col_offset\n            })\n        self.generic_visit(node)"
    ],
    [
        "def visit_Call(self, node):\n        func_name = None\n        if isinstance(node.func, ast.Name):\n            func_name = node.func.id\n        elif isinstance(node.func, ast.Attribute):\n            parts = []\n            current = node.func\n            while isinstance(current, ast.Attribute):\n                parts.insert(0, current.attr)\n                current = current.value\n            if isinstance(current, ast.Name):\n                parts.insert(0, current.id)\n            func_name = \".\".join(parts)\n        args = [ast.get_source_segment(self.source",
        "_code, arg",
        ") for arg in node.args]\n        if func_name:\n            self.function_calls.append({\n                \"function\": func_name,\n                \"arguments\": args,\n                \"start_line\": node.lineno,\n                \"end_line\": node.end_lineno,\n                \"col_offset\": node.col_offset,\n                \"end_col_offset\": node.end_col_offset\n            })\n        self.generic_visit(node)"
    ],
    [
        "def visit_Call(self, node):\n        func_name = None\n        if isinstance(node.func, ast.Name):\n            func_name = node.func.id\n        elif isinstance(node.func, ast.Attribute):\n            parts = []\n            current = node.func\n            while isinstance(current, ast.Attribute):\n                parts.insert(0, current.attr)\n                current = current.value\n            if isinstance(current, ast.Name):\n                parts.insert(0, current.id)\n            func_name = \".\".join(parts)\n        args = [ast.get_source_segment(self.source_code, arg) for arg in node.args]\n        if func_name:\n            self.function_calls.append({\n                \"function\": func_name,\n                ",
        "\"arguments\": args,\n                \"start_line\": node.lineno,\n                \"end_line\": node.end_lineno,\n                \"col_offset\": node.col_offset,\n                \"end_col_offset\": node.end_col_offset\n            }",
        ")\n        self.generic_visit(node)"
    ],
    [
        "def find_function_calls_with_args(source_code):\n    tree = ast.parse(source",
        "_code",
        ")\n    visitor = FunctionCallVisitor(source_code)\n    visitor.visit(tree)\n    return visitor.function_calls"
    ],
    [
        "def find_function_calls_with_args(source_code):\n    tree = ast.parse(source_code)\n    visitor = FunctionCallVisitor(sourc",
        "e_code",
        ")\n    visitor.visit(tree)\n    return visitor.function_calls"
    ],
    [
        "def collect_assignment_info(self, node):\n        if isinstance(node, ",
        "ast.Assign",
        "):\n            targets = node.targets\n            value = node.value\n        elif isinstance(node, ast.AugAssign):\n            targets = [node.target]\n            value = node.value\n        elif isinstance(node, ast.AnnAssign):\n            targets = [node.target]\n            value = node.value\n        else:\n            return\n        start_line = node.lineno\n        end_line = node.end_lineno\n        end_col = node.end_col_offset\n        start_col = value.col_offset if hasattr(value, 'col_offset') else 0\n        for target in targets:\n            assignment_info = {\n                'start_line': start_line,\n                'start_col': start_col,\n                'end_line': end_line,\n                'end_col': end_col,\n            }\n            self.assignments.append(assignment_info)"
    ],
    [
        "def collect_assignment_info(self, node):\n        if isinstance(node, ast.Assign):\n            targets = node.targets\n            value = node.value\n        elif isinstance(node, a",
        "st.AugAssign",
        "):\n            targets = [node.target]\n            value = node.value\n        elif isinstance(node, ast.AnnAssign):\n            targets = [node.target]\n            value = node.value\n        else:\n            return\n        start_line = node.lineno\n        end_line = node.end_lineno\n        end_col = node.end_col_offset\n        start_col = value.col_offset if hasattr(value, 'col_offset') else 0\n        for target in targets:\n            assignment_info = {\n                'start_line': start_line,\n                'start_col': start_col,\n                'end_line': end_line,\n                'end_col': end_col,\n            }\n            self.assignments.append(assignment_info)"
    ],
    [
        "def collect_assignment_info(self, node):\n        if isinstance(node, ast.Assign):\n            targets = node.targets\n            value = node.value\n        elif isinstance(node, ast.AugAssign):\n            targets = [node.target]\n            value = node.value\n        elif isinstance(node, as",
        "t.AnnAssign",
        "):\n            targets = [node.target]\n            value = node.value\n        else:\n            return\n        start_line = node.lineno\n        end_line = node.end_lineno\n        end_col = node.end_col_offset\n        start_col = value.col_offset if hasattr(value, 'col_offset') else 0\n        for target in targets:\n            assignment_info = {\n                'start_line': start_line,\n                'start_col': start_col,\n                'end_line': end_line,\n                'end_col': end_col,\n            }\n            self.assignments.append(assignment_info)"
    ],
    [
        "def collect_assignment_info(self, node):\n        if isinstance(node, ast.Assign):\n            targets = node.targets\n            value = node.value\n        elif isinstance(node, ast.AugAssign):\n            targets = [node.target]\n            value = node.value\n        elif isinstance(node, ast.AnnAssign):\n            targets = [node.target]\n            value = node.value\n        else:\n            return\n        start_line = node.lineno\n        end_line = node.end_lineno\n        end_col = node.end_col_offset\n        start_col = value.col_offset if hasattr(value, '",
        "col_offset'",
        ") else 0\n        for target in targets:\n            assignment_info = {\n                'start_line': start_line,\n                'start_col': start_col,\n                'end_line': end_line,\n                'end_col': end_col,\n            }\n            self.assignments.append(assignment_info)"
    ],
    [
        "def find_assignments(code):\n    tree = ast.parse(code)\n    visitor = AssignmentVisitor()\n    visitor.visit(tree)\n    assignments_positions = []\n    for assignment in visitor.assignments:\n        assignments_positions.append(((assignment['start_line'], assignment['start_col",
        "']), (assignment['end_line'], assignment['end_col']))",
        ")\n    return list(set(assignments_positions))"
    ],
    [
        "def find_conditions(code):\n    tree = ast.parse(code)\n    conditions = []\n    for node in ast.walk(tree):\n        if isinstance(node, (ast.",
        "If, ast.While)",
        "):\n            condition = ast.get_source_segment(code, node.test)\n            start_line = node.test.lineno\n            start_col = node.test.col_offset\n            end_line = node.test.end_lineno\n            end_col = node.test.end_col_offset\n            conditions.append(((start_line, start_col), (end_line, end_col)))\n        elif isinstance(node, ast.Assert):\n            condition = ast.get_source_segment(code, node.test)\n            start_line = node.test.lineno\n            start_col = node.test.col_offset\n            end_line = node.test.end_lineno\n            end_col = node.test.end_col_offset\n            conditions.append(((start_line, start_col), (end_line, end_col)))\n        elif isinstance(node, ast.Expr) and isinstance(node.value, ast.IfExp):\n            condition = ast.get_source_segment(code, node.value.test)\n            start_line = node.value.test.lineno\n            start_col = node.value.test.col_offset\n            end_line = node.value.test.end_lineno\n            end_col = node.value.test.end_col_offset\n            conditions.append(((start_line, start_col), (end_line, end_col)))\n    return conditions"
    ],
    [
        "def find_conditions(code):\n    tree = ast.parse(code)\n    conditions = []\n    for node in ast.walk(tree):\n        if isinstance(node, (ast.If, ast.While)):\n            condition = ast.get_source_segment(code, no",
        "de.test",
        ")\n            start_line = node.test.lineno\n            start_col = node.test.col_offset\n            end_line = node.test.end_lineno\n            end_col = node.test.end_col_offset\n            conditions.append(((start_line, start_col), (end_line, end_col)))\n        elif isinstance(node, ast.Assert):\n            condition = ast.get_source_segment(code, node.test)\n            start_line = node.test.lineno\n            start_col = node.test.col_offset\n            end_line = node.test.end_lineno\n            end_col = node.test.end_col_offset\n            conditions.append(((start_line, start_col), (end_line, end_col)))\n        elif isinstance(node, ast.Expr) and isinstance(node.value, ast.IfExp):\n            condition = ast.get_source_segment(code, node.value.test)\n            start_line = node.value.test.lineno\n            start_col = node.value.test.col_offset\n            end_line = node.value.test.end_lineno\n            end_col = node.value.test.end_col_offset\n            conditions.append(((start_line, start_col), (end_line, end_col)))\n    return conditions"
    ],
    [
        "def find_conditions(code):\n    tree = ast.parse(code)\n    conditions = []\n    for node in ast.walk(tree):\n        if isinstance(node, (ast.If, ast.While)):\n            condition = ast.get_source_segment(code, node.test)\n            start_line = node.test.lineno\n            start_col = node.test.col_offset\n            end_line = node.test.end_lineno\n            end_col = node.test.end_col_offset\n            conditions.append(((start_line, start_col",
        "), (end_line, end_col))",
        ")\n        elif isinstance(node, ast.Assert):\n            condition = ast.get_source_segment(code, node.test)\n            start_line = node.test.lineno\n            start_col = node.test.col_offset\n            end_line = node.test.end_lineno\n            end_col = node.test.end_col_offset\n            conditions.append(((start_line, start_col), (end_line, end_col)))\n        elif isinstance(node, ast.Expr) and isinstance(node.value, ast.IfExp):\n            condition = ast.get_source_segment(code, node.value.test)\n            start_line = node.value.test.lineno\n            start_col = node.value.test.col_offset\n            end_line = node.value.test.end_lineno\n            end_col = node.value.test.end_col_offset\n            conditions.append(((start_line, start_col), (end_line, end_col)))\n    return conditions"
    ],
    [
        "def find_conditions(code):\n    tree = ast.parse(code)\n    conditions = []\n    for node in ast.walk(tree):\n        if isinstance(node, (ast.If, ast.While)):\n            condition = ast.get_source_segment(code, node.test)\n            start_line = node.test.lineno\n            start_col = node.test.col_offset\n            end_line = node.test.end_lineno\n            end_col = node.test.end_col_offset\n            conditions.append(((start_line, start_col), (end_line, end_col)))\n        elif isinstance(node, ast",
        ".Assert",
        "):\n            condition = ast.get_source_segment(code, node.test)\n            start_line = node.test.lineno\n            start_col = node.test.col_offset\n            end_line = node.test.end_lineno\n            end_col = node.test.end_col_offset\n            conditions.append(((start_line, start_col), (end_line, end_col)))\n        elif isinstance(node, ast.Expr) and isinstance(node.value, ast.IfExp):\n            condition = ast.get_source_segment(code, node.value.test)\n            start_line = node.value.test.lineno\n            start_col = node.value.test.col_offset\n            end_line = node.value.test.end_lineno\n            end_col = node.value.test.end_col_offset\n            conditions.append(((start_line, start_col), (end_line, end_col)))\n    return conditions"
    ],
    [
        "def find_conditions(code):\n    tree = ast.parse(code)\n    conditions = []\n    for node in ast.walk(tree):\n        if isinstance(node, (ast.If, ast.While)):\n            condition = ast.get_source_segment(code, node.test)\n            start_line = node.test.lineno\n            start_col = node.test.col_offset\n            end_line = node.test.end_lineno\n            end_col = node.test.end_col_offset\n            conditions.append(((start_line, start_col), (end_line, end_col)))\n        elif isinstance(node, ast.Assert):\n            condition = ast.get_source_segment(code,",
        " node.test",
        ")\n            start_line = node.test.lineno\n            start_col = node.test.col_offset\n            end_line = node.test.end_lineno\n            end_col = node.test.end_col_offset\n            conditions.append(((start_line, start_col), (end_line, end_col)))\n        elif isinstance(node, ast.Expr) and isinstance(node.value, ast.IfExp):\n            condition = ast.get_source_segment(code, node.value.test)\n            start_line = node.value.test.lineno\n            start_col = node.value.test.col_offset\n            end_line = node.value.test.end_lineno\n            end_col = node.value.test.end_col_offset\n            conditions.append(((start_line, start_col), (end_line, end_col)))\n    return conditions"
    ],
    [
        "def find_conditions(code):\n    tree = ast.parse(code)\n    conditions = []\n    for node in ast.walk(tree):\n        if isinstance(node, (ast.If, ast.While)):\n            condition = ast.get_source_segment(code, node.test)\n            start_line = node.test.lineno\n            start_col = node.test.col_offset\n            end_line = node.test.end_lineno\n            end_col = node.test.end_col_offset\n            conditions.append(((start_line, start_col), (end_line, end_col)))\n        elif isinstance(node, ast.Assert):\n            condition = ast.get_source_segment(code, node.test)\n            start_line = node.test.lineno\n            start_col = node.test.col_offset\n            end_line = node.test.end_lineno\n            end_col = node.test.end_col_offset\n            conditions.append(((start_line, s",
        "tart_col), (end_line, end_col))",
        ")\n        elif isinstance(node, ast.Expr) and isinstance(node.value, ast.IfExp):\n            condition = ast.get_source_segment(code, node.value.test)\n            start_line = node.value.test.lineno\n            start_col = node.value.test.col_offset\n            end_line = node.value.test.end_lineno\n            end_col = node.value.test.end_col_offset\n            conditions.append(((start_line, start_col), (end_line, end_col)))\n    return conditions"
    ],
    [
        "def find_conditions(code):\n    tree = ast.parse(code)\n    conditions = []\n    for node in ast.walk(tree):\n        if isinstance(node, (ast.If, ast.While)):\n            condition = ast.get_source_segment(code, node.test)\n            start_line = node.test.lineno\n            start_col = node.test.col_offset\n            end_line = node.test.end_lineno\n            end_col = node.test.end_col_offset\n            conditions.append(((start_line, start_col), (end_line, end_col)))\n        elif isinstance(node, ast.Assert):\n            condition = ast.get_source_segment(code, node.test)\n            start_line = node.test.lineno\n            start_col = node.test.col_offset\n            end_line = node.test.end_lineno\n            end_col = node.test.end_col_offset\n            conditions.append(((start_line, start_col), (end_line, end_col)))\n        elif isinstance(node, a",
        "st.Expr",
        ") and isinstance(node.value, ast.IfExp):\n            condition = ast.get_source_segment(code, node.value.test)\n            start_line = node.value.test.lineno\n            start_col = node.value.test.col_offset\n            end_line = node.value.test.end_lineno\n            end_col = node.value.test.end_col_offset\n            conditions.append(((start_line, start_col), (end_line, end_col)))\n    return conditions"
    ],
    [
        "def find_conditions(code):\n    tree = ast.parse(code)\n    conditions = []\n    for node in ast.walk(tree):\n        if isinstance(node, (ast.If, ast.While)):\n            condition = ast.get_source_segment(code, node.test)\n            start_line = node.test.lineno\n            start_col = node.test.col_offset\n            end_line = node.test.end_lineno\n            end_col = node.test.end_col_offset\n            conditions.append(((start_line, start_col), (end_line, end_col)))\n        elif isinstance(node, ast.Assert):\n            condition = ast.get_source_segment(code, node.test)\n            start_line = node.test.lineno\n            start_col = node.test.col_offset\n            end_line = node.test.end_lineno\n            end_col = node.test.end_col_offset\n            conditions.append(((start_line, start_col), (end_line, end_col)))\n        elif isinstance(node, ast.Expr) and isinstance(node.val",
        "ue, ast.IfExp",
        "):\n            condition = ast.get_source_segment(code, node.value.test)\n            start_line = node.value.test.lineno\n            start_col = node.value.test.col_offset\n            end_line = node.value.test.end_lineno\n            end_col = node.value.test.end_col_offset\n            conditions.append(((start_line, start_col), (end_line, end_col)))\n    return conditions"
    ],
    [
        "def find_conditions(code):\n    tree = ast.parse(code)\n    conditions = []\n    for node in ast.walk(tree):\n        if isinstance(node, (ast.If, ast.While)):\n            condition = ast.get_source_segment(code, node.test)\n            start_line = node.test.lineno\n            start_col = node.test.col_offset\n            end_line = node.test.end_lineno\n            end_col = node.test.end_col_offset\n            conditions.append(((start_line, start_col), (end_line, end_col)))\n        elif isinstance(node, ast.Assert):\n            condition = ast.get_source_segment(code, node.test)\n            start_line = node.test.lineno\n            start_col = node.test.col_offset\n            end_line = node.test.end_lineno\n            end_col = node.test.end_col_offset\n            conditions.append(((start_line, start_col), (end_line, end_col)))\n        elif isinstance(node, ast.Expr) and isinstance(node.value, ast.IfExp):\n            condition = ast.get_source_segment(code,",
        " node.value.test",
        ")\n            start_line = node.value.test.lineno\n            start_col = node.value.test.col_offset\n            end_line = node.value.test.end_lineno\n            end_col = node.value.test.end_col_offset\n            conditions.append(((start_line, start_col), (end_line, end_col)))\n    return conditions"
    ],
    [
        "def find_conditions(code):\n    tree = ast.parse(code)\n    conditions = []\n    for node in ast.walk(tree):\n        if isinstance(node, (ast.If, ast.While)):\n            condition = ast.get_source_segment(code, node.test)\n            start_line = node.test.lineno\n            start_col = node.test.col_offset\n            end_line = node.test.end_lineno\n            end_col = node.test.end_col_offset\n            conditions.append(((start_line, start_col), (end_line, end_col)))\n        elif isinstance(node, ast.Assert):\n            condition = ast.get_source_segment(code, node.test)\n            start_line = node.test.lineno\n            start_col = node.test.col_offset\n            end_line = node.test.end_lineno\n            end_col = node.test.end_col_offset\n            conditions.append(((start_line, start_col), (end_line, end_col)))\n        elif isinstance(node, ast.Expr) and isinstance(node.value, ast.IfExp):\n            condition = ast.get_source_segment(code, node.value.test)\n            start_line = node.value.test.lineno\n            start_col = node.value.test.col_offset\n            end_line = node.value.test.end_lineno\n            end_col = node.value.test.end_col_offset\n            conditions.append(((start_line, s",
        "tart_col), (end_line, end_col))",
        ")\n    return conditions"
    ],
    [
        "def split_indentation(line: str) -> Tuple[str, str]:\n        \"\"\"Separate leading whitespace (indentation) from the rest of the line.\"\"\"\n        indentation_length = len(line) - len(line.ls",
        "trip()",
        ")\n        indentation = line[:indentation_length]\n        code_text = line[indentation_length:]\n        return indentation, code_text"
    ],
    [
        "def extract_function_call_details(lines: List[str], function_call: dict) -> Tuple[str, str, str]:\n        \"\"\"Extract the components of a function call: prefix, arguments, and suffix.\"\"\"\n        current_line, start_idx, end_idx = (\n            function_call['end_line'] - 1,\n            function_call['end_col_offset'] - 2,\n            function_call['end_col_offset'] - 1,\n        )\n        parentheses_balance = 1\n        while parentheses_balance:\n            char = lines[current_line][start_idx]\n            parentheses_balance += 1 if char == ')' else -1 if char == '(' else 0\n            start_idx -= 1\n            if start_idx < 0:\n                current_line -= 1\n                start_idx = len(lines[c",
        "urrent_line]",
        ") - 1\n        prefix = '\\n'.join(lines[function_call['start_line'] - 1:current_line] + [lines[current_line][:start_idx + 2]])\n        arguments = ', '.join(function_call['arguments'])\n        suffix = lines[function_call['end_line'] - 1][end_idx:]\n        return prefix, arguments, suffix"
    ],
    [
        "def extract_function_call_details(lines: List[str], function_call: dict) -> Tuple[str, str, str]:\n        \"\"\"Extract the components of a function call: prefix, arguments, and suffix.\"\"\"\n        current_line, start_idx, end_idx = (\n            function_call['end_line'] - 1,\n            function_call['end_col_offset'] - 2,\n            function_call['end_col_offset'] - 1,\n        )\n        parentheses_balance = 1\n        while parentheses_balance:\n            char = lines[current_line][start_idx]\n            parentheses_balance += 1 if char == ')' else -1 if char == '(' else 0\n            start_idx -= 1\n            if start_idx < 0:\n                current_line -= 1\n                start_idx = len(lines[current_line]) - 1\n        prefix = '\\n'.join(lines[fu",
        "nction_call['start_line'] - 1:current_line] + [lines[current_line][:start_idx + 2]]",
        ")\n        arguments = ', '.join(function_call['arguments'])\n        suffix = lines[function_call['end_line'] - 1][end_idx:]\n        return prefix, arguments, suffix"
    ],
    [
        "def extract_function_call_details(lines: List[str], function_call: dict) -> Tuple[str, str, str]:\n        \"\"\"Extract the components of a function call: prefix, arguments, and suffix.\"\"\"\n        current_line, start_idx, end_idx = (\n            function_call['end_line'] - 1,\n            function_call['end_col_offset'] - 2,\n            function_call['end_col_offset'] - 1,\n        )\n        parentheses_balance = 1\n        while parentheses_balance:\n            char = lines[current_line][start_idx]\n            parentheses_balance += 1 if char == ')' else -1 if char == '(' else 0\n            start_idx -= 1\n            if start_idx < 0:\n                current_line -= 1\n                start_idx = len(lines[current_line]) - 1\n        prefix = '\\n'.join(lines[function_call['start_line'] - 1:current_line] + [lines[current_line][:start_idx + 2]])\n        arguments = ', '.join(function_",
        "call['arguments']",
        ")\n        suffix = lines[function_call['end_line'] - 1][end_idx:]\n        return prefix, arguments, suffix"
    ],
    [
        "def random_split_middle_examples(examples: List[Tuple[str, str, str]], min_left: int = 5, min_right: int = 5) -> List[Tuple[str, str, str]]:\n        \"\"\"Randomly split the middle section of examples with specific constraints.\"\"\"\n        new_examples = []\n        for example in examples:\n            prefix, middle, suffix = example\n            if len(middle) < min_left + min_right:\n                continue\n            while True:\n                split_idx = random.randint(min_left, mi",
        "n_left + (len(middle) - min_right - min_left) // 2 + 1",
        ")\n                if middle[split_idx - 1:split_idx + 1] != r'\\n':\n                    break\n            prefix += middle[:split_idx]\n            middle = middle[split_idx:]\n            new_examples.append((prefix, middle, suffix))\n        return new_examples"
    ],
    [
        "def random_split_middle_examples(examples: List[Tuple[str, str, str]], min_left: int = 5, min_right: int = 5) -> List[Tuple[str, str, str]]:\n        \"\"\"Randomly split the middle section of examples with specific constraints.\"\"\"\n        new_examples = []\n        for example in examples:\n            prefix, middle, suffix = example\n            if len(middle) < min_left + min_right:\n                continue\n            while True:\n                split_idx = random.randint(min_left, min_left + (len(middle) - min_right - min_left) // 2 + 1)\n                if middle[split_idx - 1:split_idx + 1] != r'\\n':\n                    break\n            prefix += middle[:split_idx]\n            middle = middle[split_idx:]\n            new_examples.append((prefix, ",
        "middle, suffix)",
        ")\n        return new_examples"
    ],
    [
        "def extract_lines(block: str, middle_line_count: int = 1, min_context_lines: int = 1, max_context_lines: int = -1) -> List[Tuple[str, str, str]]:\n        \"\"\"Generate examples by extracting specified middle lines with configurable context lines.\"\"\"\n        lines = block.splitlines()\n        num_lines = len(lines)\n        if num_lines < 2 * min_context_lines + middle_line_count:\n            return []\n        examples = []\n        for middle_start in range(min_context_lines, num_lines - mi",
        "n_context_lines - middle_line_count",
        "):\n            middle_end = middle_start + middle_line_count\n            start_prefix = max(0, middle_start - (max_context_lines if max_context_lines >= 0 else middle_start))\n            end_suffix = min(num_lines, middle_end + (max_context_lines if max_context_lines >= 0 else num_lines))\n            indentation, middle_text = TextUtils.split_indentation('\\n'.join(lines[middle_start:middle_end]))\n            prefix = '\\n'.join(lines[start_prefix:middle_start]) + '\\n' + indentation\n            suffix = '\\n' + '\\n'.join(lines[middle_end:end_suffix])\n            examples.append((prefix, middle_text, suffix))\n        return examples"
    ],
    [
        "def extract_lines(block: str, middle_line_count: int = 1, min_context_lines: int = 1, max_context_lines: int = -1) -> List[Tuple[str, str, str]]:\n        \"\"\"Generate examples by extracting specified middle lines with configurable context lines.\"\"\"\n        lines = block.splitlines()\n        num_lines = len(lines)\n        if num_lines < 2 * min_context_lines + middle_line_count:\n            return []\n        examples = []\n        for middle_start in range(min_context_lines, num_lines - min_context_lines - middle_line_count):\n            middle_end = middle_start + middle_line_count\n            start_prefix = max(0, middle_start - (max_context",
        "_lines if max_context_lines >= 0 else middle_start)",
        ")\n            end_suffix = min(num_lines, middle_end + (max_context_lines if max_context_lines >= 0 else num_lines))\n            indentation, middle_text = TextUtils.split_indentation('\\n'.join(lines[middle_start:middle_end]))\n            prefix = '\\n'.join(lines[start_prefix:middle_start]) + '\\n' + indentation\n            suffix = '\\n' + '\\n'.join(lines[middle_end:end_suffix])\n            examples.append((prefix, middle_text, suffix))\n        return examples"
    ],
    [
        "def extract_lines(block: str, middle_line_count: int = 1, min_context_lines: int = 1, max_context_lines: int = -1) -> List[Tuple[str, str, str]]:\n        \"\"\"Generate examples by extracting specified middle lines with configurable context lines.\"\"\"\n        lines = block.splitlines()\n        num_lines = len(lines)\n        if num_lines < 2 * min_context_lines + middle_line_count:\n            return []\n        examples = []\n        for middle_start in range(min_context_lines, num_lines - min_context_lines - middle_line_count):\n            middle_end = middle_start + middle_line_count\n            start_prefix = max(0, middle_start - (max_context_lines if max_context_lines >= 0 else middle_start))\n            end_suffix = min(num_lines, middle_end + (max_context_lin",
        "es if max_context_lines >= 0 else num_lines)",
        ")\n            indentation, middle_text = TextUtils.split_indentation('\\n'.join(lines[middle_start:middle_end]))\n            prefix = '\\n'.join(lines[start_prefix:middle_start]) + '\\n' + indentation\n            suffix = '\\n' + '\\n'.join(lines[middle_end:end_suffix])\n            examples.append((prefix, middle_text, suffix))\n        return examples"
    ],
    [
        "def extract_lines(block: str, middle_line_count: int = 1, min_context_lines: int = 1, max_context_lines: int = -1) -> List[Tuple[str, str, str]]:\n        \"\"\"Generate examples by extracting specified middle lines with configurable context lines.\"\"\"\n        lines = block.splitlines()\n        num_lines = len(lines)\n        if num_lines < 2 * min_context_lines + middle_line_count:\n            return []\n        examples = []\n        for middle_start in range(min_context_lines, num_lines - min_context_lines - middle_line_count):\n            middle_end = middle_start + middle_line_count\n            start_prefix = max(0, middle_start - (max_context_lines if max_context_lines >= 0 else middle_start))\n            end_suffix = min(num_lines, middle_end + (max_context_lines if max_context_lines >= 0 else num_lines))\n            indentation, middle_text = TextUtils.split_indentation('\\n'.join",
        "(lines[middle_start:middle_end])",
        ")\n            prefix = '\\n'.join(lines[start_prefix:middle_start]) + '\\n' + indentation\n            suffix = '\\n' + '\\n'.join(lines[middle_end:end_suffix])\n            examples.append((prefix, middle_text, suffix))\n        return examples"
    ],
    [
        "def extract_lines(block: str, middle_line_count: int = 1, min_context_lines: int = 1, max_context_lines: int = -1) -> List[Tuple[str, str, str]]:\n        \"\"\"Generate examples by extracting specified middle lines with configurable context lines.\"\"\"\n        lines = block.splitlines()\n        num_lines = len(lines)\n        if num_lines < 2 * min_context_lines + middle_line_count:\n            return []\n        examples = []\n        for middle_start in range(min_context_lines, num_lines - min_context_lines - middle_line_count):\n            middle_end = middle_start + middle_line_count\n            start_prefix = max(0, middle_start - (max_context_lines if max_context_lines >= 0 else middle_start))\n            end_suffix = min(num_lines, middle_end + (max_context_lines if max_context_lines >= 0 else num_lines))\n            indentation, middle_text = TextUtils.split_indentation('\\n'.join(lines",
        "[middle_start:middle_end]",
        "))\n            prefix = '\\n'.join(lines[start_prefix:middle_start]) + '\\n' + indentation\n            suffix = '\\n' + '\\n'.join(lines[middle_end:end_suffix])\n            examples.append((prefix, middle_text, suffix))\n        return examples"
    ],
    [
        "def extract_lines(block: str, middle_line_count: int = 1, min_context_lines: int = 1, max_context_lines: int = -1) -> List[Tuple[str, str, str]]:\n        \"\"\"Generate examples by extracting specified middle lines with configurable context lines.\"\"\"\n        lines = block.splitlines()\n        num_lines = len(lines)\n        if num_lines < 2 * min_context_lines + middle_line_count:\n            return []\n        examples = []\n        for middle_start in range(min_context_lines, num_lines - min_context_lines - middle_line_count):\n            middle_end = middle_start + middle_line_count\n            start_prefix = max(0, middle_start - (max_context_lines if max_context_lines >= 0 else middle_start))\n            end_suffix = min(num_lines, middle_end + (max_context_lines if max_context_lines >= 0 else num_lines))\n            indentation, middle_text = TextUtils.split_indentation('\\n'.join(lines[middle_start:middle_end]))\n            prefix = '\\n'.join(lines[",
        "start_prefix:middle_start]",
        ") + '\\n' + indentation\n            suffix = '\\n' + '\\n'.join(lines[middle_end:end_suffix])\n            examples.append((prefix, middle_text, suffix))\n        return examples"
    ],
    [
        "def extract_lines(block: str, middle_line_count: int = 1, min_context_lines: int = 1, max_context_lines: int = -1) -> List[Tuple[str, str, str]]:\n        \"\"\"Generate examples by extracting specified middle lines with configurable context lines.\"\"\"\n        lines = block.splitlines()\n        num_lines = len(lines)\n        if num_lines < 2 * min_context_lines + middle_line_count:\n            return []\n        examples = []\n        for middle_start in range(min_context_lines, num_lines - min_context_lines - middle_line_count):\n            middle_end = middle_start + middle_line_count\n            start_prefix = max(0, middle_start - (max_context_lines if max_context_lines >= 0 else middle_start))\n            end_suffix = min(num_lines, middle_end + (max_context_lines if max_context_lines >= 0 else num_lines))\n            indentation, middle_text = TextUtils.split_indentation('\\n'.join(lines[middle_start:middle_end]))\n            prefix = '\\n'.join(lines[start_prefix:middle_start]) + '\\n' + indentation\n            suffix = '\\n' + '\\n'.join(lines[mid",
        "dle_end:end_suffix]",
        ")\n            examples.append((prefix, middle_text, suffix))\n        return examples"
    ],
    [
        "def extract_lines(block: str, middle_line_count: int = 1, min_context_lines: int = 1, max_context_lines: int = -1) -> List[Tuple[str, str, str]]:\n        \"\"\"Generate examples by extracting specified middle lines with configurable context lines.\"\"\"\n        lines = block.splitlines()\n        num_lines = len(lines)\n        if num_lines < 2 * min_context_lines + middle_line_count:\n            return []\n        examples = []\n        for middle_start in range(min_context_lines, num_lines - min_context_lines - middle_line_count):\n            middle_end = middle_start + middle_line_count\n            start_prefix = max(0, middle_start - (max_context_lines if max_context_lines >= 0 else middle_start))\n            end_suffix = min(num_lines, middle_end + (max_context_lines if max_context_lines >= 0 else num_lines))\n            indentation, middle_text = TextUtils.split_indentation('\\n'.join(lines[middle_start:middle_end]))\n            prefix = '\\n'.join(lines[start_prefix:middle_start]) + '\\n' + indentation\n            suffix = '\\n' + '\\n'.join(lines[middle_end:end_suffix])\n            examples.append((prefix, middle",
        "_text, suffix)",
        ")\n        return examples"
    ],
    [
        "def extract_function_arguments(block: str, max_arguments: int = 5, min_context_lines: int = 1, max_context_lines: int = -1) -> List[Tuple[str, str, str]]:\n        \"\"\"Extract function arguments with specified context and argument count limitations.\"\"\"\n        function_calls = find_function_calls_with_args(block)\n        lines = block.splitlines()\n        num_lines = len(lines)\n        examples = []\n        for call in function_calls:\n            if len(call['a",
        "rguments']",
        ") > max_arguments > 0:\n                continue\n            if call['start_line'] - 1 < min_context_lines or num_lines - call['end_line'] < min_context_lines:\n                continue\n            prefix, middle, suffix = TextUtils.extract_function_call_details(lines, call)\n            if not middle:\n                continue\n            start = max(0, call['start_line'] - 1 - (max_context_lines if max_context_lines >= 0 else call['start_line'] - 1))\n            end = min(num_lines, call['end_line'] + (max_context_lines if max_context_lines >= 0 else num_lines))\n            prefix = '\\n'.join(lines[start:call['start_line'] - 1] + [prefix])\n            suffix = '\\n'.join([suffix] + lines[call['end_line']:end])\n            examples.append((prefix, middle, suffix))\n        return examples"
    ],
    [
        "def extract_function_arguments(block: str, max_arguments: int = 5, min_context_lines: int = 1, max_context_lines: int = -1) -> List[Tuple[str, str, str]]:\n        \"\"\"Extract function arguments with specified context and argument count limitations.\"\"\"\n        function_calls = find_function_calls_with_args(block)\n        lines = block.splitlines()\n        num_lines = len(lines)\n        examples = []\n        for call in function_calls:\n            if len(call['arguments']) > max_arguments > 0:\n                continue\n            if call['start_line'] - 1 < min_context_lines or num_lines - call['end_line'] < min_context_lines:\n                continue\n            prefix, middle, suffix = TextUtils.extract_function_call_details(lines",
        ", call",
        ")\n            if not middle:\n                continue\n            start = max(0, call['start_line'] - 1 - (max_context_lines if max_context_lines >= 0 else call['start_line'] - 1))\n            end = min(num_lines, call['end_line'] + (max_context_lines if max_context_lines >= 0 else num_lines))\n            prefix = '\\n'.join(lines[start:call['start_line'] - 1] + [prefix])\n            suffix = '\\n'.join([suffix] + lines[call['end_line']:end])\n            examples.append((prefix, middle, suffix))\n        return examples"
    ],
    [
        "def extract_function_arguments(block: str, max_arguments: int = 5, min_context_lines: int = 1, max_context_lines: int = -1) -> List[Tuple[str, str, str]]:\n        \"\"\"Extract function arguments with specified context and argument count limitations.\"\"\"\n        function_calls = find_function_calls_with_args(block)\n        lines = block.splitlines()\n        num_lines = len(lines)\n        examples = []\n        for call in function_calls:\n            if len(call['arguments']) > max_arguments > 0:\n                continue\n            if call['start_line'] - 1 < min_context_lines or num_lines - call['end_line'] < min_context_lines:\n                continue\n            prefix, middle, suffix = TextUtils.extract_function_call_details(lines, call)\n            if not middle:\n                continue\n            start = max(0, call['",
        "start_line'] - 1 - (max_context_lines if max_context_lines >= 0 else call['start_line'] - 1)",
        ")\n            end = min(num_lines, call['end_line'] + (max_context_lines if max_context_lines >= 0 else num_lines))\n            prefix = '\\n'.join(lines[start:call['start_line'] - 1] + [prefix])\n            suffix = '\\n'.join([suffix] + lines[call['end_line']:end])\n            examples.append((prefix, middle, suffix))\n        return examples"
    ],
    [
        "def extract_function_arguments(block: str, max_arguments: int = 5, min_context_lines: int = 1, max_context_lines: int = -1) -> List[Tuple[str, str, str]]:\n        \"\"\"Extract function arguments with specified context and argument count limitations.\"\"\"\n        function_calls = find_function_calls_with_args(block)\n        lines = block.splitlines()\n        num_lines = len(lines)\n        examples = []\n        for call in function_calls:\n            if len(call['arguments']) > max_arguments > 0:\n                continue\n            if call['start_line'] - 1 < min_context_lines or num_lines - call['end_line'] < min_context_lines:\n                continue\n            prefix, middle, suffix = TextUtils.extract_function_call_details(lines, call)\n            if not middle:\n                continue\n            start = max(0, call['start_line'] - 1 - (max_context_lines if max_context_lines >= 0 else call['start_line'] - 1))\n            end = min(num_lines, call['end_line'",
        "] + (max_context_lines if max_context_lines >= 0 else num_lines)",
        ")\n            prefix = '\\n'.join(lines[start:call['start_line'] - 1] + [prefix])\n            suffix = '\\n'.join([suffix] + lines[call['end_line']:end])\n            examples.append((prefix, middle, suffix))\n        return examples"
    ],
    [
        "def extract_function_arguments(block: str, max_arguments: int = 5, min_context_lines: int = 1, max_context_lines: int = -1) -> List[Tuple[str, str, str]]:\n        \"\"\"Extract function arguments with specified context and argument count limitations.\"\"\"\n        function_calls = find_function_calls_with_args(block)\n        lines = block.splitlines()\n        num_lines = len(lines)\n        examples = []\n        for call in function_calls:\n            if len(call['arguments']) > max_arguments > 0:\n                continue\n            if call['start_line'] - 1 < min_context_lines or num_lines - call['end_line'] < min_context_lines:\n                continue\n            prefix, middle, suffix = TextUtils.extract_function_call_details(lines, call)\n            if not middle:\n                continue\n            start = max(0, call['start_line'] - 1 - (max_context_lines if max_context_lines >= 0 else call['start_line'] - 1))\n            end = min(num_lines, call['end_line'] + (max_context_lines if max_context_lines >= 0 else num_lines))\n            prefix = '\\n'.join(lines[start:call['start_",
        "line'] - 1] + [prefix]",
        ")\n            suffix = '\\n'.join([suffix] + lines[call['end_line']:end])\n            examples.append((prefix, middle, suffix))\n        return examples"
    ],
    [
        "def extract_function_arguments(block: str, max_arguments: int = 5, min_context_lines: int = 1, max_context_lines: int = -1) -> List[Tuple[str, str, str]]:\n        \"\"\"Extract function arguments with specified context and argument count limitations.\"\"\"\n        function_calls = find_function_calls_with_args(block)\n        lines = block.splitlines()\n        num_lines = len(lines)\n        examples = []\n        for call in function_calls:\n            if len(call['arguments']) > max_arguments > 0:\n                continue\n            if call['start_line'] - 1 < min_context_lines or num_lines - call['end_line'] < min_context_lines:\n                continue\n            prefix, middle, suffix = TextUtils.extract_function_call_details(lines, call)\n            if not middle:\n                continue\n            start = max(0, call['start_line'] - 1 - (max_context_lines if max_context_lines >= 0 else call['start_line'] - 1))\n            end = min(num_lines, call['end_line'] + (max_context_lines if max_context_lines >= 0 else num_lines))\n            prefix = '\\n'.join(lines[start:call['start_line'] - 1] + [prefix])\n            suffix = '\\n'.join([suffi",
        "x] + lines[call['end_line']:end]",
        ")\n            examples.append((prefix, middle, suffix))\n        return examples"
    ],
    [
        "def extract_function_arguments(block: str, max_arguments: int = 5, min_context_lines: int = 1, max_context_lines: int = -1) -> List[Tuple[str, str, str]]:\n        \"\"\"Extract function arguments with specified context and argument count limitations.\"\"\"\n        function_calls = find_function_calls_with_args(block)\n        lines = block.splitlines()\n        num_lines = len(lines)\n        examples = []\n        for call in function_calls:\n            if len(call['arguments']) > max_arguments > 0:\n                continue\n            if call['start_line'] - 1 < min_context_lines or num_lines - call['end_line'] < min_context_lines:\n                continue\n            prefix, middle, suffix = TextUtils.extract_function_call_details(lines, call)\n            if not middle:\n                continue\n            start = max(0, call['start_line'] - 1 - (max_context_lines if max_context_lines >= 0 else call['start_line'] - 1))\n            end = min(num_lines, call['end_line'] + (max_context_lines if max_context_lines >= 0 else num_lines))\n            prefix = '\\n'.join(lines[start:call['start_line'] - 1] + [prefix])\n            suffix = '\\n'.join([suffix] + lines[call['end_line']:end])\n            examples.append((prefix, mi",
        "ddle, suffix)",
        ")\n        return examples"
    ],
    [
        "def extract_section(lines: List[str], start_pos: (int, int), end_pos: (int, int), max_characters: int = -1,\n                        min_context_lines: int = 1, max_context_lines: int = -1) -> Tuple[str, str, str]:\n        num_lines = len(lines)\n        start_line, start_idx = start_pos[0] - 1, start_pos[1]\n        end_line, end_idx = end_pos[0] - 1, end_pos[1]\n        if start_line < min_context_lines or num_lines - end_line - 1 < min_context_lines:\n            return None\n        middle_text = (\n            lines[start_line][start_idx:end_idx] if start_line == end_line\n            else '\\n'.join([lines[start_line][start_i",
        "dx:]] + lines[start_line + 1:end_line] + [lines[end_line][:end_idx]]",
        ")\n        )\n        if 0 < max_characters < len(middle_text):\n            return None\n        start = max(0, start_line - (max_context_lines if max_context_lines >= 0 else start_line))\n        end = min(num_lines, end_line + 1 + (max_context_lines if max_context_lines >= 0 else num_lines))\n        prefix = '\\n'.join(lines[start:start_line] + [lines[start_line][:start_idx]])\n        suffix = '\\n'.join([lines[end_line][end_idx:]] + lines[end_line + 1:end])\n        return prefix, middle_text, suffix"
    ],
    [
        "def extract_section(lines: List[str], start_pos: (int, int), end_pos: (int, int), max_characters: int = -1,\n                        min_context_lines: int = 1, max_context_lines: int = -1) -> Tuple[str, str, str]:\n        num_lines = len(lines)\n        start_line, start_idx = start_pos[0] - 1, start_pos[1]\n        end_line, end_idx = end_pos[0] - 1, end_pos[1]\n        if start_line < min_context_lines or num_lines - end_line - 1 < min_context_lines:\n            return None\n        middle_text = (\n            lines[start_line][start_idx:end_idx] if start_line == end_line\n            else '\\n'.join(\n                [lines[start_line][start_idx:]] + lines[start_line + 1:end_line] + [lines[end_line][:end_idx]]\n            )\n        )\n        if 0 < max_characters < len(middl",
        "e_text",
        "):\n            return None\n        start = max(0, start_line - (max_context_lines if max_context_lines >= 0 else start_line))\n        end = min(num_lines, end_line + 1 + (max_context_lines if max_context_lines >= 0 else num_lines))\n        prefix = '\\n'.join(lines[start:start_line] + [lines[start_line][:start_idx]])\n        suffix = '\\n'.join([lines[end_line][end_idx:]] + lines[end_line + 1:end])\n        return prefix, middle_text, suffix"
    ],
    [
        "def extract_section(lines: List[str], start_pos: (int, int), end_pos: (int, int), max_characters: int = -1,\n                        min_context_lines: int = 1, max_context_lines: int = -1) -> Tuple[str, str, str]:\n        num_lines = len(lines)\n        start_line, start_idx = start_pos[0] - 1, start_pos[1]\n        end_line, end_idx = end_pos[0] - 1, end_pos[1]\n        if start_line < min_context_lines or num_lines - end_line - 1 < min_context_lines:\n            return None\n        middle_text = (\n            lines[start_line][start_idx:end_idx] if start_line == end_line\n            else '\\n'.join(\n                [lines[start_line][start_idx:]] + lines[start_line + 1:end_line] + [lines[end_line][:end_idx]]\n            )\n        )\n        if 0 < max_characters < len(middle_text):\n            return None\n        start = max(0, start_line - ",
        "(max_context_lines if max_context_lines >= 0 else start_line)",
        ")\n        end = min(num_lines, end_line + 1 + (max_context_lines if max_context_lines >= 0 else num_lines))\n        prefix = '\\n'.join(lines[start:start_line] + [lines[start_line][:start_idx]])\n        suffix = '\\n'.join([lines[end_line][end_idx:]] + lines[end_line + 1:end])\n        return prefix, middle_text, suffix"
    ],
    [
        "def extract_section(lines: List[str], start_pos: (int, int), end_pos: (int, int), max_characters: int = -1,\n                        min_context_lines: int = 1, max_context_lines: int = -1) -> Tuple[str, str, str]:\n        num_lines = len(lines)\n        start_line, start_idx = start_pos[0] - 1, start_pos[1]\n        end_line, end_idx = end_pos[0] - 1, end_pos[1]\n        if start_line < min_context_lines or num_lines - end_line - 1 < min_context_lines:\n            return None\n        middle_text = (\n            lines[start_line][start_idx:end_idx] if start_line == end_line\n            else '\\n'.join(\n                [lines[start_line][start_idx:]] + lines[start_line + 1:end_line] + [lines[end_line][:end_idx]]\n            )\n        )\n        if 0 < max_characters < len(middle_text):\n            return None\n        start = max(0, start_line - (max_context_lines if max_context_lines >= 0 else start_line))\n        end = min(num_lines, end_line + 1 + (max_",
        "context_lines if max_context_lines >= 0 else num_lines)",
        ")\n        prefix = '\\n'.join(lines[start:start_line] + [lines[start_line][:start_idx]])\n        suffix = '\\n'.join([lines[end_line][end_idx:]] + lines[end_line + 1:end])\n        return prefix, middle_text, suffix"
    ],
    [
        "def extract_section(lines: List[str], start_pos: (int, int), end_pos: (int, int), max_characters: int = -1,\n                        min_context_lines: int = 1, max_context_lines: int = -1) -> Tuple[str, str, str]:\n        num_lines = len(lines)\n        start_line, start_idx = start_pos[0] - 1, start_pos[1]\n        end_line, end_idx = end_pos[0] - 1, end_pos[1]\n        if start_line < min_context_lines or num_lines - end_line - 1 < min_context_lines:\n            return None\n        middle_text = (\n            lines[start_line][start_idx:end_idx] if start_line == end_line\n            else '\\n'.join(\n                [lines[start_line][start_idx:]] + lines[start_line + 1:end_line] + [lines[end_line][:end_idx]]\n            )\n        )\n        if 0 < max_characters < len(middle_text):\n            return None\n        start = max(0, start_line - (max_context_lines if max_context_lines >= 0 else start_line))\n        end = min(num_lines, end_line + 1 + (max_context_lines if max_context_lines >= 0 else num_lines))\n        prefix = '\\n'.join(lines[start:start_line] + [li",
        "nes[start_line][:start_idx]]",
        ")\n        suffix = '\\n'.join([lines[end_line][end_idx:]] + lines[end_line + 1:end])\n        return prefix, middle_text, suffix"
    ],
    [
        "def extract_section(lines: List[str], start_pos: (int, int), end_pos: (int, int), max_characters: int = -1,\n                        min_context_lines: int = 1, max_context_lines: int = -1) -> Tuple[str, str, str]:\n        num_lines = len(lines)\n        start_line, start_idx = start_pos[0] - 1, start_pos[1]\n        end_line, end_idx = end_pos[0] - 1, end_pos[1]\n        if start_line < min_context_lines or num_lines - end_line - 1 < min_context_lines:\n            return None\n        middle_text = (\n            lines[start_line][start_idx:end_idx] if start_line == end_line\n            else '\\n'.join(\n                [lines[start_line][start_idx:]] + lines[start_line + 1:end_line] + [lines[end_line][:end_idx]]\n            )\n        )\n        if 0 < max_characters < len(middle_text):\n            return None\n        start = max(0, start_line - (max_context_lines if max_context_lines >= 0 else start_line))\n        end = min(num_lines, end_line + 1 + (max_context_lines if max_context_lines >= 0 else num_lines))\n        prefix = '\\n'.join(lines[start:start_line] + [lines[start_line][:start_idx]])\n        suffix = '\\n'.join([lines[e",
        "nd_line][end_idx:]] + lines[end_line + 1:end]",
        ")\n        return prefix, middle_text, suffix"
    ],
    [
        "def extract_assignment_sections(block: str, max_characters: int = 100, min_context_lines: int = 1, max_context_lines: int = -1) -> List[Tuple[str, str, str]]:\n        \"\"\"Extract assignment sections with character limit and surrounding context.\"\"\"\n        assignments = find_assignments(block)\n        lines = block.splitlines()\n        examples = []\n        for start_pos, end_pos in assignments:\n            result = CodeSegmentExtractor.extract_section(lines, start_pos, end_pos, max_charac",
        "ters, min_context_lines, max_context_lines",
        ")\n            if result:\n                examples.append(result)\n        return examples"
    ],
    [
        "def extract_condition_sections(block: str, max_characters: int = 100, min_context_lines: int = 1, max_context_lines: int = -1) -> List[Tuple[str, str, str]]:\n        \"\"\"Extract condition sections with character limit and surrounding context.\"\"\"\n        conditions = find_conditions(block)\n        lines = block.splitlines()\n        examples = []\n        for start_pos, end_pos in conditions:\n            result = CodeSegmentExtractor.extract_section(lines, start_pos, end_pos, max_charac",
        "ters, min_context_lines, max_context_lines",
        ")\n            if result:\n                examples.append(result)\n        return examples"
    ],
    [
        "def extract_datasets(\n        code_blocks: List[str],\n        max_values: List[int],\n        max_context_lines: List[int],\n        dataset_type: str,\n        extract_method: Callable[[str, Any, Any], List[Tuple[str, str, str]]]\n    ) -> List[Tuple[str, List[Tuple[str, str, str]]]]:\n        datasets = []\n        for max_value in max_values:\n            for max_context in max_context_lines:\n                dataset_name = f'{dataset_type}_{max_value}_{max_context}'\n                examples = []\n                for block in code_blocks:\n                    examples.extend(extract_meth",
        "od(block, max_value, max_context)",
        ")\n                if examples:\n                    datasets.append((dataset_name, examples))\n                    random_split_name = f'random_split_{dataset_type}_{max_value}_{max_context}'\n                    examples_split = TextUtils.random_split_middle_examples(examples, min_left=5, min_right=5)\n                    if examples_split:\n                        datasets.append((random_split_name, examples_split))\n        return datasets"
    ],
    [
        "def extract_datasets(\n        code_blocks: List[str],\n        max_values: List[int],\n        max_context_lines: List[int],\n        dataset_type: str,\n        extract_method: Callable[[str, Any, Any], List[Tuple[str, str, str]]]\n    ) -> List[Tuple[str, List[Tuple[str, str, str]]]]:\n        datasets = []\n        for max_value in max_values:\n            for max_context in max_context_lines:\n                dataset_name = f'{dataset_type}_{max_value}_{max_context}'\n                examples = []\n                for block in code_blocks:\n                    examples.extend(extract_method(block, m",
        "ax_value, max_context",
        "))\n                if examples:\n                    datasets.append((dataset_name, examples))\n                    random_split_name = f'random_split_{dataset_type}_{max_value}_{max_context}'\n                    examples_split = TextUtils.random_split_middle_examples(examples, min_left=5, min_right=5)\n                    if examples_split:\n                        datasets.append((random_split_name, examples_split))\n        return datasets"
    ],
    [
        "def extract_datasets(\n        code_blocks: List[str],\n        max_values: List[int],\n        max_context_lines: List[int],\n        dataset_type: str,\n        extract_method: Callable[[str, Any, Any], List[Tuple[str, str, str]]]\n    ) -> List[Tuple[str, List[Tuple[str, str, str]]]]:\n        datasets = []\n        for max_value in max_values:\n            for max_context in max_context_lines:\n                dataset_name = f'{dataset_type}_{max_value}_{max_context}'\n                examples = []\n                for block in code_blocks:\n                    examples.extend(extract_method(block, max_value, max_context))\n                if examples:\n                    datasets.append((dataset_",
        "name, examples)",
        ")\n                    random_split_name = f'random_split_{dataset_type}_{max_value}_{max_context}'\n                    examples_split = TextUtils.random_split_middle_examples(examples, min_left=5, min_right=5)\n                    if examples_split:\n                        datasets.append((random_split_name, examples_split))\n        return datasets"
    ],
    [
        "def extract_datasets(\n        code_blocks: List[str],\n        max_values: List[int],\n        max_context_lines: List[int],\n        dataset_type: str,\n        extract_method: Callable[[str, Any, Any], List[Tuple[str, str, str]]]\n    ) -> List[Tuple[str, List[Tuple[str, str, str]]]]:\n        datasets = []\n        for max_value in max_values:\n            for max_context in max_context_lines:\n                dataset_name = f'{dataset_type}_{max_value}_{max_context}'\n                examples = []\n                for block in code_blocks:\n                    examples.extend(extract_method(block, max_value, max_context))\n                if examples:\n                    datasets.append((dataset_name, examples))\n                    random_split_name = f'random_split_{dataset_type}_{max_value}_{max_context}'\n                    examples_split = TextUtils.random_split_middle_examples(examples, min_left=5, min_right=5)\n                    if examples_split:\n                        datasets.append((random_s",
        "plit_name, examples_split)",
        ")\n        return datasets"
    ],
    [
        "def rouge_score(self, generated, expected):\n        scores = self.rouge.get_scores(generated,",
        " expected",
        ")[0]\n        return scores['rouge-l']['f']"
    ],
    [
        "def meteor_score(self, generated, expected):\n        try:\n            generated_tokens = nltk.word_tokenize(generated)\n            expected_tokens = nltk.word_tokenize(expected)\n            return meteor_score([expe",
        "cted_tokens], generated_tokens",
        ")\n        except Exception as e:\n            print(f\"Error calculating METEOR score: {e}\")\n            return None"
    ],
    [
        "def meteor_score(self, generated, expected):\n        try:\n            generated_tokens = nltk.word_tokenize(generated)\n            expected_tokens = nltk.word_tokenize(expected)\n            return meteor_score([expected_tokens], generated_tokens)\n        except Exception as e:\n            print(f\"Error ",
        "calculating METEOR score: {e}\"",
        ")\n            return None"
    ],
    [
        "def chrf_score(self, generated, expected):\n        try:\n            return sacrebleu.sentence_chrf(generated, ",
        "[expected]",
        ").score / 100.0\n        except Exception as e:\n            print(f\"Error calculating chrF score: {e}\")\n            return None"
    ],
    [
        "def chrf_score(self, generated, expected):\n        try:\n            return sacrebleu.sentence_chrf(generated, [expected]).score / 100.0\n        except Exception as e:\n            print(f\"Err",
        "or calculating chrF score: {e}\"",
        ")\n            return None"
    ],
    [
        "def bert_score(self, generated, expected):\n        try:\n            P, R, F1 = bert_score([genera",
        "ted], [expected]",
        ")\n            return F1.item()\n        except Exception as e:\n            print(f\"Error calculating BERTScore: {e}\")\n            return None"
    ],
    [
        "def bert_score(self, generated, expected):\n        try:\n            P, R, F1 = bert_score([generated], [expected], lang='en', rescale_with_baseline=True)\n            return F1.item()\n        except Exception as e:\n            print(f\"Error cal",
        "culating BERTScore: {e}\"",
        ")\n            return None"
    ],
    [
        "def evaluate(self, generated, expected, check_syntax=False):\n        results = {}\n        results['exact_match'] = self.exact_match(generated",
        ", expected",
        ")\n        results['chrf'] = self.chrf_score(generated, expected)\n        results['bleu'] = self.bleu_score(generated, expected)\n        results['rouge'] = self.rouge_score(generated, expected)\n        results['meteor'] = self.meteor_score(generated, expected)\n        results['bert'] = self.bert_score(generated, expected)\n        if check_syntax:\n            results['syntax_valid'] = self.syntax_validity(generated)\n        return results"
    ],
    [
        "def evaluate(self, generated, expected, check_syntax=False):\n        results = {}\n        results['exact_match'] = self.exact_match(generated, expected)\n        results['chrf'] = self.chrf_score(generated",
        ", expected",
        ")\n        results['bleu'] = self.bleu_score(generated, expected)\n        results['rouge'] = self.rouge_score(generated, expected)\n        results['meteor'] = self.meteor_score(generated, expected)\n        results['bert'] = self.bert_score(generated, expected)\n        if check_syntax:\n            results['syntax_valid'] = self.syntax_validity(generated)\n        return results"
    ],
    [
        "def evaluate(self, generated, expected, check_syntax=False):\n        results = {}\n        results['exact_match'] = self.exact_match(generated, expected)\n        results['chrf'] = self.chrf_score(generated, expected)\n        results['bleu'] = self.bleu_score(generated,",
        " expected",
        ")\n        results['rouge'] = self.rouge_score(generated, expected)\n        results['meteor'] = self.meteor_score(generated, expected)\n        results['bert'] = self.bert_score(generated, expected)\n        if check_syntax:\n            results['syntax_valid'] = self.syntax_validity(generated)\n        return results"
    ],
    [
        "def evaluate(self, generated, expected, check_syntax=False):\n        results = {}\n        results['exact_match'] = self.exact_match(generated, expected)\n        results['chrf'] = self.chrf_score(generated, expected)\n        results['bleu'] = self.bleu_score(generated, expected)\n        results['rouge'] = self.rouge_score(gener",
        "ated, expected",
        ")\n        results['meteor'] = self.meteor_score(generated, expected)\n        results['bert'] = self.bert_score(generated, expected)\n        if check_syntax:\n            results['syntax_valid'] = self.syntax_validity(generated)\n        return results"
    ],
    [
        "def evaluate(self, generated, expected, check_syntax=False):\n        results = {}\n        results['exact_match'] = self.exact_match(generated, expected)\n        results['chrf'] = self.chrf_score(generated, expected)\n        results['bleu'] = self.bleu_score(generated, expected)\n        results['rouge'] = self.rouge_score(generated, expected)\n        results['meteor'] = self.meteor_score(generat",
        "ed, expected",
        ")\n        results['bert'] = self.bert_score(generated, expected)\n        if check_syntax:\n            results['syntax_valid'] = self.syntax_validity(generated)\n        return results"
    ],
    [
        "def evaluate(self, generated, expected, check_syntax=False):\n        results = {}\n        results['exact_match'] = self.exact_match(generated, expected)\n        results['chrf'] = self.chrf_score(generated, expected)\n        results['bleu'] = self.bleu_score(generated, expected)\n        results['rouge'] = self.rouge_score(generated, expected)\n        results['meteor'] = self.meteor_score(generated, expected)\n        results['bert'] = self.bert_score(genera",
        "ted, expected",
        ")\n        if check_syntax:\n            results['syntax_valid'] = self.syntax_validity(generated)\n        return results"
    ],
    [
        "def evaluate_multi(self, generated: List[str], expected: List[str], check_syntax=False):\n        length = len(generated)\n        if length != len(expected):\n            return None\n        total = defaultdict(float)\n        counts = defaultdict(int)\n        for gen, exp in zip(generat",
        "ed, expected",
        "):\n            for key, value in self.evaluate(gen, exp, check_syntax).items():\n                if value is not None:\n                    total[key] += value\n                    counts[key] += 1\n        averaged = {key: (total[key] / counts[key]) if counts[key] > 0 else None for key in total}\n        return averaged"
    ],
    [
        "def evaluate_multi(self, generated: List[str], expected: List[str], check_syntax=False):\n        length = len(generated)\n        if length != len(expected):\n            return None\n        total = defaultdict(float)\n        counts = defaultdict(int)\n        for gen, exp in zip(generated, expected):\n            for key, value in self.evaluate(gen, exp, ",
        "check_syntax",
        ").items():\n                if value is not None:\n                    total[key] += value\n                    counts[key] += 1\n        averaged = {key: (total[key] / counts[key]) if counts[key] > 0 else None for key in total}\n        return averaged"
    ]
]